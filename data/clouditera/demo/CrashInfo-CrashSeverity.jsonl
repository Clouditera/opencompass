{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2064==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abca (0x1ad7f29bbd0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fc325539887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5556a088b696 in hi_malloc /sourcecode/alloc.h:59\n    #2 0x5556a0894880 in sds_malloc /sourcecode/sds.c:1114\n    #3 0x5556a08897b4 in fuzzloop /dockerin/fuzz_drivers/tf1728369139883gumo.c:25\n    #4 0x5556a089d2d9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==2064==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Dhiredis_EXPORTS\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: sds_malloc\n// Sign: sds_malloc(size_t size)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"fmacros.h\" //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <ctype.h> //extract\n#include <assert.h> //extract\n#include <limits.h> //extract\n#include \"sds.h\" //extract\n#include \"sdsalloc.h\" //extract\n\nint fuzzloop() {\n    size_t size = (size_t)fuzzUint64(0);\n    void * ret = sds_malloc(size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/alloc.h\n  58: static inline void *hi_malloc(size_t size) {\n  59:     return hiredisAllocFns.mallocFn(size);\n  60: }\n  61: \nStacktrace #1:\nFile: /sourcecode/sds.c\n1114: void *sds_malloc(size_t size) { return s_malloc(size); }\n1115:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==23494==ERROR: AddressSanitizer: requested allocation size 0x431bde82d790 (0x431bde82e790 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fa0dc167887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7fa0db86efca in CRYPTO_malloc crypto/mem.c:202\n    #2 0x7fa0db86f07c in CRYPTO_zalloc crypto/mem.c:222\n    #3 0x5604c1c3c2b6 in ssl_cert_new ssl/ssl_cert.c:74\n    #4 0x5604c1c3b98f in fuzzloop /dockerin/fuzz_drivers/tf1730183726839udqm.c:47\n    #5 0x5604c1e44a69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==23494==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:24:53\n// Signature: tls1_set_sigalgs(CERT *c, int *psig_nids, size_t salglen, int client)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: tls1_set_sigalgs\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Issl -DAES_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdio.h> //extract\n#include <sys/types.h> //extract\n#include \"internal/nelem.h\" //extract\n#include \"internal/o_dir.h\" //extract\n#include <openssl/bio.h> //extract\n#include <openssl/pem.h> //extract\n#include <openssl/store.h> //extract\n#include <openssl/x509v3.h> //extract\n#include <openssl/dh.h> //extract\n#include <openssl/bn.h> //extract\n#include <openssl/crypto.h> //extract\n#include \"internal/refcount.h\" //extract\n#include \"ssl_local.h\" //extract\n#include \"ssl_cert_table.h\" //extract\n#include \"internal/thread_once.h\" //extract\n# include <sys/stat.h> //extract\n#include <stdlib.h> //extract\n#include <openssl/objects.h> //extract\n#include <openssl/evp.h> //extract\n#include <openssl/hmac.h> //extract\n#include <openssl/core_names.h> //extract\n#include <openssl/ocsp.h> //extract\n#include <openssl/conf.h> //extract\n#include <openssl/provider.h> //extract\n#include <openssl/param_build.h> //extract\n#include \"internal/sizes.h\" //extract\n#include \"internal/tlsgroups.h\" //extract\n#include \"quic/quic_local.h\" //extract\n#include <openssl/ct.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    size_t ssl_pkey_num = (size_t)fuzzUint64(0);\n    CERT * c = ssl_cert_new(ssl_pkey_num);\n    if (c == NULL)\n        return 0;\n    int * psig_nids = (int *)fuzzFixBlob(1, 1 * sizeof(int));\n    size_t salglen = (size_t)fuzzUint64(2);\n    int client = fuzzInt32(3);\n    int ret = tls1_set_sigalgs(c, psig_nids, salglen, client);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/mem.c\n 177: void *CRYPTO_malloc(size_t num, const char *file, int line)\n 178: {\n 179:     void *ptr;\n 180: \n 181:     INCREMENT(malloc_count);\n 182:     if (malloc_impl != CRYPTO_malloc) {\n 183:         ptr = malloc_impl(num, file, line);\n 184:         if (ptr != NULL || num == 0)\n 185:             return ptr;\n 186:         goto err;\n 187:     }\n 188: \n 189:     if (num == 0)\n 190:         return NULL;\n 191: \n 192:     FAILTEST();\n 193:     if (allow_customize) {\n 194:         /*\n 195:          * Disallow customization after the first allocation. We only set this\n 196:          * if necessary to avoid a store to the same cache line on every\n 197:          * allocation.\n 198:          */\n 199:         allow_customize = 0;\n 200:     }\n 201: \n 202:     ptr = malloc(num);\n 203:     if (ptr != NULL)\n 204:         return ptr;\n 205:  err:\n 206:     /*\n 207:      * ossl_err_get_state_int() in err.c uses CRYPTO_zalloc(num, NULL, 0) for\n 208:      * ERR_STATE allocation. Prevent mem alloc error loop while reporting error.\n 209:      */\n 210:     if (file != NULL || line != 0) {\n 211:         ERR_new();\n 212:         ERR_set_debug(file, line, NULL);\n 213:         ERR_set_error(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE, NULL);\n 214:     }\n 215:     return NULL;\n 216: }\n 217: \nStacktrace #1:\nFile: /sourcecode/crypto/mem.c\n 218: void *CRYPTO_zalloc(size_t num, const char *file, int line)\n 219: {\n 220:     void *ret;\n 221: \n 222:     ret = CRYPTO_malloc(num, file, line);\n 223:     if (ret != NULL)\n 224:         memset(ret, 0, num);\n 225: \n 226:     return ret;\n 227: }\n 228: \nStacktrace #2:\nFile: /sourcecode/ssl/ssl_cert.c\n  61: CERT *ssl_cert_new(size_t ssl_pkey_num)\n  62: {\n  63:     CERT *ret = NULL;\n  64: \n  65:     /* Should never happen */\n  66:     if (!ossl_assert(ssl_pkey_num >= SSL_PKEY_NUM))\n  67:         return NULL;\n  68: \n  69:     ret = OPENSSL_zalloc(sizeof(*ret));\n  70:     if (ret == NULL)\n  71:         return NULL;\n  72: \n  73:     ret->ssl_pkey_num = ssl_pkey_num;\n  74:     ret->pkeys = OPENSSL_zalloc(ret->ssl_pkey_num * sizeof(CERT_PKEY));\n  75:     if (ret->pkeys == NULL) {\n  76:         OPENSSL_free(ret);\n  77:         return NULL;\n  78:     }\n  79: \n  80:     ret->key = &(ret->pkeys[SSL_PKEY_RSA]);\n  81:     ret->sec_cb = ssl_security_default_callback;\n  82:     ret->sec_level = OPENSSL_TLS_SECURITY_LEVEL;\n  83:     ret->sec_ex = NULL;\n  84:     if (!CRYPTO_NEW_REF(&ret->references, 1)) {\n  85:         OPENSSL_free(ret->pkeys);\n  86:         OPENSSL_free(ret);\n  87:         return NULL;\n  88:     }\n  89: \n  90:     return ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n#0 0x7fcadf6d2f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x564c8822f604 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7fcadf6d8e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7fcadf63e60b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7fcadf63a19a in __asan::asan_malloc(unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:980\n    #5 0x7fcadf6c6861 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:146\n    #6 0x564c881e176e in real_malloc /sourcecode/src/stdlib/SDL_malloc.c:5196\n    #7 0x564c881e1d4b in SDL_malloc_REAL /sourcecode/src/stdlib/SDL_malloc.c:5295\n    #8 0x564c87adbd18 in SDL_SIMDAlloc_REAL /sourcecode/src/cpuinfo/SDL_cpuinfo.c:1169\n    #9 0x564c87dd94db in SDL_CreateRGBSurfaceWithFormat_REAL /sourcecode/src/video/SDL_surface.c:156\n    #10 0x564c87dd9b6e in SDL_CreateRGBSurface_REAL /sourcecode/src/video/SDL_surface.c:201\n    #11 0x564c88222f10 in SDL_CreateCursor_REAL /sourcecode/src/events/SDL_mouse.c:1295\n    #12 0x564c8797570a in SDL_CreateCursor_DEFAULT /sourcecode/src/dynapi/SDL_dynapi_procs.h:285\n    #13 0x564c87983463 in SDL_CreateCursor /sourcecode/src/dynapi/SDL_dynapi_procs.h:285\n    #14 0x564c87972a5d in fuzzloop /dockerin/fuzz_drivers/tf1728900799110xlrq.c:30\n    #15 0x564c8822e279 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #16 0x564c879727c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #17 0x7fcadf412d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #18 0x7fcadf412e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #19 0x564c87972914 in _start (/dockerin/fuzz_drivers/tf1728900799110xlrq.out+0xc77914)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/dynapi -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_mouse.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_mouse.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_SetCursor\n// Sign: SDL_SetCursor(SDL_Cursor *a)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"SDL_config.h\" //extract\n#include \"SDL_dynapi.h\" //extract\n#include \"SDL.h\" //extract\n#include \"SDL_syswm.h\" //extract\n#include \"SDL_vulkan.h\" //extract\n#include \"build/include/SDL2/SDL_mouse.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned char * a = (unsigned char *)fuzzData(0);\n    unsigned char * b = (unsigned char *)fuzzData(1);\n    int c = fuzzInt32(2);\n    int d = fuzzInt32(3);\n    int e = fuzzInt32(4);\n    int f = fuzzInt32(5);\n    SDL_Cursor * a1 = SDL_CreateCursor(a, b, c, d, e, f);\n    if (a1 == NULL)\n        return 0;\n    SDL_SetCursor(a1);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5196: static void* SDLCALL real_malloc(size_t s) { return malloc(s); }\n5197: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5287: void *SDL_malloc(size_t size)\n5288: {\n5289:     void *mem;\n5290: \n5291:     if (!size) {\n5292:         size = 1;\n5293:     }\n5294: \n5295:     mem = s_mem.malloc_func(size);\n5296:     if (mem) {\n5297:         SDL_AtomicIncRef(&s_mem.num_allocations);\n5298:     }\n5299:     return mem;\n5300: }\n5301: \nStacktrace #2:\nFile: /sourcecode/src/cpuinfo/SDL_cpuinfo.c\n1155: void *SDL_SIMDAlloc(const size_t len)\n1156: {\n1157:     const size_t alignment = SDL_SIMDGetAlignment();\n1158:     const size_t padding = (alignment - (len % alignment)) % alignment;\n1159:     Uint8 *retval = NULL;\n1160:     Uint8 *ptr;\n1161:     size_t to_allocate;\n1162: \n1163:     /* alignment + padding + sizeof(void *) is bounded (a few hundred\n1164:      * bytes max), so no need to check for overflow within that argument */\n1165:     if (SDL_size_add_overflow(len, alignment + padding + sizeof(void *), &to_allocate)) {\n1166:         return NULL;\n1167:     }\n1168: \n1169:     ptr = (Uint8 *)SDL_malloc(to_allocate);\n1170:     if (ptr) {\n1171:         /* store the actual allocated pointer right before our aligned pointer. */\n1172:         retval = ptr + sizeof(void *);\n1173:         retval += alignment - (((size_t)retval) % alignment);\n1174:         *(((void **)retval) - 1) = ptr;\n1175:     }\n1176:     return retval;\n1177: }\n1178: \nStacktrace #3:\nFile: /sourcecode/src/video/SDL_surface.c\n  77: SDL_Surface *SDL_CreateRGBSurfaceWithFormat(Uint32 flags, int width, int height, int depth,\n  78:                                Uint32 format)\n  79: {\n  80:     size_t pitch;\n  81:     SDL_Surface *surface;\n  82: \n  83:     /* The flags are no longer used, make the compiler happy */\n  84:     (void)flags;\n  85: \n  86:     if (width < 0) {\n  87:         SDL_InvalidParamError(\"width\");\n  88:         return NULL;\n  89:     }\n  90: \n  91:     if (height < 0) {\n  92:         SDL_InvalidParamError(\"height\");\n  93:         return NULL;\n  94:     }\n  95: \n  96:     if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n  97:         SDL_SetError(\"invalid format\");\n  98:         return NULL;\n  99:     } else {\n 100:         pitch = SDL_CalculatePitch(format, width, SDL_FALSE);\n 101:         if (pitch > SDL_MAX_SINT32) {\n 102:             /* Overflow... */\n 103:             SDL_OutOfMemory();\n 104:             return NULL;\n 105:         }\n 106:     }\n 107: \n 108:     /* Allocate the surface */\n 109:     surface = (SDL_Surface *)SDL_calloc(1, sizeof(*surface));\n 110:     if (!surface) {\n 111:         SDL_OutOfMemory();\n 112:         return NULL;\n 113:     }\n 114: \n 115:     surface->format = SDL_AllocFormat(format);\n 116:     if (!surface->format) {\n 117:         SDL_FreeSurface(surface);\n 118:         return NULL;\n 119:     }\n 120:     surface->w = width;\n 121:     surface->h = height;\n 122:     surface->pitch = (int)pitch;\n 123:     SDL_SetClipRect(surface, NULL);\n 124: \n 125:     if (SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {\n 126:         SDL_Palette *palette =\n 127:             SDL_AllocPalette((1 << surface->format->BitsPerPixel));\n 128:         if (!palette) {\n 129:             SDL_FreeSurface(surface);\n 130:             return NULL;\n 131:         }\n 132:         if (palette->ncolors == 2) {\n 133:             /* Create a black and white bitmap palette */\n 134:             palette->colors[0].r = 0xFF;\n 135:             palette->colors[0].g = 0xFF;\n 136:             palette->colors[0].b = 0xFF;\n 137:             palette->colors[1].r = 0x00;\n 138:             palette->colors[1].g = 0x00;\n 139:             palette->colors[1].b = 0x00;\n 140:         }\n 141:         SDL_SetSurfacePalette(surface, palette);\n 142:         SDL_FreePalette(palette);\n 143:     }\n 144: \n 145:     /* Get the pixels */\n 146:     if (surface->w && surface->h) {\n 147:         /* Assumptions checked in surface_size_assumptions assert above */\n 148:         size_t size;\n 149:         if (SDL_size_mul_overflow(surface->h, surface->pitch, &size)) {\n 150:             /* Overflow... */\n 151:             SDL_FreeSurface(surface);\n 152:             SDL_OutOfMemory();\n 153:             return NULL;\n 154:         }\n 155: \n 156:         surface->pixels = SDL_SIMDAlloc(size);\n 157:         if (!surface->pixels) {\n 158:             SDL_FreeSurface(surface);\n 159:             SDL_OutOfMemory();\n 160:             return NULL;\n 161:         }\n 162:         surface->flags |= SDL_SIMD_ALIGNED;\n 163:         /* This is important for bitmaps */\n 164:         SDL_memset(surface->pixels, 0, size);\n 165:     }\n 166: \n 167:     /* Allocate an empty mapping */\n 168:     surface->map = SDL_AllocBlitMap();\n 169:     if (!surface->map) {\n 170:         SDL_FreeSurface(surface);\n 171:         return NULL;\n 172:     }\n 173: \n 174:     /* By default surface with an alpha mask are set up for blending */\n 175:     if (surface->format->Amask) {\n 176:         SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n 177:     }\n 178: \n 179:     /* The surface is ready to go */\n 180:     surface->refcount = 1;\n 181:     return surface;\n 182: }\n 183: \nStacktrace #4:\nFile: /sourcecode/src/video/SDL_surface.c\n 188: SDL_Surface *SDL_CreateRGBSurface(Uint32 flags,\n 189:                      int width, int height, int depth,\n 190:                      Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)\n 191: {\n 192:     Uint32 format;\n 193: \n 194:     /* Get the pixel format */\n 195:     format = SDL_MasksToPixelFormatEnum(depth, Rmask, Gmask, Bmask, Amask);\n 196:     if (format == SDL_PIXELFORMAT_UNKNOWN) {\n 197:         SDL_SetError(\"Unknown pixel format\");\n 198:         return NULL;\n 199:     }\n 200: \n 201:     return SDL_CreateRGBSurfaceWithFormat(flags, width, height, depth, format);\n 202: }\n 203: \nStacktrace #5:\nFile: /sourcecode/src/events/SDL_mouse.c\n1279: SDL_Cursor *SDL_CreateCursor(const Uint8 *data, const Uint8 *mask,\n1280:                  int w, int h, int hot_x, int hot_y)\n1281: {\n1282:     SDL_Surface *surface;\n1283:     SDL_Cursor *cursor;\n1284:     int x, y;\n1285:     Uint32 *pixel;\n1286:     Uint8 datab = 0, maskb = 0;\n1287:     const Uint32 black = 0xFF000000;\n1288:     const Uint32 white = 0xFFFFFFFF;\n1289:     const Uint32 transparent = 0x00000000;\n1290: \n1291:     /* Make sure the width is a multiple of 8 */\n1292:     w = ((w + 7) & ~7);\n1293: \n1294:     /* Create the surface from a bitmap */\n1295:     surface = SDL_CreateRGBSurface(0, w, h, 32,\n1296:                                    0x00FF0000,\n1297:                                    0x0000FF00,\n1298:                                    0x000000FF,\n1299:                                    0xFF000000);\n1300:     if (!surface) {\n1301:         return NULL;\n1302:     }\n1303:     for (y = 0; y < h; ++y) {\n1304:         pixel = (Uint32 *)((Uint8 *)surface->pixels + y * surface->pitch);\n1305:         for (x = 0; x < w; ++x) {\n1306:             if ((x % 8) == 0) {\n1307:                 datab = *data++;\n1308:                 maskb = *mask++;\n1309:             }\n1310:             if (maskb & 0x80) {\n1311:                 *pixel++ = (datab & 0x80) ? black : white;\n1312:             } else {\n1313:                 *pixel++ = (datab & 0x80) ? black : transparent;\n1314:             }\n1315:             datab <<= 1;\n1316:             maskb <<= 1;\n1317:         }\n1318:     }\n1319: \n1320:     cursor = SDL_CreateColorCursor(surface, hot_x, hot_y);\n1321: \n1322:     SDL_FreeSurface(surface);\n1323: \n1324:     return cursor;\n1325: }\n1326: \nStacktrace #6:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 285: SDL_DYNAPI_PROC(SDL_Cursor*,SDL_CreateCursor,(const Uint8 *a, const Uint8 *b, int c, int d, int e, int f),(a,b,c,d,e,f),return)\n 286: \nStacktrace #7:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 285: SDL_DYNAPI_PROC(SDL_Cursor*,SDL_CreateCursor,(const Uint8 *a, const Uint8 *b, int c, int d, int e, int f),(a,b,c,d,e,f),return)\n 286:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7faae3428f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x559ce54d0e24 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7faae342ee02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7faae339460b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7faae33901ff in __asan::Allocator::Calloc(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:748\n    #5 0x7faae33901ff in __asan::asan_calloc(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:984\n    #6 0x7faae341ca34 in __interceptor_calloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:155\n    #7 0x559ce54bf7b4 in poller_create /sourcecode/src/kernel/poller.c:1173\n    #8 0x559ce54b79f4 in fuzzloop /dockerin/fuzz_drivers/tf1729051211354ndhs.cpp:21\n    #9 0x559ce54cfa99 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x559ce54b7668 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7faae2e2cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7faae2e2ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x559ce54b77b4 in _start (/dockerin/fuzz_drivers/tf1729051211354ndhs.out+0xf7b4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 03:59:54\n// Signature: poller_add_timer(struct timespec *value, void *context, void **timer, poller_t *poller)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: poller_add_timer\n// CFLAGS is used to specify compile flags, you can add other flags, separated by spaces.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\"\n#include \"src/kernel/poller.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    struct poller_params params = {\n        .max_open_files = fuzzUint32(0),\n        .callback = NULL,\n        .context = NULL\n    };\n\n    poller_t *poller = poller_create(&params);\n    if (!poller) return -1;\n\n    struct timespec ts = {\n        .tv_sec = fuzzInt64(1),\n        .tv_nsec = fuzzInt64(2)\n    };\n\n    void *timer = NULL;\n    int ret = poller_add_timer(&ts, (void *)fuzzData(3), &timer, poller);\n\n    poller_destroy(poller);\n    return ret;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/poller.c\n1171: poller_t *poller_create(const struct poller_params *params)\n1172: {\n1173: \tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n1174: \tpoller_t *poller;\n1175: \n1176: \tif (nodes_buf)\n1177: \t{\n1178: \t\tpoller = __poller_create(nodes_buf, params);\n1179: \t\tif (poller)\n1180: \t\t\treturn poller;\n1181: \n1182: \t\tfree(nodes_buf);\n1183: \t}\n1184: \n1185: \treturn NULL;\n1186: }\n1187:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==44771==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abea (0x1ad7f29bbf0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f311aaf3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f3f41b601d in protocol::HttpMessage::append_output_body(void const*, unsigned long) /sourcecode/src/protocol/HttpMessage.cc:38\n    #2 0x55f3f418ee6d in fuzzloop /dockerin/fuzz_drivers/tf1729046934226msfb.cpp:30\n    #3 0x55f3f41c0e69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==44771==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: protocol::HttpMessage::append_output_body(void *buf, size_t size)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol11HttpMessage18append_output_bodyEPKvm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/protocol -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/HttpMessage.h\" //extract\n#include <errno.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <utility> //extract\n#include \"HttpMessage.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    bool is_resp = fuzzBool(0);\n    auto httpmessage = std::make_unique<protocol::HttpMessage>(is_resp);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * buf = (void *)fuzzData(1);\n    size_t size = (size_t)fuzzUint64(2);\n    httpmessage->append_output_body(buf, size);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/HttpMessage.cc\n  35: bool HttpMessage::append_output_body(const void *buf, size_t size)\n  36: {\n  37: \tsize_t n = sizeof (struct HttpMessageBlock) + size;\n  38: \tstruct HttpMessageBlock *block = (struct HttpMessageBlock *)malloc(n);\n  39: \n  40: \tif (block)\n  41: \t{\n  42: \t\tmemcpy(block + 1, buf, size);\n  43: \t\tblock->ptr = block + 1;\n  44: \t\tblock->size = size;\n  45: \t\tlist_add_tail(&block->list, &this->output_body);\n  46: \t\tthis->output_body_size += size;\n  47: \t\treturn true;\n  48: \t}\n  49: \n  50: \treturn false;\n  51: }\n  52:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f710cbb2f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55a6740b3364 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7f710cbb8e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7f710cb1e60b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7f710cb1a43c in __asan::asan_memalign(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:1039\n    #5 0x7f710cba81a3 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #6 0x55a6740a84a1 in __gnu_cxx::new_allocator<void*>::allocate(unsigned long, void const*) /usr/include/c++/11/ext/new_allocator.h:127\n    #7 0x55a6740a75d7 in std::allocator_traits<std::allocator<void*> >::allocate(std::allocator<void*>&, unsigned long) /usr/include/c++/11/bits/alloc_traits.h:464\n    #8 0x55a6740a7044 in std::_Vector_base<void*, std::allocator<void*> >::_M_allocate(unsigned long) /usr/include/c++/11/bits/stl_vector.h:346\n    #9 0x55a6740a6301 in std::vector<void*, std::allocator<void*> >::_M_default_append(unsigned long) /usr/include/c++/11/bits/vector.tcc:635\n    #10 0x55a6740a58b0 in std::vector<void*, std::allocator<void*> >::resize(unsigned long) /usr/include/c++/11/bits/stl_vector.h:940\n    #11 0x55a6740a521e in YAML::AnchorDict<void*>::Register(unsigned long, void*) /sourcecode/include/yaml-cpp/contrib/anchordict.h:28\n    #12 0x55a6740a4b77 in YAML::GraphBuilderAdapter::RegisterAnchor(unsigned long, void*) /sourcecode/src/contrib/graphbuilderadapter.cpp:72\n    #13 0x55a6740a4419 in YAML::GraphBuilderAdapter::OnScalar(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/contrib/graphbuilderadapter.cpp:26\n    #14 0x55a6740a0cb9 in fuzzloop /dockerin/fuzz_drivers/tf1729077324115bggr.cpp:39\n    #15 0x55a6740b1fd9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #16 0x55a6740a0688 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #17 0x7f710c5b6d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #18 0x7f710c5b6e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #19 0x55a6740a07d4 in _start (/dockerin/fuzz_drivers/tf1729077324115bggr.out+0x157d4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 11:14:12\n// Signature: YAML::GraphBuilderAdapter::DispositionNode(void *pNode)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML19GraphBuilderAdapter15DispositionNodeEPv\n// CFLAGS is used to specify compile flags, you can add other flags, separated by spaces.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src -fno-access-control\n#include \"FuzzAgent.h\"\n#include \"src/contrib/graphbuilderadapter.h\"\n#include \"yaml-cpp/contrib/graphbuilder.h\"\n#include \"yaml-cpp/emitterstyle.h\"  // Include for EmitterStyle\n#include \"yaml-cpp/anchor.h\"        // Include for anchor_t\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // Use a concrete implementation of GraphBuilderInterface\n    class ConcreteGraphBuilder : public YAML::GraphBuilderInterface {\n    public:\n        virtual ~ConcreteGraphBuilder() {}\n        virtual void *NewNull(const YAML::Mark &mark, void *pParentNode) { return nullptr; }\n        virtual void *NewScalar(const YAML::Mark &mark, const std::string &tag, void *pParentNode, const std::string &value) { return nullptr; }\n        virtual void *NewSequence(const YAML::Mark &mark, const std::string &tag, void *pParentNode) { return nullptr; }\n        virtual void AppendToSequence(void *pSequence, void *pNode) {}\n        virtual void *NewMap(const YAML::Mark &mark, const std::string &tag, void *pParentNode) { return nullptr; }\n        virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) {}\n    };\n\n    ConcreteGraphBuilder builder;\n    YAML::GraphBuilderAdapter adapter(builder);\n    YAML::Mark mark;\n\n    char* tag = fuzzString(0);\n    YAML::anchor_t anchor = fuzzUint32(1);  // Use YAML::anchor_t\n    char* value = fuzzString(2);\n    YAML::EmitterStyle::value style = static_cast<YAML::EmitterStyle::value>(fuzzInt32(3));  // Use YAML::EmitterStyle::value\n\n    adapter.OnScalar(mark, tag, anchor, value);\n    adapter.OnSequenceStart(mark, tag, anchor, style);\n    adapter.OnSequenceEnd();\n    adapter.OnMapStart(mark, tag, anchor, style);\n    adapter.OnMapEnd();\n\n    void* pNode = builder.NewNull(mark, nullptr);\n    adapter.DispositionNode(pNode);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/yaml-cpp/contrib/anchordict.h\n  18:  *\n  19:  * <p>Efficient implementation that can make assumptions about how\n  20:  * {@code anchor_t} values are assigned by the {@link Parser} class.\n  21:  */\n  22: template <class T>\n  23: class AnchorDict {\n  24:  public:\n  25:   AnchorDict() : m_data{} {}\n  26:   void Register(anchor_t anchor, T value) {\n  27:     if (anchor > m_data.size()) {\n  28:       m_data.resize(anchor);\n  29:     }\n  30:     m_data[anchor - 1] = value;\n  31:   }\n  32: \n  33:   T Get(anchor_t anchor) const { return m_data[anchor - 1]; }\n  34: \n  35:  private:\n  36:   std::vector<T> m_data;\n  37: };\n  38: }  // namespace YAML\n  39: \nStacktrace #1:\nFile: /sourcecode/src/contrib/graphbuilderadapter.cpp\n  70: void GraphBuilderAdapter::RegisterAnchor(anchor_t anchor, void *pNode) {\n  71:   if (anchor) {\n  72:     m_anchors.Register(anchor, pNode);\n  73:   }\n  74: }\n  75: \nStacktrace #2:\nFile: /sourcecode/src/contrib/graphbuilderadapter.cpp\n  22: void GraphBuilderAdapter::OnScalar(const Mark &mark, const std::string &tag,\n  23:                                    anchor_t anchor, const std::string &value) {\n  24:   void *pParent = GetCurrentParent();\n  25:   void *pNode = m_builder.NewScalar(mark, tag, pParent, value);\n  26:   RegisterAnchor(anchor, pNode);\n  27: \n  28:   DispositionNode(pNode);\n  29: }\n  30:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==5169==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abdc (0x1ad7f29bbe0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7ff265778887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f03a9a1693 in hi_malloc /sourcecode/alloc.h:59\n    #2 0x55f03a9a197c in sdsnewlen /sourcecode/sds.c:94\n    #3 0x55f03a99f7c9 in fuzzloop /dockerin/fuzz_drivers/tf1728369139915kaws.c:27\n    #4 0x55f03a9b32c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==5169==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Dhiredis_EXPORTS\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: sdsnewlen\n// Sign: sdsnewlen(void *init, size_t initlen)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"fmacros.h\" //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <ctype.h> //extract\n#include <assert.h> //extract\n#include <limits.h> //extract\n#include \"sds.h\" //extract\n#include \"sdsalloc.h\" //extract\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * init = (void *)fuzzData(0);\n    size_t initlen = (size_t)fuzzUint64(1);\n    sds ret = sdsnewlen(init, initlen);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/alloc.h\n  58: static inline void *hi_malloc(size_t size) {\n  59:     return hiredisAllocFns.mallocFn(size);\n  60: }\n  61: \nStacktrace #1:\nFile: /sourcecode/sds.c\n  83: sds sdsnewlen(const void *init, size_t initlen) {\n  84:     void *sh;\n  85:     sds s;\n  86:     char type = sdsReqType(initlen);\n  87:     /* Empty strings are usually created in order to append. Use type 8\n  88:      * since type 5 is not good at this. */\n  89:     if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n  90:     int hdrlen = sdsHdrSize(type);\n  91:     unsigned char *fp; /* flags pointer. */\n  92: \n  93:     if (hdrlen+initlen+1 <= initlen) return NULL; /* Catch size_t overflow */\n  94:     sh = s_malloc(hdrlen+initlen+1);\n  95:     if (sh == NULL) return NULL;\n  96:     if (!init)\n  97:         memset(sh, 0, hdrlen+initlen+1);\n  98:     s = (char*)sh+hdrlen;\n  99:     fp = ((unsigned char*)s)-1;\n 100:     switch(type) {\n 101:         case SDS_TYPE_5: {\n 102:             *fp = type | (initlen << SDS_TYPE_BITS);\n 103:             break;\n 104:         }\n 105:         case SDS_TYPE_8: {\n 106:             SDS_HDR_VAR(8,s);\n 107:             sh->len = initlen;\n 108:             sh->alloc = initlen;\n 109:             *fp = type;\n 110:             break;\n 111:         }\n 112:         case SDS_TYPE_16: {\n 113:             SDS_HDR_VAR(16,s);\n 114:             sh->len = initlen;\n 115:             sh->alloc = initlen;\n 116:             *fp = type;\n 117:             break;\n 118:         }\n 119:         case SDS_TYPE_32: {\n 120:             SDS_HDR_VAR(32,s);\n 121:             sh->len = initlen;\n 122:             sh->alloc = initlen;\n 123:             *fp = type;\n 124:             break;\n 125:         }\n 126:         case SDS_TYPE_64: {\n 127:             SDS_HDR_VAR(64,s);\n 128:             sh->len = initlen;\n 129:             sh->alloc = initlen;\n 130:             *fp = type;\n 131:             break;\n 132:         }\n 133:     }\n 134:     if (initlen && init)\n 135:         memcpy(s, init, initlen);\n 136:     s[initlen] = '\\0';\n 137:     return s;\n 138: }\n 139:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3817==ERROR: AddressSanitizer: requested allocation size 0xfffffffff7540000 (0xfffffffff7541000 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f52cfec0357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102\n    #1 0x55ef22d86de0 in PreCalculatedPrimeTable::PreCalculatedPrimeTable(int) build/googletest-source/googletest/samples/prime_tables.h:81\n    #2 0x55ef22d88d8d in std::_MakeUniq<PreCalculatedPrimeTable>::__single_object std::make_unique<PreCalculatedPrimeTable, int&>(int&) /usr/include/c++/11/bits/unique_ptr.h:962\n    #3 0x55ef22d86794 in fuzzloop /dockerin/fuzz_drivers/tf1728877392019mjim.cpp:20\n    #4 0x55ef22d92359 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==3817==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102 in operator new[](unsigned long)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/googletest-source/googletest/samples\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZN23PreCalculatedPrimeTableC1Ei\n// Sign: PreCalculatedPrimeTable::PreCalculatedPrimeTable(int max)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"build/googletest-source/googletest/samples/prime_tables.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    int max = fuzzInt32(0);\n    auto ret = std::make_unique<PreCalculatedPrimeTable>(max);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/build/googletest-source/googletest/samples/prime_tables.h\n  80:   explicit PreCalculatedPrimeTable(int max)\n  81:       : is_prime_size_(max + 1), is_prime_(new bool[max + 1]) {\n  82:     CalculatePrimesUpTo(max);\n  83:   }\n  84:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==657==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abca (0x1ad7f29bbd0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fd9f922cc38 in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164\n    #1 0x55e88eba4745 in hi_realloc /sourcecode/alloc.h:71\n    #2 0x55e88ebad8d3 in sds_realloc /sourcecode/sds.c:1115\n    #3 0x55e88eba27c9 in fuzzloop /dockerin/fuzz_drivers/tf1728369139884wjfk.c:27\n    #4 0x55e88ebb62e9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==657==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164 in __interceptor_realloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Dhiredis_EXPORTS\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: sds_realloc\n// Sign: sds_realloc(void *ptr, size_t size)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"fmacros.h\" //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <ctype.h> //extract\n#include <assert.h> //extract\n#include <limits.h> //extract\n#include \"sds.h\" //extract\n#include \"sdsalloc.h\" //extract\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ptr = (void *)fuzzData(0);\n    size_t size = (size_t)fuzzUint64(1);\n    void * ret = sds_realloc(ptr, size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/alloc.h\n  70: static inline void *hi_realloc(void *ptr, size_t size) {\n  71:     return hiredisAllocFns.reallocFn(ptr, size);\n  72: }\n  73: \nStacktrace #1:\nFile: /sourcecode/sds.c\n1115: void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\n1116:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==46344==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abe2 (0x1ad7f29bbe8 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fe3e402b887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55b2e8e69305 in real_malloc /sourcecode/src/stdlib/SDL_malloc.c:5196\n    #2 0x55b2e8e698e2 in SDL_malloc_REAL /sourcecode/src/stdlib/SDL_malloc.c:5295\n    #3 0x55b2e863fc28 in SDL_NewDataQueue /sourcecode/src/SDL_dataqueue.c:73\n    #4 0x55b2e863f8d9 in fuzzloop /dockerin/fuzz_drivers/tf1728900796625mxco.c:31\n    #5 0x55b2e8eb5e19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==46344==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc -Isrc/dynapi -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件src/SDL_dataqueue.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=src/SDL_dataqueue.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_mutex.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_mutex.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_DestroyMutex\n// Sign: SDL_DestroyMutex(SDL_mutex *a)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"./SDL_internal.h\" //extract\n#include \"SDL.h\" //extract\n#include \"./SDL_dataqueue.h\" //extract\n#include \"SDL_config.h\" //extract\n#include \"SDL_dynapi.h\" //extract\n#include \"SDL_syswm.h\" //extract\n#include \"SDL_vulkan.h\" //extract\n#include \"src/SDL_dataqueue.h\" //autogen\n#include \"build/include/SDL2/SDL_mutex.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    size_t _packetlen = (size_t)fuzzUint64(0);\n    size_t initialslack = (size_t)fuzzUint64(1);\n    SDL_DataQueue * queue = SDL_NewDataQueue(_packetlen, initialslack);\n    if (queue == NULL)\n        return 0;\n    SDL_mutex * a = SDL_GetDataQueueMutex(queue);\n    if (a == NULL)\n        return 0;\n    SDL_DestroyMutex(a);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5196: static void* SDLCALL real_malloc(size_t s) { return malloc(s); }\n5197: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5287: void *SDL_malloc(size_t size)\n5288: {\n5289:     void *mem;\n5290: \n5291:     if (!size) {\n5292:         size = 1;\n5293:     }\n5294: \n5295:     mem = s_mem.malloc_func(size);\n5296:     if (mem) {\n5297:         SDL_AtomicIncRef(&s_mem.num_allocations);\n5298:     }\n5299:     return mem;\n5300: }\n5301: \nStacktrace #2:\nFile: /sourcecode/src/SDL_dataqueue.c\n  53: SDL_DataQueue *SDL_NewDataQueue(const size_t _packetlen, const size_t initialslack)\n  54: {\n  55:     SDL_DataQueue *queue = (SDL_DataQueue *)SDL_calloc(1, sizeof(SDL_DataQueue));\n  56: \n  57:     if (!queue) {\n  58:         SDL_OutOfMemory();\n  59:     } else {\n  60:         const size_t packetlen = _packetlen ? _packetlen : 1024;\n  61:         const size_t wantpackets = (initialslack + (packetlen - 1)) / packetlen;\n  62:         size_t i;\n  63: \n  64:         queue->packet_size = packetlen;\n  65: \n  66:         queue->lock = SDL_CreateMutex();\n  67:         if (!queue->lock) {\n  68:             SDL_free(queue);\n  69:             return NULL;\n  70:         }\n  71: \n  72:         for (i = 0; i < wantpackets; i++) {\n  73:             SDL_DataQueuePacket *packet = (SDL_DataQueuePacket *)SDL_malloc(sizeof(SDL_DataQueuePacket) + packetlen);\n  74:             if (packet) { /* don't care if this fails, we'll deal later. */\n  75:                 packet->datalen = 0;\n  76:                 packet->startpos = 0;\n  77:                 packet->next = queue->pool;\n  78:                 queue->pool = packet;\n  79:             }\n  80:         }\n  81:     }\n  82: \n  83:     return queue;\n  84: }\n  85:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==299==ERROR: AddressSanitizer: requested allocation size 0xffffffffffffffff (0x800 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f9030aaa357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102\n    #1 0x5640d825fbb5 in protocol::MySQLResultCursor::fetch_result_set(__mysql_result_set const*) /sourcecode/src/protocol/MySQLResult.cc:107\n    #2 0x5640d81fcaee in fuzzloop /sharedockerin/ta1729664330946apug/test_file.cpp:38\n    #3 0x5640d82a0f89 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==299==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102 in operator new[](unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:55:25\n// Signature: protocol::MySQLResultCursor::fetch_result_set(struct __mysql_result_set *result_set)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol17MySQLResultCursor16fetch_result_setEPK18__mysql_result_set\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\" // Added this line to fix the undeclared symbol error\n#include \"src/protocol/MySQLResult.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* fuzz_data = fuzzData(0);\n    int fuzz_len = fuzzGetLen(0);\n\n    protocol::MySQLResponse resp;\n    // Corrected the member function name to match the actual implementation\n    resp.get_parser(); // This line will be corrected based on the actual member function name\n\n    protocol::MySQLResultCursor cursor(&resp);\n    struct __mysql_result_set result_set;\n    result_set.server_status = fuzzUint32(1);\n    result_set.type = fuzzUint8(2);\n    result_set.field_count = fuzzUint32(3);\n    result_set.rows_begin_offset = fuzzUint32(4);\n    result_set.rows_end_offset = fuzzUint32(5);\n    result_set.row_count = fuzzUint32(6);\n    result_set.affected_rows = fuzzUint64(7);\n    result_set.insert_id = fuzzUint64(8);\n    result_set.warning_count = fuzzUint32(9);\n    result_set.info_offset = fuzzUint32(10);\n    result_set.info_len = fuzzUint32(11);\n\n    cursor.fetch_result_set(&result_set);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/MySQLResult.cc\n  92: void MySQLResultCursor::fetch_result_set(const struct __mysql_result_set *result_set)\n  93: {\n  94: \tconst char *buf = (const char *)this->parser->buf;\n  95: \tthis->server_status = result_set->server_status;\n  96: \n  97: \tswitch (result_set->type)\n  98: \t{\n  99: \tcase MYSQL_PACKET_GET_RESULT:\n 100: \t\tthis->status = MYSQL_STATUS_GET_RESULT;\n 101: \t\tthis->field_count = result_set->field_count;\n 102: \t\tthis->start = buf + result_set->rows_begin_offset;\n 103: \t\tthis->pos = this->start;\n 104: \t\tthis->end = buf + result_set->rows_end_offset;\n 105: \t\tthis->row_count = result_set->row_count;\n 106: \n 107: \t\tthis->fields = new MySQLField *[this->field_count];\n 108: \t\tfor (int i = 0; i < this->field_count; i++)\n 109: \t\t\tthis->fields[i] = new MySQLField(this->parser->buf, result_set->fields[i]);\n 110: \t\tbreak;\n 111: \n 112: \tcase MYSQL_PACKET_OK:\n 113: \t\tthis->status = MYSQL_STATUS_OK;\n 114: \t\tthis->affected_rows = result_set->affected_rows;\n 115: \t\tthis->insert_id = result_set->insert_id;\n 116: \t\tthis->warning_count = result_set->warning_count;\n 117: \t\tthis->start = buf + result_set->info_offset;\n 118: \t\tthis->info_len = result_set->info_len;\n 119: \t\tthis->field_count = 0;\n 120: \t\tthis->fields = NULL;\n 121: \t\tbreak;\n 122: \n 123: \tdefault:\n 124: \t\tthis->status = MYSQL_STATUS_ERROR;\n 125: \t\tbreak;\n 126: \t}\n 127: }\n 128:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2046==ERROR: AddressSanitizer: requested allocation size 0x200000000000 (0x200000001000 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f136a654a57 in __interceptor_calloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154\n    #1 0x5562dcd25f35 in ht_init /sourcecode/external/hash/hash_table_impl.h:74\n    #2 0x5562dcd25c58 in fb_value_set_init /sourcecode/src/compiler/hash_tables/value_set.c:26\n    #3 0x5562dcd1981c in fuzzloop /dockerin/fuzz_drivers/tf1728556408570rsjp.c:34\n    #4 0x5562dcd30499 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==2046==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154 in __interceptor_calloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler/hash_tables -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: fb_value_set_init\n// Sign: fb_value_set_init(fb_value_set_t *ht, size_t count)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../symbols.h\" //extract\n#include \"hash/ht_hash_function.h\" //extract\n#include \"external/hash/hash_table.h\" //autogen\n#include \"src/compiler/symbols.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //file: external/hash/hash_table.h:63\n    //struct hash_table {\n    //    void *table;\n    //    char *offsets;\n    //    size_t count;\n    //    /* May be stored as a direct count, or log2. */\n    //    size_t buckets;\n    //};\n    struct hash_table *ht = (struct hash_table *)driverAllocMem(sizeof(struct hash_table));\n    ht->table = (void *)fuzzData(0);\n    ht->offsets = fuzzString(1);\n    ht->buckets = (unsigned long)fuzzUint64(2);\n    \n    size_t count = (size_t)fuzzUint64(3);\n    int ret = fb_value_set_init(ht, count);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/external/hash/hash_table_impl.h\n  59: static int ht_init(hash_table_t *ht, size_t count)\n  60: {\n  61:     size_t buckets = 4;\n  62: \n  63:     if ((HT_LOAD_FACTOR_FRAC) > 256 || (HT_LOAD_FACTOR_FRAC) < 1) {\n  64:         /*\n  65:          * 100% is bad but still the users choice.\n  66:          * 101% will never terminate insertion.\n  67:          */\n  68:         HT_PANIC(\"hash table failed with impossible load factor\");\n  69:         return -1;\n  70:     }\n  71:     while (count > buckets * (HT_LOAD_FACTOR_FRAC) / 256) {\n  72:         buckets *= 2;\n  73:     }\n  74:     ht->table = calloc(buckets, sizeof(ht_item_t));\n  75:     if (ht->table == 0) {\n  76:         return -1;\n  77:     }\n  78:     ht->offsets = 0;\n  79:     ht->buckets = buckets;\n  80:     ht->count = 0;\n  81:     return 0;\n  82: }\n  83: \nStacktrace #1:\nFile: /sourcecode/src/compiler/hash_tables/value_set.c\n  26: DEFINE_HASH_TABLE(fb_value_set)\n  27:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==125679==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29ac08 (0x1ad7f29bc08 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fb4407f8887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562b9a9d62bc in real_malloc /sourcecode/src/stdlib/SDL_malloc.c:5196\n    #2 0x562b9a9d6899 in SDL_malloc_REAL /sourcecode/src/stdlib/SDL_malloc.c:5295\n    #3 0x562b9a1ae9da in SDL_SIMDAlloc_REAL /sourcecode/src/cpuinfo/SDL_cpuinfo.c:1169\n    #4 0x562b9a1ac8c4 in fuzzloop /dockerin/fuzz_drivers/tf1728900798867fbqs.c:22\n    #5 0x562b9aa22dc9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==125679==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/cpuinfo -DSDL2_EXPORTS -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_SIMDAlloc_REAL\n// Sign: SDL_SIMDAlloc_REAL(size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../SDL_internal.h\" //extract\n#include \"SDL_cpuinfo.h\" //extract\n#include \"SDL_assert.h\" //extract\n#include <unistd.h> //extract\n#include <sys/auxv.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    size_t len = (size_t)fuzzUint64(0);\n    void * ret = SDL_SIMDAlloc_REAL(len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5196: static void* SDLCALL real_malloc(size_t s) { return malloc(s); }\n5197: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5287: void *SDL_malloc(size_t size)\n5288: {\n5289:     void *mem;\n5290: \n5291:     if (!size) {\n5292:         size = 1;\n5293:     }\n5294: \n5295:     mem = s_mem.malloc_func(size);\n5296:     if (mem) {\n5297:         SDL_AtomicIncRef(&s_mem.num_allocations);\n5298:     }\n5299:     return mem;\n5300: }\n5301: \nStacktrace #2:\nFile: /sourcecode/src/cpuinfo/SDL_cpuinfo.c\n1155: void *SDL_SIMDAlloc(const size_t len)\n1156: {\n1157:     const size_t alignment = SDL_SIMDGetAlignment();\n1158:     const size_t padding = (alignment - (len % alignment)) % alignment;\n1159:     Uint8 *retval = NULL;\n1160:     Uint8 *ptr;\n1161:     size_t to_allocate;\n1162: \n1163:     /* alignment + padding + sizeof(void *) is bounded (a few hundred\n1164:      * bytes max), so no need to check for overflow within that argument */\n1165:     if (SDL_size_add_overflow(len, alignment + padding + sizeof(void *), &to_allocate)) {\n1166:         return NULL;\n1167:     }\n1168: \n1169:     ptr = (Uint8 *)SDL_malloc(to_allocate);\n1170:     if (ptr) {\n1171:         /* store the actual allocated pointer right before our aligned pointer. */\n1172:         retval = ptr + sizeof(void *);\n1173:         retval += alignment - (((size_t)retval) % alignment);\n1174:         *(((void **)retval) - 1) = ptr;\n1175:     }\n1176:     return retval;\n1177: }\n1178:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "高危", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fbb707a0f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x564c179eb1a4 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7fbb707a6e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7fbb7070c60b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7fbb70708c96 in __asan::Allocator::Reallocate(void*, unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:727\n    #5 0x7fbb70708c96 in __asan::asan_realloc(void*, unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:1009\n    #6 0x7fbb70794c14 in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:165\n    #7 0x564c1782d821 in default_realloc_ex /sourcecode/crypto/mem.c:86\n    #8 0x564c1782e4d1 in CRYPTO_realloc /sourcecode/crypto/mem.c:346\n    #9 0x564c17830ae4 in sk_insert /sourcecode/crypto/stack/stack.c:149\n    #10 0x564c17831682 in sk_push /sourcecode/crypto/stack/stack.c:246\n    #11 0x564c1782d5d7 in CRYPTO_set_ex_data /sourcecode/crypto/ex_data.c:613\n    #12 0x564c1782951f in X509_STORE_CTX_set_ex_data /sourcecode/crypto/x509/x509_vfy.c:1843\n    #13 0x564c1781ef3b in fuzzloop /dockerin/fuzz_drivers/tf1728981988330egfo.c:35\n    #14 0x564c179e9e19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #15 0x564c1781ecc8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #16 0x7fbb703f0d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #17 0x7fbb703f0e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #18 0x564c1781ee14 in _start (/dockerin/fuzz_drivers/tf1728981988330egfo.out+0xa1e14)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Icrypto -Icrypto/modes -Icrypto/asn1 -Icrypto/evp -Iinclude -Icrypto/x509 -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DTERMIO -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM\n// Version: dev-v2.4.6-20241015-543df72\n// Target: X509_STORE_CTX_set_ex_data\n// Sign: X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdio.h> //extract\n#include <time.h> //extract\n#include <errno.h> //extract\n#include \"cryptlib.h\" //extract\n#include <openssl/crypto.h> //extract\n#include <openssl/lhash.h> //extract\n#include <openssl/buffer.h> //extract\n#include <openssl/evp.h> //extract\n#include <openssl/asn1.h> //extract\n#include <openssl/x509.h> //extract\n#include <openssl/x509v3.h> //extract\n#include <openssl/objects.h> //extract\n#include \"include/openssl/x509_vfy.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    X509_STORE_CTX * ctx = X509_STORE_CTX_new();\n    if (ctx == NULL)\n        return 0;\n    int idx = fuzzInt32(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(1);\n    int ret = X509_STORE_CTX_set_ex_data(ctx, idx, data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/mem.c\n  84: static void *default_realloc_ex(void *str, size_t num,\n  85:         const char *file, int line)\n  86: \t{ return realloc_func(str,num); }\n  87: \nStacktrace #1:\nFile: /sourcecode/crypto/mem.c\n 335: void *CRYPTO_realloc(void *str, int num, const char *file, int line)\n 336: \t{\n 337: \tvoid *ret = NULL;\n 338: \n 339: \tif (str == NULL)\n 340: \t\treturn CRYPTO_malloc(num, file, line);\n 341: \n 342: \tif (num <= 0) return NULL;\n 343: \n 344: \tif (realloc_debug_func != NULL)\n 345: \t\trealloc_debug_func(str, NULL, num, file, line, 0);\n 346: \tret = realloc_ex_func(str,num,file,line);\n 347: #ifdef LEVITTE_DEBUG_MEM\n 348: \tfprintf(stderr, \"LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\\n\", str, ret, num);\n 349: #endif\n 350: \tif (realloc_debug_func != NULL)\n 351: \t\trealloc_debug_func(str, ret, num, file, line, 1);\n 352: \n 353: \treturn ret;\n 354: \t}\n 355: \nStacktrace #2:\nFile: /sourcecode/crypto/stack/stack.c\n 142: int sk_insert(_STACK *st, void *data, int loc)\n 143: \t{\n 144: \tchar **s;\n 145: \n 146: \tif(st == NULL) return 0;\n 147: \tif (st->num_alloc <= st->num+1)\n 148: \t\t{\n 149: \t\ts=OPENSSL_realloc((char *)st->data,\n 150: \t\t\t(unsigned int)sizeof(char *)*st->num_alloc*2);\n 151: \t\tif (s == NULL)\n 152: \t\t\treturn(0);\n 153: \t\tst->data=s;\n 154: \t\tst->num_alloc*=2;\n 155: \t\t}\n 156: \tif ((loc >= (int)st->num) || (loc < 0))\n 157: \t\tst->data[st->num]=data;\n 158: \telse\n 159: \t\t{\n 160: \t\tint i;\n 161: \t\tchar **f,**t;\n 162: \n 163: \t\tf=st->data;\n 164: \t\tt=&(st->data[1]);\n 165: \t\tfor (i=st->num; i>=loc; i--)\n 166: \t\t\tt[i]=f[i];\n 167: \t\t\t\n 168: #ifdef undef /* no memmove on sunos :-( */\n 169: \t\tmemmove(&(st->data[loc+1]),\n 170: \t\t\t&(st->data[loc]),\n 171: \t\t\tsizeof(char *)*(st->num-loc));\n 172: #endif\n 173: \t\tst->data[loc]=data;\n 174: \t\t}\n 175: \tst->num++;\n 176: \tst->sorted=0;\n 177: \treturn(st->num);\n 178: \t}\n 179: \nStacktrace #3:\nFile: /sourcecode/crypto/stack/stack.c\n 244: int sk_push(_STACK *st, void *data)\n 245: \t{\n 246: \treturn(sk_insert(st,data,st->num));\n 247: \t}\n 248: \nStacktrace #4:\nFile: /sourcecode/crypto/ex_data.c\n 597: int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)\n 598: \t{\n 599: \tint i;\n 600: \n 601: \tif (ad->sk == NULL)\n 602: \t\t{\n 603: \t\tif ((ad->sk=sk_void_new_null()) == NULL)\n 604: \t\t\t{\n 605: \t\t\tCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\n 606: \t\t\treturn(0);\n 607: \t\t\t}\n 608: \t\t}\n 609: \ti=sk_void_num(ad->sk);\n 610: \n 611: \twhile (i <= idx)\n 612: \t\t{\n 613: \t\tif (!sk_void_push(ad->sk,NULL))\n 614: \t\t\t{\n 615: \t\t\tCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\n 616: \t\t\treturn(0);\n 617: \t\t\t}\n 618: \t\ti++;\n 619: \t\t}\n 620: \tsk_void_set(ad->sk,idx,val);\n 621: \treturn(1);\n 622: \t}\n 623: \nStacktrace #5:\nFile: /sourcecode/crypto/x509/x509_vfy.c\n1841: int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\n1842: \t{\n1843: \treturn CRYPTO_set_ex_data(&ctx->ex_data,idx,data);\n1844: \t}\n1845:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==7950==ERROR: AddressSanitizer: requested allocation size 0x6b5fca6af3c0 (0x6b5fca6b0400 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f1fbc4b257c in __interceptor_posix_memalign ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:226\n    #1 0x55b06e5b75e7 in pthreadpool_allocate /sourcecode/src/memory.c:44\n    #2 0x55b06e5b5e5b in pthreadpool_create /sourcecode/src/pthreads.c:258\n    #3 0x55b06e5b3784 in fuzzloop /dockerin/fuzz_drivers/tf1728877391904ouvq.cpp:21\n    #4 0x55b06e5bfe49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==7950==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:226 in __interceptor_posix_memalign\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Isrc\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: pthreadpool_create\n// Sign: pthreadpool_create(size_t threads_count)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stddef.h> //extract\n#include \"threadpool-utils.h\" //extract\n#include \"include/pthreadpool.h\" //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    size_t threads_count = (size_t)fuzzUint64(0);\n    struct pthreadpool * ret = pthreadpool_create(threads_count);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/memory.c\n  22: PTHREADPOOL_INTERNAL struct pthreadpool* pthreadpool_allocate(\n  23: \tsize_t threads_count)\n  24: {\n  25: \tassert(threads_count >= 1);\n  26: \n  27: \tconst size_t threadpool_size = sizeof(struct pthreadpool) + threads_count * sizeof(struct thread_info);\n  28: \tstruct pthreadpool* threadpool = NULL;\n  29: \t#if defined(__ANDROID__)\n  30: \t\t/*\n  31: \t\t * Android didn't get posix_memalign until API level 17 (Android 4.2).\n  32: \t\t * Use (otherwise obsolete) memalign function on Android platform.\n  33: \t\t */\n  34: \t\tthreadpool = memalign(PTHREADPOOL_CACHELINE_SIZE, threadpool_size);\n  35: \t\tif (threadpool == NULL) {\n  36: \t\t\treturn NULL;\n  37: \t\t}\n  38: \t#elif defined(_WIN32)\n  39: \t\tthreadpool = _aligned_malloc(threadpool_size, PTHREADPOOL_CACHELINE_SIZE);\n  40: \t\tif (threadpool == NULL) {\n  41: \t\t\treturn NULL;\n  42: \t\t}\n  43: \t#else\n  44: \t\tif (posix_memalign((void**) &threadpool, PTHREADPOOL_CACHELINE_SIZE, threadpool_size) != 0) {\n  45: \t\t\treturn NULL;\n  46: \t\t}\n  47: \t#endif\n  48: \tmemset(threadpool, 0, threadpool_size);\n  49: \treturn threadpool;\n  50: }\n  51: \nStacktrace #1:\nFile: /sourcecode/src/pthreads.c\n 248: \t\t#elif defined(_WIN32)\n 249: \t\t\tSYSTEM_INFO system_info;\n 250: \t\t\tZeroMemory(&system_info, sizeof(system_info));\n 251: \t\t\tGetSystemInfo(&system_info);\n 252: \t\t\tthreads_count = (size_t) system_info.dwNumberOfProcessors;\n 253: \t\t#else\n 254: \t\t\t#error \"Platform-specific implementation of sysconf(_SC_NPROCESSORS_ONLN) required\"\n 255: \t\t#endif\n 256: \t}\n 257: \n 258: \tstruct pthreadpool* threadpool = pthreadpool_allocate(threads_count);\n 259: \tif (threadpool == NULL) {\n 260: \t\treturn NULL;\n 261: \t}\n 262: \tthreadpool->threads_count = fxdiv_init_size_t(threads_count);\n 263: \tfor (size_t tid = 0; tid < threads_count; tid++) {\n 264: \t\tthreadpool->threads[tid].thread_number = tid;\n 265: \t\tthreadpool->threads[tid].threadpool = threadpool;\n 266: \t}\n 267: \n 268: \t/* Thread pool with a single thread computes everything on the caller thread. */\n 269:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3599==ERROR: AddressSanitizer: requested allocation size 0x1ad7f39abe7 (0x1ad7f39bbe8 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f45dcbf1887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f2a4f2a6f4 in hi_malloc /sourcecode/alloc.h:59\n    #2 0x55f2a4f2b939 in sdsMakeRoomFor /sourcecode/sds.c:232\n    #3 0x55f2a4f2d28e in sdscatlen /sourcecode/sds.c:384\n    #4 0x55f2a4f33862 in sdsjoinsds /sourcecode/sds.c:1104\n    #5 0x55f2a4f2882a in fuzzloop /dockerin/fuzz_drivers/tf1728369139911ooew.c:32\n    #6 0x55f2a4f3c329 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==3599==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Dhiredis_EXPORTS\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: sdsjoinsds\n// Sign: sdsjoinsds(sds *argv, int argc, char *sep, size_t seplen)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"fmacros.h\" //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <ctype.h> //extract\n#include <assert.h> //extract\n#include <limits.h> //extract\n#include \"sds.h\" //extract\n#include \"sdsalloc.h\" //extract\n\nint fuzzloop() {\n    char * line = fuzzString(0);\n    int * argc = (int *)fuzzFixBlob(1, 1 * sizeof(int));\n    sds * argv = sdssplitargs(line, argc);\n    if (argv == NULL)\n        return 0;\n    int argc1 = fuzzInt32(2);\n    char * sep = fuzzString(3);\n    size_t seplen = (size_t)fuzzUint64(4);\n    sds ret = sdsjoinsds(argv, argc1, sep, seplen);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/alloc.h\n  58: static inline void *hi_malloc(size_t size) {\n  59:     return hiredisAllocFns.mallocFn(size);\n  60: }\n  61: \nStacktrace #1:\nFile: /sourcecode/sds.c\n 197: sds sdsMakeRoomFor(sds s, size_t addlen) {\n 198:     void *sh, *newsh;\n 199:     size_t avail = sdsavail(s);\n 200:     size_t len, newlen, reqlen;\n 201:     char type, oldtype = s[-1] & SDS_TYPE_MASK;\n 202:     int hdrlen;\n 203: \n 204:     /* Return ASAP if there is enough space left. */\n 205:     if (avail >= addlen) return s;\n 206: \n 207:     len = sdslen(s);\n 208:     sh = (char*)s-sdsHdrSize(oldtype);\n 209:     reqlen = newlen = (len+addlen);\n 210:     if (newlen <= len) return NULL; /* Catch size_t overflow */\n 211:     if (newlen < SDS_MAX_PREALLOC)\n 212:         newlen *= 2;\n 213:     else\n 214:         newlen += SDS_MAX_PREALLOC;\n 215: \n 216:     type = sdsReqType(newlen);\n 217: \n 218:     /* Don't use type 5: the user is appending to the string and type 5 is\n 219:      * not able to remember empty space, so sdsMakeRoomFor() must be called\n 220:      * at every appending operation. */\n 221:     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n 222: \n 223:     hdrlen = sdsHdrSize(type);\n 224:     if (hdrlen+newlen+1 <= reqlen) return NULL; /* Catch size_t overflow */\n 225:     if (oldtype==type) {\n 226:         newsh = s_realloc(sh, hdrlen+newlen+1);\n 227:         if (newsh == NULL) return NULL;\n 228:         s = (char*)newsh+hdrlen;\n 229:     } else {\n 230:         /* Since the header size changes, need to move the string forward,\n 231:          * and can't use realloc */\n 232:         newsh = s_malloc(hdrlen+newlen+1);\n 233:         if (newsh == NULL) return NULL;\n 234:         memcpy((char*)newsh+hdrlen, s, len+1);\n 235:         s_free(sh);\n 236:         s = (char*)newsh+hdrlen;\n 237:         s[-1] = type;\n 238:         sdssetlen(s, len);\n 239:     }\n 240:     sdssetalloc(s, newlen);\n 241:     return s;\n 242: }\n 243: \nStacktrace #2:\nFile: /sourcecode/sds.c\n 381: sds sdscatlen(sds s, const void *t, size_t len) {\n 382:     size_t curlen = sdslen(s);\n 383: \n 384:     s = sdsMakeRoomFor(s,len);\n 385:     if (s == NULL) return NULL;\n 386:     memcpy(s+curlen, t, len);\n 387:     sdssetlen(s, curlen+len);\n 388:     s[curlen+len] = '\\0';\n 389:     return s;\n 390: }\n 391: \nStacktrace #3:\nFile: /sourcecode/sds.c\n1098: sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n1099:     sds join = sdsempty();\n1100:     int j;\n1101: \n1102:     for (j = 0; j < argc; j++) {\n1103:         join = sdscatsds(join, argv[j]);\n1104:         if (j != argc-1) join = sdscatlen(join,sep,seplen);\n1105:     }\n1106:     return join;\n1107: }\n1108:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fecbb6a7f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5585d275b644 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7fecbb6ade02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7fecbb61360b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7fecbb60f43c in __asan::asan_memalign(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:1039\n    #5 0x7fecbb69d1a3 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #6 0x7fecbb4fe724 in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reserve(unsigned long) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x14c724)\n    #7 0x5585d274c010 in YAML::Stream::get[abi:cxx11](int) /sourcecode/src/stream.cpp:278\n    #8 0x5585d2749dbf in fuzzloop /dockerin/fuzz_drivers/tf1729061963035ldyh.cpp:26\n    #9 0x5585d275a2b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x5585d2749928 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7fecbb0abd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7fecbb0abe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x5585d2749a74 in _start (/dockerin/fuzz_drivers/tf1729061963035ldyh.out+0x13a74)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Stream::get(int n)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML6Stream3getB5cxx11Ei\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <iostream> //extract\n#include \"stream.h\" //extract\n#include <sstream>\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream input(temp);\n    auto stream = std::make_unique<YAML::Stream>(input);\n    int n = fuzzInt32(1);\n    stream->get(n);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stream.cpp\n 275: std::string Stream::get(int n) {\n 276:   std::string ret;\n 277:   if (n > 0) {\n 278:     ret.reserve(static_cast<std::string::size_type>(n));\n 279:     for (int i = 0; i < n; i++)\n 280:       ret += get();\n 281:   }\n 282:   return ret;\n 283: }\n 284:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==39619==ERROR: AddressSanitizer: requested allocation size 0x2843ebe81af0 (0x2843ebe82af0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fcdbf5cc1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x56022db846d8 in __gnu_cxx::new_allocator<protocol::RedisValue>::allocate(unsigned long, void const*) /usr/include/c++/11/ext/new_allocator.h:127\n    #2 0x56022db83e9e in std::allocator_traits<std::allocator<protocol::RedisValue> >::allocate(std::allocator<protocol::RedisValue>&, unsigned long) /usr/include/c++/11/bits/alloc_traits.h:464\n    #3 0x56022db82a0a in std::_Vector_base<protocol::RedisValue, std::allocator<protocol::RedisValue> >::_M_allocate(unsigned long) /usr/include/c++/11/bits/stl_vector.h:346\n    #4 0x56022db823b4 in std::_Vector_base<protocol::RedisValue, std::allocator<protocol::RedisValue> >::_M_create_storage(unsigned long) /usr/include/c++/11/bits/stl_vector.h:361\n    #5 0x56022db7ff3e in std::_Vector_base<protocol::RedisValue, std::allocator<protocol::RedisValue> >::_Vector_base(unsigned long, std::allocator<protocol::RedisValue> const&) /usr/include/c++/11/bits/stl_vector.h:305\n    #6 0x56022db7f249 in std::vector<protocol::RedisValue, std::allocator<protocol::RedisValue> >::vector(unsigned long, std::allocator<protocol::RedisValue> const&) /usr/include/c++/11/bits/stl_vector.h:511\n    #7 0x56022db7a074 in protocol::RedisValue::set_array(unsigned long) /sourcecode/src/protocol/RedisMessage.cc:287\n    #8 0x56022db77146 in fuzzloop /dockerin/fuzz_drivers/tf1729046934385eftr.cpp:28\n    #9 0x56022dbb2589 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==39619==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99 in operator new(unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: protocol::RedisValue::set_array(size_t new_size)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol10RedisValue9set_arrayEm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/protocol -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/RedisMessage.h\" //extract\n#include <errno.h> //extract\n#include <string.h> //extract\n#include <sstream> //extract\n#include <utility> //extract\n#include \"EncodeStream.h\" //extract\n#include \"RedisMessage.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto redisvalue = std::make_unique<protocol::RedisValue>();\n    size_t new_size = (size_t)fuzzUint64(0);\n    redisvalue->set_array(new_size);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/RedisMessage.cc\n 280: void RedisValue::set_array(size_t new_size)\n 281: {\n 282: \tif (type_ == REDIS_REPLY_TYPE_ARRAY)\n 283: \t\t((Rarr *)data_)->resize(new_size);\n 284: \telse\n 285: \t{\n 286: \t\tfree_data();\n 287: \t\tdata_ = new Rarr(new_size);\n 288: \t\ttype_ = REDIS_REPLY_TYPE_ARRAY;\n 289: \t}\n 290: }\n 291:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==8341==ERROR: AddressSanitizer: requested allocation size 0xd6bf94d5e60 (0xd6bf94d6e60 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f9e83f4f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x557f04c9e632 in mpoller_create /sourcecode/src/kernel/mpoller.c:66\n    #2 0x557f04c976dc in Communicator::create_poller(unsigned long) /sourcecode/src/kernel/Communicator.cc:1428\n    #3 0x557f04c97903 in Communicator::init(unsigned long, unsigned long) /sourcecode/src/kernel/Communicator.cc:1451\n    #4 0x557f04c8dd86 in fuzzloop /dockerin/fuzz_drivers/tf1729046934042wjlr.cpp:42\n    #5 0x557f04cb7439 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==8341==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: Communicator::init(size_t poller_threads, size_t handler_threads)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator4initEmm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I_include/workflow -I. -Isrc/kernel -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto communicator = std::make_unique<Communicator>();\n    size_t poller_threads = (size_t)fuzzUint64(0);\n    size_t handler_threads = (size_t)fuzzUint64(1);\n    communicator->init(poller_threads, handler_threads);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/mpoller.c\n  57: mpoller_t *mpoller_create(const struct poller_params *params, size_t nthreads)\n  58: {\n  59: \tmpoller_t *mpoller;\n  60: \tsize_t size;\n  61: \n  62: \tif (nthreads == 0)\n  63: \t\tnthreads = 1;\n  64: \n  65: \tsize = offsetof(mpoller_t, poller) + nthreads * sizeof (void *);\n  66: \tmpoller = (mpoller_t *)malloc(size);\n  67: \tif (mpoller)\n  68: \t{\n  69: \t\tmpoller->nthreads = (unsigned int)nthreads;\n  70: \t\tif (__mpoller_create(params, mpoller) >= 0)\n  71: \t\t\treturn mpoller;\n  72: \n  73: \t\tfree(mpoller);\n  74: \t}\n  75: \n  76: \treturn NULL;\n  77: }\n  78: \nStacktrace #1:\nFile: /sourcecode/src/kernel/Communicator.cc\n1414: int Communicator::create_poller(size_t poller_threads)\n1415: {\n1416: \tstruct poller_params params = {\n1417: \t\t.max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n1418: \t\t.callback\t\t\t=\tCommunicator::callback,\n1419: \t};\n1420: \n1421: \tif ((ssize_t)params.max_open_files < 0)\n1422: \t\treturn -1;\n1423: \n1424: \tthis->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n1425: \tif (this->msgqueue)\n1426: \t{\n1427: \t\tparams.context = this->msgqueue;\n1428: \t\tthis->mpoller = mpoller_create(&params, poller_threads);\n1429: \t\tif (this->mpoller)\n1430: \t\t{\n1431: \t\t\tif (mpoller_start(this->mpoller) >= 0)\n1432: \t\t\t\treturn 0;\n1433: \n1434: \t\t\tmpoller_destroy(this->mpoller);\n1435: \t\t}\n1436: \n1437: \t\tmsgqueue_destroy(this->msgqueue);\n1438: \t}\n1439: \n1440: \treturn -1;\n1441: }\n1442: \nStacktrace #2:\nFile: /sourcecode/src/kernel/Communicator.cc\n1443: int Communicator::init(size_t poller_threads, size_t handler_threads)\n1444: {\n1445: \tif (poller_threads == 0)\n1446: \t{\n1447: \t\terrno = EINVAL;\n1448: \t\treturn -1;\n1449: \t}\n1450: \n1451: \tif (this->create_poller(poller_threads) >= 0)\n1452: \t{\n1453: \t\tif (this->create_handler_threads(handler_threads) >= 0)\n1454: \t\t{\n1455: \t\t\tthis->stop_flag = 0;\n1456: \t\t\treturn 0;\n1457: \t\t}\n1458: \n1459: \t\tmpoller_stop(this->mpoller);\n1460: \t\tmpoller_destroy(this->mpoller);\n1461: \t\tmsgqueue_destroy(this->msgqueue);\n1462: \t}\n1463: \n1464: \treturn -1;\n1465: }\n1466:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==30850==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abca (0x1ad7f29bbd0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fc2fa46d887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55a1fdcc047b in ring_buf_resize include/internal/ring_buf.h:244\n    #2 0x55a1fdcc0964 in ossl_quic_sstream_new ssl/quic/quic_sstream.c:69\n    #3 0x55a1fdcbf604 in fuzzloop /dockerin/fuzz_drivers/tf1730183726456bdiy.c:22\n    #4 0x55a1fdcccb99 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==30850==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:25:40\n// Signature: ossl_quic_sstream_mark_acked(QUIC_SSTREAM *qss, uint64_t start, uint64_t end)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_quic_sstream_mark_acked\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Issl/quic -DAES_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/quic_stream.h\" //extract\n#include \"internal/uint_set.h\" //extract\n#include \"internal/common.h\" //extract\n#include \"internal/ring_buf.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    size_t init_buf_size = (size_t)fuzzUint64(0);\n    QUIC_SSTREAM * qss = ossl_quic_sstream_new(init_buf_size);\n    if (qss == NULL)\n        return 0;\n    uint64_t start = fuzzUint64(1);\n    uint64_t end = fuzzUint64(2);\n    int ret = ossl_quic_sstream_mark_acked(qss, start, end);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/internal/ring_buf.h\n 234:     struct ring_buf rnew = {0};\n 235:     const unsigned char *src = NULL;\n 236:     size_t src_len = 0, copied = 0;\n 237: \n 238:     if (num_bytes == r->alloc)\n 239:         return 1;\n 240: \n 241:     if (num_bytes < ring_buf_used(r))\n 242:         return 0;\n 243: \n 244:     rnew.start = OPENSSL_malloc(num_bytes);\n 245:     if (rnew.start == NULL)\n 246:         return 0;\n 247: \n 248:     rnew.alloc          = num_bytes;\n 249:     rnew.head_offset    = r->head_offset - ring_buf_used(r);\n 250:     rnew.ctail_offset   = rnew.head_offset;\n 251: \n 252:     for (;;) {\n 253:         if (!ring_buf_get_buf_at(r, r->ctail_offset + copied, &src, &src_len)) {\n 254:             OPENSSL_free(rnew.start);\n 255: \nStacktrace #1:\nFile: /sourcecode/ssl/quic/quic_sstream.c\n  60: QUIC_SSTREAM *ossl_quic_sstream_new(size_t init_buf_size)\n  61: {\n  62:     QUIC_SSTREAM *qss;\n  63: \n  64:     qss = OPENSSL_zalloc(sizeof(QUIC_SSTREAM));\n  65:     if (qss == NULL)\n  66:         return NULL;\n  67: \n  68:     ring_buf_init(&qss->ring_buf);\n  69:     if (!ring_buf_resize(&qss->ring_buf, init_buf_size, 0)) {\n  70:         ring_buf_destroy(&qss->ring_buf, 0);\n  71:         OPENSSL_free(qss);\n  72:         return NULL;\n  73:     }\n  74: \n  75:     ossl_uint_set_init(&qss->new_set);\n  76:     ossl_uint_set_init(&qss->acked_set);\n  77:     return qss;\n  78: }\n  79:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==7068==ERROR: AddressSanitizer: requested allocation size 0x1ad7f39abdc (0x1ad7f39bbe0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fd63bf82887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5582a019584e in hi_malloc /sourcecode/alloc.h:59\n    #2 0x5582a0196a93 in sdsMakeRoomFor /sourcecode/sds.c:232\n    #3 0x5582a01983e8 in sdscatlen /sourcecode/sds.c:384\n    #4 0x5582a01761f7 in __redisAppendCommand /sourcecode/hiredis.c:1116\n    #5 0x5582a01762fc in redisAppendFormattedCommand /sourcecode/hiredis.c:1128\n    #6 0x5582a0167a75 in fuzzloop /dockerin/fuzz_drivers/tf1728369139782pjtn.c:33\n    #7 0x5582a01b3e09 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==7068==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Dhiredis_EXPORTS\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: redisAppendFormattedCommand\n// Sign: redisAppendFormattedCommand(redisContext *c, char *cmd, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"fmacros.h\" //extract\n#include <string.h> //extract\n#include <stdlib.h> //extract\n#include <assert.h> //extract\n#include <errno.h> //extract\n#include <ctype.h> //extract\n#include \"hiredis.h\" //extract\n#include \"net.h\" //extract\n#include \"sds.h\" //extract\n#include \"async.h\" //extract\n#include \"win32.h\" //extract\n\nint fuzzloop() {\n    char * ip = fuzzString(0);\n    int port = fuzzInt32(1);\n    redisContext * c = redisConnect(ip, port);\n    if (c == NULL)\n        return 0;\n    char * cmd = fuzzString(2);\n    size_t len = (size_t)fuzzUint64(3);\n    int ret = redisAppendFormattedCommand(c, cmd, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/alloc.h\n  58: static inline void *hi_malloc(size_t size) {\n  59:     return hiredisAllocFns.mallocFn(size);\n  60: }\n  61: \nStacktrace #1:\nFile: /sourcecode/sds.c\n 197: sds sdsMakeRoomFor(sds s, size_t addlen) {\n 198:     void *sh, *newsh;\n 199:     size_t avail = sdsavail(s);\n 200:     size_t len, newlen, reqlen;\n 201:     char type, oldtype = s[-1] & SDS_TYPE_MASK;\n 202:     int hdrlen;\n 203: \n 204:     /* Return ASAP if there is enough space left. */\n 205:     if (avail >= addlen) return s;\n 206: \n 207:     len = sdslen(s);\n 208:     sh = (char*)s-sdsHdrSize(oldtype);\n 209:     reqlen = newlen = (len+addlen);\n 210:     if (newlen <= len) return NULL; /* Catch size_t overflow */\n 211:     if (newlen < SDS_MAX_PREALLOC)\n 212:         newlen *= 2;\n 213:     else\n 214:         newlen += SDS_MAX_PREALLOC;\n 215: \n 216:     type = sdsReqType(newlen);\n 217: \n 218:     /* Don't use type 5: the user is appending to the string and type 5 is\n 219:      * not able to remember empty space, so sdsMakeRoomFor() must be called\n 220:      * at every appending operation. */\n 221:     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n 222: \n 223:     hdrlen = sdsHdrSize(type);\n 224:     if (hdrlen+newlen+1 <= reqlen) return NULL; /* Catch size_t overflow */\n 225:     if (oldtype==type) {\n 226:         newsh = s_realloc(sh, hdrlen+newlen+1);\n 227:         if (newsh == NULL) return NULL;\n 228:         s = (char*)newsh+hdrlen;\n 229:     } else {\n 230:         /* Since the header size changes, need to move the string forward,\n 231:          * and can't use realloc */\n 232:         newsh = s_malloc(hdrlen+newlen+1);\n 233:         if (newsh == NULL) return NULL;\n 234:         memcpy((char*)newsh+hdrlen, s, len+1);\n 235:         s_free(sh);\n 236:         s = (char*)newsh+hdrlen;\n 237:         s[-1] = type;\n 238:         sdssetlen(s, len);\n 239:     }\n 240:     sdssetalloc(s, newlen);\n 241:     return s;\n 242: }\n 243: \nStacktrace #2:\nFile: /sourcecode/sds.c\n 381: sds sdscatlen(sds s, const void *t, size_t len) {\n 382:     size_t curlen = sdslen(s);\n 383: \n 384:     s = sdsMakeRoomFor(s,len);\n 385:     if (s == NULL) return NULL;\n 386:     memcpy(s+curlen, t, len);\n 387:     sdssetlen(s, curlen+len);\n 388:     s[curlen+len] = '\\0';\n 389:     return s;\n 390: }\n 391: \nStacktrace #3:\nFile: /sourcecode/hiredis.c\n1113: int __redisAppendCommand(redisContext *c, const char *cmd, size_t len) {\n1114:     sds newbuf;\n1115: \n1116:     newbuf = sdscatlen(c->obuf,cmd,len);\n1117:     if (newbuf == NULL) {\n1118:         __redisSetError(c,REDIS_ERR_OOM,\"Out of memory\");\n1119:         return REDIS_ERR;\n1120:     }\n1121: \n1122:     c->obuf = newbuf;\n1123:     return REDIS_OK;\n1124: }\n1125: \nStacktrace #4:\nFile: /sourcecode/hiredis.c\n1126: int redisAppendFormattedCommand(redisContext *c, const char *cmd, size_t len) {\n1127: \n1128:     if (__redisAppendCommand(c, cmd, len) != REDIS_OK) {\n1129:         return REDIS_ERR;\n1130:     }\n1131: \n1132:     return REDIS_OK;\n1133: }\n1134:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==17775==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abcb (0x1ad7f29bbd0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f1f78dfe1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55a893b39331 in __gnu_cxx::new_allocator<char>::allocate(unsigned long, void const*) /usr/include/c++/11/ext/new_allocator.h:127\n    #2 0x55a893b38e35 in std::allocator_traits<std::allocator<char> >::allocate(std::allocator<char>&, unsigned long) /usr/include/c++/11/bits/alloc_traits.h:464\n    #3 0x55a893b38766 in std::_Vector_base<char, std::allocator<char> >::_M_allocate(unsigned long) /usr/include/c++/11/bits/stl_vector.h:346\n    #4 0x55a893b37673 in std::vector<char, std::allocator<char> >::_M_default_append(unsigned long) /usr/include/c++/11/bits/vector.tcc:635\n    #5 0x55a893b367da in std::vector<char, std::allocator<char> >::resize(unsigned long) /usr/include/c++/11/bits/stl_vector.h:940\n    #6 0x55a893b35f45 in YAML::ostream_wrapper::write(char const*, unsigned long) /sourcecode/src/ostream_wrapper.cpp:43\n    #7 0x55a893b348f6 in fuzzloop /dockerin/fuzz_drivers/tf1729044067554bpzh.cpp:25\n    #8 0x55a893b427b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==17775==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99 in operator new(unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:00:58\n// Signature: YAML::ostream_wrapper::write(char *str, std::size_t size)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML15ostream_wrapper5writeEPKcm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"yaml-cpp/ostream_wrapper.h\" //extract\n#include <algorithm> //extract\n#include <cstring> //extract\n#include <iostream> //extract\n#include <memory> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto ostream_wrapper = std::make_unique<YAML::ostream_wrapper>();\n    char * str = fuzzString(0);\n    std::size_t size = (std::size_t)fuzzUint64(1);\n    ostream_wrapper->write(str, size);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/ostream_wrapper.cpp\n  39: void ostream_wrapper::write(const char* str, std::size_t size) {\n  40:   if (m_pStream) {\n  41:     m_pStream->write(str, size);\n  42:   } else {\n  43:     m_buffer.resize(std::max(m_buffer.size(), m_pos + size + 1));\n  44:     std::copy(str, str + size, m_buffer.begin() + m_pos);\n  45:   }\n  46: \n  47:   for (std::size_t i = 0; i < size; i++) {\n  48:     update_pos(str[i]);\n  49:   }\n  50: }\n  51:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fc62b49cf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x564f0c9d4884 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7fc62b4a2e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7fc62b40860b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7fc62b40419a in __asan::asan_malloc(unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:980\n    #5 0x7fc62b490861 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:146\n    #6 0x564f0c9abde2 in CommTarget::init(sockaddr const*, unsigned int, int, int) /sourcecode/src/kernel/Communicator.cc:157\n    #7 0x564f0c9a7e32 in CommSchedTarget::init(sockaddr const*, unsigned int, int, int, unsigned long) /sourcecode/src/kernel/CommScheduler.cc:59\n    #8 0x564f0c9a6f17 in fuzzloop /dockerin/fuzz_drivers/tf1729046934026gpie.cpp:41\n    #9 0x564f0c9d34f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x564f0c9a6a78 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7fc62aea0d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7fc62aea0e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x564f0c9a6bc4 in _start (/dockerin/fuzz_drivers/tf1729046934026gpie.out+0x14bc4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: CommSchedTarget::init(struct sockaddr *addr, socklen_t addrlen, int connect_timeout, int response_timeout, size_t max_connections)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN15CommSchedTarget4initEPK8sockaddrjiim\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I_include/workflow -I. -Isrc/kernel -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <errno.h> //extract\n#include <stdlib.h> //extract\n#include <pthread.h> //extract\n#include \"CommScheduler.h\" //extract\n#include <memory> //autogen\n#include \"_include/workflow/Communicator.h\" //autogen\n#include \"/usr/include/x86_64-linux-gnu/bits/socket.h\" //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto commtarget = std::make_unique<CommSchedTarget>();\n    //file: /usr/include/x86_64-linux-gnu/bits/socket.h:180\n    //struct sockaddr\n    //  {\n    //    __SOCKADDR_COMMON (sa_);\t/* Common data: address family and length.  */\n    //    char sa_data[14];\t\t/* Address data.  */\n    //  };\n    sockaddr *addr = (sockaddr *)driverAllocMem(sizeof(sockaddr));\n    char *temp = fuzzFixBlob(0, sizeof(sockaddr));\n    memcpy(addr, temp, sizeof(addr));\n    unsigned int addrlen = fuzzUint32(1);\n    int connect_timeout = fuzzInt32(2);\n    int response_timeout = fuzzInt32(3);\n    size_t max_connections = (size_t)fuzzUint64(4);\n    commtarget->init(addr, addrlen, connect_timeout, response_timeout, max_connections);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n 152: int CommTarget::init(const struct sockaddr *addr, socklen_t addrlen,\n 153: \t\t\t\t\t int connect_timeout, int response_timeout)\n 154: {\n 155: \tint ret;\n 156: \n 157: \tthis->addr = (struct sockaddr *)malloc(addrlen);\n 158: \tif (this->addr)\n 159: \t{\n 160: \t\tret = pthread_mutex_init(&this->mutex, NULL);\n 161: \t\tif (ret == 0)\n 162: \t\t{\n 163: \t\t\tmemcpy(this->addr, addr, addrlen);\n 164: \t\t\tthis->addrlen = addrlen;\n 165: \t\t\tthis->connect_timeout = connect_timeout;\n 166: \t\t\tthis->response_timeout = response_timeout;\n 167: \t\t\tINIT_LIST_HEAD(&this->idle_list);\n 168: \n 169: \t\t\tthis->ssl_ctx = NULL;\n 170: \t\t\tthis->ssl_connect_timeout = 0;\n 171: \t\t\treturn 0;\n 172: \t\t}\n 173: \n 174: \t\terrno = ret;\n 175: \t\tfree(this->addr);\n 176: \t}\n 177: \n 178: \treturn -1;\n 179: }\n 180: \nStacktrace #1:\nFile: /sourcecode/src/kernel/CommScheduler.cc\n  47: int CommSchedTarget::init(const struct sockaddr *addr, socklen_t addrlen,\n  48: \t\t\t\t\t\t  int connect_timeout, int response_timeout,\n  49: \t\t\t\t\t\t  size_t max_connections)\n  50: {\n  51: \tint ret;\n  52: \n  53: \tif (max_connections == 0)\n  54: \t{\n  55: \t\terrno = EINVAL;\n  56: \t\treturn -1;\n  57: \t}\n  58: \n  59: \tif (this->CommTarget::init(addr, addrlen, connect_timeout,\n  60: \t\t\t\t\t\t\t   response_timeout) >= 0)\n  61: \t{\n  62: \t\tret = pthread_mutex_init(&this->mutex, NULL);\n  63: \t\tif (ret == 0)\n  64: \t\t{\n  65: \t\t\tret = pthread_cond_init(&this->cond, NULL);\n  66: \t\t\tif (ret == 0)\n  67: \t\t\t{\n  68: \t\t\t\tthis->max_load = max_connections;\n  69: \t\t\t\tthis->cur_load = 0;\n  70: \t\t\t\tthis->wait_cnt = 0;\n  71: \t\t\t\tthis->group = NULL;\n  72: \t\t\t\treturn 0;\n  73: \t\t\t}\n  74: \n  75: \t\t\tpthread_mutex_destroy(&this->mutex);\n  76: \t\t}\n  77: \n  78: \t\terrno = ret;\n  79: \t\tthis->CommTarget::deinit();\n  80: \t}\n  81: \n  82: \treturn -1;\n  83: }\n  84:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4227==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abca (0x1ad7f29bbd0 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f6566f21887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5577aebd1615 in flatcc_builder_alloc /sourcecode/src/runtime/builder.c:2039\n    #2 0x5577aebb1774 in fuzzloop /dockerin/fuzz_drivers/tf1728556408598rcyf.c:20\n    #3 0x5577aebe14b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==4227==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/test/json_test/generated -Iinclude -Isrc/runtime -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1 -DFLATCC_JSON_PARSE_WIDE_SPACE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_builder_alloc\n// Sign: flatcc_builder_alloc(size_t size)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include \"flatcc/flatcc_builder.h\" //extract\n#include \"flatcc/flatcc_emitter.h\" //extract\n\nint fuzzloop() {\n    size_t size = (size_t)fuzzUint64(0);\n    void * ret = flatcc_builder_alloc(size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/runtime/builder.c\n2037: void *flatcc_builder_alloc(size_t size)\n2038: {\n2039:     return FLATCC_BUILDER_ALLOC(size);\n2040: }\n2041:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f7117273f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5652d0c5f784 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7f7117279e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7f71171df60b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7f71171db19a in __asan::asan_malloc(unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:980\n    #5 0x7f7117267861 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:146\n    #6 0x5652d0c2429a in default_malloc_ex /sourcecode/crypto/mem.c:79\n    #7 0x5652d0c24e12 in CRYPTO_malloc /sourcecode/crypto/mem.c:308\n    #8 0x5652d0c23f6a in BUF_memdup /sourcecode/crypto/buffer/buf_str.c:91\n    #9 0x5652d0c23db9 in fuzzloop /dockerin/fuzz_drivers/tf1728981987322gyqa.c:22\n    #10 0x5652d0c5e3f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x5652d0c23b68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f7116ec3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f7116ec3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x5652d0c23cb4 in _start (/dockerin/fuzz_drivers/tf1728981987322gyqa.out+0x3dcb4)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Icrypto -Icrypto/modes -Icrypto/asn1 -Icrypto/evp -Iinclude -Icrypto/buffer -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DTERMIO -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM\n// Version: dev-v2.4.6-20241015-543df72\n// Target: BUF_memdup\n// Sign: BUF_memdup(void *data, size_t siz)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdio.h> //extract\n#include \"cryptlib.h\" //extract\n#include <openssl/buffer.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(0);\n    size_t siz = (size_t)fuzzUint64(1);\n    void * ret = BUF_memdup(data, siz);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/mem.c\n  78: static void *default_malloc_ex(size_t num, const char *file, int line)\n  79: \t{ return malloc_func(num); }\n  80: \nStacktrace #1:\nFile: /sourcecode/crypto/mem.c\n 296: void *CRYPTO_malloc(int num, const char *file, int line)\n 297: \t{\n 298: \tvoid *ret = NULL;\n 299: \n 300: \tif (num <= 0) return NULL;\n 301: \n 302: \tallow_customize = 0;\n 303: \tif (malloc_debug_func != NULL)\n 304: \t\t{\n 305: \t\tallow_customize_debug = 0;\n 306: \t\tmalloc_debug_func(NULL, num, file, line, 0);\n 307: \t\t}\n 308: \tret = malloc_ex_func(num,file,line);\n 309: #ifdef LEVITTE_DEBUG_MEM\n 310: \tfprintf(stderr, \"LEVITTE_DEBUG_MEM:         > 0x%p (%d)\\n\", ret, num);\n 311: #endif\n 312: \tif (malloc_debug_func != NULL)\n 313: \t\tmalloc_debug_func(ret, num, file, line, 1);\n 314: \n 315: #ifndef OPENSSL_CPUID_OBJ\n 316:         /* Create a dependency on the value of 'cleanse_ctr' so our memory\n 317:          * sanitisation function can't be optimised out. NB: We only do\n 318:          * this for >2Kb so the overhead doesn't bother us. */\n 319:         if(ret && (num > 2048))\n 320: \t{\textern unsigned char cleanse_ctr;\n 321:                 ((unsigned char *)ret)[0] = cleanse_ctr;\n 322: \t}\n 323: #endif\n 324: \n 325: \treturn ret;\n 326: \t}\n 327: \nStacktrace #2:\nFile: /sourcecode/crypto/buffer/buf_str.c\n  85: void *BUF_memdup(const void *data, size_t siz)\n  86: \t{\n  87: \tvoid *ret;\n  88: \n  89: \tif (data == NULL) return(NULL);\n  90: \n  91: \tret=OPENSSL_malloc(siz);\n  92: \tif (ret == NULL) \n  93: \t\t{\n  94: \t\tBUFerr(BUF_F_BUF_MEMDUP,ERR_R_MALLOC_FAILURE);\n  95: \t\treturn(NULL);\n  96: \t\t}\n  97: \treturn memcpy(ret, data, siz);\n  98: \t}\t\n  99:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2846==ERROR: AddressSanitizer: requested allocation size 0x20000000000 (0x20000001000 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7f7420220c38 in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164\n    #1 0x557fc683d4ea in flatcc_builder_default_alloc /sourcecode/src/runtime/builder.c:168\n    #2 0x557fc683c89e in fuzzloop /dockerin/fuzz_drivers/tf1728556408599uxgl.c:34\n    #3 0x557fc686c5c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==2846==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164 in __interceptor_realloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/test/json_test/generated -Iinclude -Isrc/runtime -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1 -DFLATCC_JSON_PARSE_WIDE_SPACE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_builder_default_alloc\n// Sign: flatcc_builder_default_alloc(void *alloc_context, flatcc_iovec_t *b, size_t request, int zero_fill, int hint)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include \"flatcc/flatcc_builder.h\" //extract\n#include \"flatcc/flatcc_emitter.h\" //extract\n#include \"include/flatcc/flatcc_iov.h\" //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * alloc_context = (void *)fuzzData(0);\n    //file: include/flatcc/flatcc_iov.h:16\n    //struct flatcc_iovec {\n    //    void *iov_base;\n    //    size_t iov_len;\n    //};\n    struct flatcc_iovec *b = (struct flatcc_iovec *)driverAllocMem(sizeof(struct flatcc_iovec));\n    b->iov_base = (void *)fuzzData(1);\n    b->iov_len = (unsigned long)fuzzUint64(2);\n    \n    size_t request = (size_t)fuzzUint64(3);\n    int zero_fill = fuzzInt32(4);\n    int hint = fuzzInt32(5);\n    int ret = flatcc_builder_default_alloc(alloc_context, b, request, zero_fill, hint);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/runtime/builder.c\n 123: int flatcc_builder_default_alloc(void *alloc_context, iovec_t *b, size_t request, int zero_fill, int hint)\n 124: {\n 125:     void *p;\n 126:     size_t n;\n 127: \n 128:     (void)alloc_context;\n 129: \n 130:     if (request == 0) {\n 131:         if (b->iov_base) {\n 132:             FLATCC_BUILDER_FREE(b->iov_base);\n 133:             b->iov_base = 0;\n 134:             b->iov_len = 0;\n 135:         }\n 136:         return 0;\n 137:     }\n 138:     switch (hint) {\n 139:     case flatcc_builder_alloc_ds:\n 140:         n = 256;\n 141:         break;\n 142:     case flatcc_builder_alloc_ht:\n 143:         /* Should be exact size, or space size is just wasted. */\n 144:         n = request;\n 145:         break;\n 146:     case flatcc_builder_alloc_fs:\n 147:         n = sizeof(__flatcc_builder_frame_t) * 8;\n 148:         break;\n 149:     case flatcc_builder_alloc_us:\n 150:         n = 64;\n 151:         break;\n 152:     default:\n 153:         /*\n 154:          * We have many small structures - vs stack for tables with few\n 155:          * elements, and few offset fields in patch log. No need to\n 156:          * overallocate in case of busy small messages.\n 157:          */\n 158:         n = 32;\n 159:         break;\n 160:     }\n 161:     while (n < request) {\n 162:         n *= 2;\n 163:     }\n 164:     if (request <= b->iov_len && b->iov_len / 2 >= n) {\n 165:         /* Add hysteresis to shrink. */\n 166:         return 0;\n 167:     }\n 168:     if (!(p = FLATCC_BUILDER_REALLOC(b->iov_base, n))) {\n 169:         return -1;\n 170:     }\n 171:     /* Realloc might also shrink. */\n 172:     if (zero_fill && b->iov_len < n) {\n 173:         memset((uint8_t *)p + b->iov_len, 0, n - b->iov_len);\n 174:     }\n 175:     b->iov_base = p;\n 176:     b->iov_len = n;\n 177:     return 0;\n 178: }\n 179:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==14518==ERROR: AddressSanitizer: requested allocation size 0xd6bf94d5e50 (0xd6bf94d6e50 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fb1cdd9f357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102\n    #1 0x5630b908a6a4 in WFResourcePool::create(unsigned long) /sourcecode/src/factory/WFResourcePool.cc:77\n    #2 0x5630b908a8b5 in WFResourcePool::WFResourcePool(unsigned long) /sourcecode/src/factory/WFResourcePool.cc:92\n    #3 0x5630b90899a6 in std::_MakeUniq<WFResourcePool>::__single_object std::make_unique<WFResourcePool, unsigned long&>(unsigned long&) /usr/include/c++/11/bits/unique_ptr.h:962\n    #4 0x5630b90897c8 in fuzzloop /dockerin/fuzz_drivers/tf1729046934163bpfd.cpp:24\n    #5 0x5630b9096f79 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==14518==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102 in operator new[](unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: WFResourcePool::post(void *res)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14WFResourcePool4postEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/factory -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <string.h> //extract\n#include \"list.h\" //extract\n#include \"WFTask.h\" //extract\n#include \"WFResourcePool.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    size_t n = (size_t)fuzzUint64(0);\n    auto wfresourcepool = std::make_unique<WFResourcePool>(n);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * res = (void *)fuzzData(1);\n    wfresourcepool->post(res);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/factory/WFResourcePool.cc\n  75: void WFResourcePool::create(size_t n)\n  76: {\n  77: \tthis->data.res = new void *[n];\n  78: \tthis->data.value = n;\n  79: \tthis->data.index = 0;\n  80: \tINIT_LIST_HEAD(&this->data.wait_list);\n  81: \tthis->data.pool = this;\n  82: }\n  83: \nStacktrace #1:\nFile: /sourcecode/src/factory/WFResourcePool.cc\n  90: WFResourcePool::WFResourcePool(size_t n)\n  91: {\n  92: \tthis->create(n);\n  93: \tmemset(this->data.res, 0, n * sizeof (void *));\n  94: }\n  95:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==209785==ERROR: AddressSanitizer: requested allocation size 0xd6bf94d5e60 (0xd6bf94d6e60 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fbf0fe6a887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55cd7281e612 in mpoller_create /sourcecode/src/kernel/mpoller.c:66\n    #2 0x55cd728176bc in Communicator::create_poller(unsigned long) /sourcecode/src/kernel/Communicator.cc:1428\n    #3 0x55cd7280dd66 in fuzzloop /dockerin/fuzz_drivers/tf1729046934035tfdd.cpp:41\n    #4 0x55cd72837419 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==209785==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:48:39\n// Signature: Communicator::create_poller(size_t poller_threads)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator13create_pollerEm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I_include/workflow -I. -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto communicator = std::make_unique<Communicator>();\n    size_t poller_threads = (size_t)fuzzUint64(0);\n    communicator->create_poller(poller_threads);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/mpoller.c\n  57: mpoller_t *mpoller_create(const struct poller_params *params, size_t nthreads)\n  58: {\n  59: \tmpoller_t *mpoller;\n  60: \tsize_t size;\n  61: \n  62: \tif (nthreads == 0)\n  63: \t\tnthreads = 1;\n  64: \n  65: \tsize = offsetof(mpoller_t, poller) + nthreads * sizeof (void *);\n  66: \tmpoller = (mpoller_t *)malloc(size);\n  67: \tif (mpoller)\n  68: \t{\n  69: \t\tmpoller->nthreads = (unsigned int)nthreads;\n  70: \t\tif (__mpoller_create(params, mpoller) >= 0)\n  71: \t\t\treturn mpoller;\n  72: \n  73: \t\tfree(mpoller);\n  74: \t}\n  75: \n  76: \treturn NULL;\n  77: }\n  78: \nStacktrace #1:\nFile: /sourcecode/src/kernel/Communicator.cc\n1414: int Communicator::create_poller(size_t poller_threads)\n1415: {\n1416: \tstruct poller_params params = {\n1417: \t\t.max_open_files\t\t=\t(size_t)sysconf(_SC_OPEN_MAX),\n1418: \t\t.callback\t\t\t=\tCommunicator::callback,\n1419: \t};\n1420: \n1421: \tif ((ssize_t)params.max_open_files < 0)\n1422: \t\treturn -1;\n1423: \n1424: \tthis->msgqueue = msgqueue_create(16 * 1024, sizeof (struct poller_result));\n1425: \tif (this->msgqueue)\n1426: \t{\n1427: \t\tparams.context = this->msgqueue;\n1428: \t\tthis->mpoller = mpoller_create(&params, poller_threads);\n1429: \t\tif (this->mpoller)\n1430: \t\t{\n1431: \t\t\tif (mpoller_start(this->mpoller) >= 0)\n1432: \t\t\t\treturn 0;\n1433: \n1434: \t\t\tmpoller_destroy(this->mpoller);\n1435: \t\t}\n1436: \n1437: \t\tmsgqueue_destroy(this->msgqueue);\n1438: \t}\n1439: \n1440: \treturn -1;\n1441: }\n1442:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==194==ERROR: AddressSanitizer: requested allocation size 0x1ad7f29abd6 (0x1ad7f29bbd8 after adjustments for alignment, red zones etc.) exceeds maximum supported size of 0x10000000000 (thread T0)\n    #0 0x7fed849ee887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562ecc136db7 in __flatcc_fb_create_join_path_n /sourcecode/src/compiler/fileio.c:60\n    #2 0x562ecc13722e in __flatcc_fb_create_path_ext_n /sourcecode/src/compiler/fileio.c:88\n    #3 0x562ecc13656b in fuzzloop /dockerin/fuzz_drivers/tf1728556408511bppf.c:20\n    #4 0x562ecc140ef9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==194==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: allocation-size-too-big ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: __flatcc_fb_create_path_ext_n\n// Sign: __flatcc_fb_create_path_ext_n(char *path, size_t path_len, char *ext)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"src/compiler/fileio.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * path = fuzzString(0);\n    size_t path_len = (size_t)fuzzUint64(1);\n    char * ext = fuzzString(2);\n    char * ret = __flatcc_fb_create_path_ext_n(path, path_len, ext);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/fileio.c\n  44: char *fb_create_join_path_n(const char *prefix, size_t prefix_len,\n  45:         const char *suffix, size_t suffix_len, const char *ext, int path_sep)\n  46: {\n  47:     char *path;\n  48:     size_t ext_len = ext ? strlen(ext) : 0;\n  49:     size_t n;\n  50: \n  51:     if (!prefix ||\n  52:             (suffix_len > 0 && (suffix[0] == '/' || suffix[0] == '\\\\')) ||\n  53:             (suffix_len > 1 && suffix[1] == ':')) {\n  54:         prefix_len = 0;\n  55:     }\n  56:     if (path_sep && (prefix_len == 0 ||\n  57:             (prefix[prefix_len - 1] == '/' || prefix[prefix_len - 1] == '\\\\'))) {\n  58:         path_sep = 0;\n  59:     }\n  60:     path = malloc(prefix_len + !!path_sep + suffix_len + ext_len + 1);\n  61:     if (!path) {\n  62:         return 0;\n  63:     }\n  64:     n = 0;\n  65:     if (prefix_len > 0) {\n  66:         memcpy(path, prefix, prefix_len);\n  67:         n += prefix_len;\n  68:     }\n  69:     if (path_sep) {\n  70:         path[n++] = '/';\n  71:     }\n  72:     memcpy(path + n, suffix, suffix_len);\n  73:     n += suffix_len;\n  74:     memcpy(path + n, ext, ext_len);\n  75:     n += ext_len;\n  76:     path[n] = '\\0';\n  77:     return path;\n  78: }\n  79: \nStacktrace #1:\nFile: /sourcecode/src/compiler/fileio.c\n  86: char *fb_create_path_ext_n(const char *path, size_t path_len, const char *ext)\n  87: {\n  88:     return fb_create_join_path_n(0, 0, path, path_len, ext, 0);\n  89: }\n  90:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "高危", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==557545==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffce4250800 in thread T0\n    #0 0x7fb5acc2fd07 in operator delete(void*) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:160\n    #1 0x555c63c4e854 in WFGraphNode::~WFGraphNode() /sourcecode/src/factory/WFGraphTask.cc:45\n    #2 0x555c63c4df0b in WFGraphNode::done() /sourcecode/src/factory/WFGraphTask.cc:33\n    #3 0x555c63c48bc3 in fuzzloop /dockerin/fuzz_drivers/tf1729655207806frmv.cpp:17\n    #4 0x555c63c68489 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x555c63c485c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fb5ac006d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fb5ac006e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x555c63c48714 in _start (/dockerin/fuzz_drivers/tf1729655207806frmv.out+0x40714)\n\nAddress 0x7ffce4250800 is located in stack of thread T0 at offset 48 in frame\n    #0 0x555c63c4890b in fuzzloop /dockerin/fuzz_drivers/tf1729655207806frmv.cpp:14\n\n  This frame has 1 object(s):\n    [48, 152) 'node' (line 15) <== Memory access at offset 48 is inside this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: bad-free ../../../../src/libsanitizer/asan/asan_new_delete.cpp:160 in operator delete(void*)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:15\n// Signature: WFGraphNode::done()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN11WFGraphNode4doneEv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/WFGraphTask.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    WFGraphNode node;\n    node.user_data = (void *)fuzzUint64(0);\n    node.done();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/factory/WFGraphTask.cc\n  35: \treturn series->pop();\n  36: }\n  37: \n  38: WFGraphNode::~WFGraphNode()\n  39: {\n  40: \tif (this->user_data)\n  41: \t{\n  42: \t\tfor (WFGraphNode *node : this->successors)\n  43: \t\t\tnode->WFCounterTask::count();\n  44: \t}\n  45: }\n  46: \n  47: WFGraphNode& WFGraphTask::create_graph_node(SubTask *task)\n  48: {\n  49: \tWFGraphNode *node = new WFGraphNode;\n  50: \tSeriesWork *series = Workflow::create_series_work(node, node, nullptr);\n  51: \n  52: \tseries->push_back(task);\n  53: \tthis->parallel->add_series(series);\n  54: \treturn *node;\n  55: }\n  56: \nStacktrace #1:\nFile: /sourcecode/src/factory/WFGraphTask.cc\n  23: SubTask *WFGraphNode::done()\n  24: {\n  25: \tSeriesWork *series = series_of(this);\n  26: \n  27: \tif (!this->user_data)\n  28: \t{\n  29: \t\tthis->value = 1;\n  30: \t\tthis->user_data = (void *)1;\n  31: \t}\n  32: \telse\n  33: \t\tdelete this;\n  34: \n  35: \treturn series->pop();\n  36: }\n  37:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==558728==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7fffbdca8630 in thread T0\n    #0 0x7f22f22f424f in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172\n    #1 0x55eedb4ce97f in WFResolverTask::~WFResolverTask() (/dockerin/fuzz_drivers/tf1729655329697noaw.out+0x2d497f)\n    #2 0x55eedb4e0c3a in WFResolverTask::task_callback() /sourcecode/src/nameservice/WFDnsResolver.cc:752\n    #3 0x55eedb4dab77 in WFResolverTask::done() /sourcecode/src/nameservice/WFDnsResolver.cc:579\n    #4 0x55eedb4c84c2 in fuzzloop /dockerin/fuzz_drivers/tf1729655329697noaw.cpp:47\n    #5 0x55eedb644d19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55eedb4c7838 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f22f16cad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f22f16cae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55eedb4c7984 in _start (/dockerin/fuzz_drivers/tf1729655329697noaw.out+0x2cd984)\n\nAddress 0x7fffbdca8630 is located in stack of thread T0 at offset 384 in frame\n    #0 0x55eedb4c7b94 in fuzzloop /dockerin/fuzz_drivers/tf1729655329697noaw.cpp:17\n\n  This frame has 6 object(s):\n    [48, 49) '<unknown>'\n    [64, 96) 'ep_params' (line 30)\n    [128, 168) 'ns_params' (line 20)\n    [208, 280) 'uri' (line 19)\n    [320, 352) 'callback' (line 42)\n    [384, 576) 'task' (line 44) <== Memory access at offset 384 is inside this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: bad-free ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172 in operator delete(void*, unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:20\n// Signature: WFResolverTask::done()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14WFResolverTask4doneEv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/WFDnsResolver.h\"\n#include \"_include/workflow/WFGlobal.h\"\n#include \"_include/workflow/WFNameService.h\" // Added to fix undeclared symbol \"WFNSParams\" error\n#include \"_include/workflow/EndpointParams.h\" // Added to fix undeclared symbol \"EndpointParams\" error\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    ParsedURI uri; // Initialize the uri member\n    struct WFNSParams ns_params = {\n        .type = (enum TransportType)fuzzUint8(1), // Cast to correct type\n        .uri = uri, // Initialize the uri member\n        .info = fuzzString(2),\n        .fixed_addr = fuzzBool(3),\n        .retry_times = fuzzUint8(0),\n        .tracing = nullptr // Initialize tracing to nullptr\n    };\n    unsigned int dns_ttl_default = fuzzUint32(4);\n    unsigned int dns_ttl_min = fuzzUint32(5);\n    struct EndpointParams ep_params = {\n        .address_family = fuzzUint8(6),\n        .max_connections = fuzzUint32(7),\n        .connect_timeout = fuzzUint32(8),\n        .response_timeout = fuzzUint32(9),\n        .ssl_connect_timeout = fuzzUint32(10),\n        .use_tls_sni = fuzzBool(11)\n    };\n    const char *host = fuzzString(12);\n    unsigned short port = fuzzUint16(13);\n\n    // Use std::function to wrap the lambda for the callback\n    std::function<void(WFRouterTask*)> callback = [](WFRouterTask *task) {};\n\n    WFResolverTask task(&ns_params, dns_ttl_default, dns_ttl_min, &ep_params, std::move(callback));\n    task.host_ = host;\n    task.port_ = port;\n    task.done();\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/WFDnsResolver.cc\n 735: void WFResolverTask::task_callback()\n 736: {\n 737: \tif (in_guard_)\n 738: \t{\n 739: \t\tint family = ep_params_.address_family;\n 740: \t\tstd::string cache_host = __get_cache_host(host_, family);\n 741: \t\tstd::string guard_name = __get_guard_name(cache_host, port_);\n 742: \n 743: \t\tif (this->state == WFT_STATE_DNS_ERROR)\n 744: \t\t\tmsg_ = (void *)(intptr_t)this->error;\n 745: \n 746: \t\tWFTaskFactory::release_guard_safe(guard_name, msg_);\n 747: \t}\n 748: \n 749: \tif (this->callback)\n 750: \t\tthis->callback(this);\n 751: \n 752: \tdelete this;\n 753: }\n 754: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/WFDnsResolver.cc\n 574: SubTask *WFResolverTask::done()\n 575: {\n 576: \tSeriesWork *series = series_of(this);\n 577: \n 578: \tif (!has_next_)\n 579: \t\ttask_callback();\n 580: \telse\n 581: \t\thas_next_ = false;\n 582: \n 583: \treturn series->pop();\n 584: }\n 585:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==376835==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffeb37642f0 in thread T0\n    #0 0x7f33fd2c624f in operator delete(void*, unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172\n    #1 0x55ab5fbf286d in PolicyAddrParams::~PolicyAddrParams() _include/workflow/WFServiceGovernance.h:75\n    #2 0x55ab5fbf2bda in EndpointAddress::~EndpointAddress() _include/workflow/WFServiceGovernance.h:97\n    #3 0x55ab5fbf204f in fuzzloop /dockerin/fuzz_drivers/tf1729655254723gomd.cpp:27\n    #4 0x55ab5fdbc409 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55ab5fbf1978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f33fc69cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f33fc69ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55ab5fbf1ac4 in _start (/dockerin/fuzz_drivers/tf1729655254723gomd.out+0x376ac4)\n\nAddress 0x7ffeb37642f0 is located in stack of thread T0 at offset 160 in frame\n    #0 0x55ab5fbf1b98 in fuzzloop /dockerin/fuzz_drivers/tf1729655254723gomd.cpp:15\n\n  This frame has 6 object(s):\n    [48, 49) '<unknown>'\n    [64, 120) 'addrParams' (line 18)\n    [160, 216) 'params' (line 23) <== Memory access at offset 160 is inside this variable\n    [256, 288) '<unknown>'\n    [320, 472) 'addr' (line 24)\n    [544, 856) 'policy' (line 17)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: bad-free ../../../../src/libsanitizer/asan/asan_new_delete.cpp:172 in operator delete(void*, unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:01\n// Signature: UPSGroupPolicy::hash_map_add_addr(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14UPSGroupPolicy17hash_map_add_addrEP15EndpointAddress\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFServiceGovernance.h\" // Added to fix undeclared symbol errors\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    UPSGroupPolicy policy;\n    AddressParams addrParams; // Create an AddressParams object\n    addrParams.weight = fuzzUint16(1);\n    addrParams.server_type = fuzzInt8(2);\n    addrParams.group_id = fuzzInt32(3);\n\n    PolicyAddrParams params(&addrParams); // Create a PolicyAddrParams object using AddressParams\n    EndpointAddress addr(fuzzString(0), &params); // Provide the required arguments\n    policy.hash_map_add_addr(&addr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/_include/workflow/WFServiceGovernance.h\n  75: \tvirtual ~PolicyAddrParams() { }\n  76: \nStacktrace #1:\nFile: /sourcecode/_include/workflow/WFServiceGovernance.h\n  97: \tvirtual ~EndpointAddress() { delete this->params; }\n  98:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==16971==ERROR: AddressSanitizer: calloc parameters overflow: count * size (-956286606 * 4) cannot be represented in type size_t (thread T0)\n    #0 0x7fc88bb92a57 in __interceptor_calloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154\n    #1 0x561510ab47b0 in real_calloc /sourcecode/src/stdlib/SDL_malloc.c:5197\n    #2 0x561510ab4de8 in SDL_calloc_REAL /sourcecode/src/stdlib/SDL_malloc.c:5311\n    #3 0x5615105f6dc8 in SDL_NewAudioStream_REAL /sourcecode/src/audio/SDL_audiocvt.c:1056\n    #4 0x56151025be2c in SDL_NewAudioStream /sourcecode/src/dynapi/SDL_dynapi_procs.h:680\n    #5 0x561510245a5e in fuzzloop /dockerin/fuzz_drivers/tf1728900796364mhut.c:30\n    #6 0x561510b01279 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==16971==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: calloc-overflow ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154 in __interceptor_calloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/dynapi -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_audio.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_audio.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_AudioStreamAvailable\n// Sign: SDL_AudioStreamAvailable(SDL_AudioStream *a)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"SDL_config.h\" //extract\n#include \"SDL_dynapi.h\" //extract\n#include \"SDL.h\" //extract\n#include \"SDL_syswm.h\" //extract\n#include \"SDL_vulkan.h\" //extract\n#include \"build/include/SDL2/SDL_audio.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned short a = fuzzUint16(0);\n    unsigned char b = fuzzUint8(1);\n    int c = fuzzInt32(2);\n    unsigned short d = fuzzUint16(3);\n    unsigned char e = fuzzUint8(4);\n    int f = fuzzInt32(5);\n    SDL_AudioStream * a1 = SDL_NewAudioStream(a, b, c, d, e, f);\n    if (a1 == NULL)\n        return 0;\n    int ret = SDL_AudioStreamAvailable(a1);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5197: static void* SDLCALL real_calloc(size_t n, size_t s) { return calloc(n, s); }\n5198: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5302: void *SDL_calloc(size_t nmemb, size_t size)\n5303: {\n5304:     void *mem;\n5305: \n5306:     if (!nmemb || !size) {\n5307:         nmemb = 1;\n5308:         size = 1;\n5309:     }\n5310: \n5311:     mem = s_mem.calloc_func(nmemb, size);\n5312:     if (mem) {\n5313:         SDL_AtomicIncRef(&s_mem.num_allocations);\n5314:     }\n5315:     return mem;\n5316: }\n5317: \nStacktrace #2:\nFile: /sourcecode/src/audio/SDL_audiocvt.c\n1010: SDL_AudioStream *SDL_NewAudioStream(const SDL_AudioFormat src_format,\n1011:                    const Uint8 src_channels,\n1012:                    const int src_rate,\n1013:                    const SDL_AudioFormat dst_format,\n1014:                    const Uint8 dst_channels,\n1015:                    const int dst_rate)\n1016: {\n1017:     int packetlen = 4096; /* !!! FIXME: good enough for now. */\n1018:     Uint8 pre_resample_channels;\n1019:     SDL_AudioStream *retval;\n1020: \n1021:     if (src_channels == 0) {\n1022:         SDL_InvalidParamError(\"src_channels\");\n1023:         return NULL;\n1024:     }\n1025: \n1026:     if (dst_channels == 0) {\n1027:         SDL_InvalidParamError(\"dst_channels\");\n1028:         return NULL;\n1029:     }\n1030: \n1031:     retval = (SDL_AudioStream *)SDL_calloc(1, sizeof(SDL_AudioStream));\n1032:     if (!retval) {\n1033:         SDL_OutOfMemory();\n1034:         return NULL;\n1035:     }\n1036: \n1037:     /* If increasing channels, do it after resampling, since we'd just\n1038:        do more work to resample duplicate channels. If we're decreasing, do\n1039:        it first so we resample the interpolated data instead of interpolating\n1040:        the resampled data (!!! FIXME: decide if that works in practice, though!). */\n1041:     pre_resample_channels = SDL_min(src_channels, dst_channels);\n1042: \n1043:     retval->first_run = SDL_TRUE;\n1044:     retval->src_sample_frame_size = (SDL_AUDIO_BITSIZE(src_format) / 8) * src_channels;\n1045:     retval->src_format = src_format;\n1046:     retval->src_channels = src_channels;\n1047:     retval->src_rate = src_rate;\n1048:     retval->dst_sample_frame_size = (SDL_AUDIO_BITSIZE(dst_format) / 8) * dst_channels;\n1049:     retval->dst_format = dst_format;\n1050:     retval->dst_channels = dst_channels;\n1051:     retval->dst_rate = dst_rate;\n1052:     retval->pre_resample_channels = pre_resample_channels;\n1053:     retval->packetlen = packetlen;\n1054:     retval->rate_incr = ((double)dst_rate) / ((double)src_rate);\n1055:     retval->resampler_padding_samples = ResamplerPadding(retval->src_rate, retval->dst_rate) * pre_resample_channels;\n1056:     retval->resampler_padding = (float *)SDL_calloc(retval->resampler_padding_samples ? retval->resampler_padding_samples : 1, sizeof(float));\n1057: \n1058:     if (!retval->resampler_padding) {\n1059:         SDL_FreeAudioStream(retval);\n1060:         SDL_OutOfMemory();\n1061:         return NULL;\n1062:     }\n1063: \n1064:     retval->staging_buffer_size = ((retval->resampler_padding_samples / retval->pre_resample_channels) * retval->src_sample_frame_size);\n1065:     if (retval->staging_buffer_size > 0) {\n1066:         retval->staging_buffer = (Uint8 *)SDL_malloc(retval->staging_buffer_size);\n1067:         if (!retval->staging_buffer) {\n1068:             SDL_FreeAudioStream(retval);\n1069:             SDL_OutOfMemory();\n1070:             return NULL;\n1071:         }\n1072:     }\n1073: \n1074:     /* Not resampling? It's an easy conversion (and maybe not even that!) */\n1075:     if (src_rate == dst_rate) {\n1076:         retval->cvt_before_resampling.needed = SDL_FALSE;\n1077:         if (SDL_BuildAudioCVT(&retval->cvt_after_resampling, src_format, src_channels, dst_rate, dst_format, dst_channels, dst_rate) < 0) {\n1078:             SDL_FreeAudioStream(retval);\n1079:             return NULL; /* SDL_BuildAudioCVT should have called SDL_SetError. */\n1080:         }\n1081:     } else {\n1082:         /* Don't resample at first. Just get us to Float32 format. */\n1083:         /* !!! FIXME: convert to int32 on devices without hardware float. */\n1084:         if (SDL_BuildAudioCVT(&retval->cvt_before_resampling, src_format, src_channels, src_rate, AUDIO_F32SYS, pre_resample_channels, src_rate) < 0) {\n1085:             SDL_FreeAudioStream(retval);\n1086:             return NULL; /* SDL_BuildAudioCVT should have called SDL_SetError. */\n1087:         }\n1088: \n1089: #ifdef HAVE_LIBSAMPLERATE_H\n1090:         SetupLibSampleRateResampling(retval);\n1091: #endif\n1092: \n1093:         if (!retval->resampler_func) {\n1094:             retval->resampler_state = SDL_calloc(retval->resampler_padding_samples, sizeof(float));\n1095:             if (!retval->resampler_state) {\n1096:                 SDL_FreeAudioStream(retval);\n1097:                 SDL_OutOfMemory();\n1098:                 return NULL;\n1099:             }\n1100: \n1101:             retval->resampler_func = SDL_ResampleAudioStream;\n1102:             retval->reset_resampler_func = SDL_ResetAudioStreamResampler;\n1103:             retval->cleanup_resampler_func = SDL_CleanupAudioStreamResampler;\n1104:         }\n1105: \n1106:         /* Convert us to the final format after resampling. */\n1107:         if (SDL_BuildAudioCVT(&retval->cvt_after_resampling, AUDIO_F32SYS, pre_resample_channels, dst_rate, dst_format, dst_channels, dst_rate) < 0) {\n1108:             SDL_FreeAudioStream(retval);\n1109:             return NULL; /* SDL_BuildAudioCVT should have called SDL_SetError. */\n1110:         }\n1111:     }\n1112: \n1113:     retval->queue = SDL_NewDataQueue(packetlen, (size_t)packetlen * 2);\n1114:     if (!retval->queue) {\n1115:         SDL_FreeAudioStream(retval);\n1116:         return NULL; /* SDL_NewDataQueue should have called SDL_SetError. */\n1117:     }\n1118: \n1119:     return retval;\n1120: }\n1121: \nStacktrace #3:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 680: SDL_DYNAPI_PROC(SDL_AudioStream*,SDL_NewAudioStream,(const SDL_AudioFormat a, const Uint8 b, const int c, const SDL_AudioFormat d, const Uint8 e, const int f),(a,b,c,d,e,f),return)\n 681:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==574700==ERROR: AddressSanitizer: attempting double-free on 0x602000001830 in thread T0:\n    #0 0x7f6a1a72b537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x556a55742153 in CommTarget::deinit() /sourcecode/src/kernel/Communicator.cc:184\n    #2 0x556a55731b49 in CommSchedTarget::deinit() /sourcecode/src/kernel/CommScheduler.cc:89\n    #3 0x556a5572f48c in fuzzloop /dockerin/fuzz_drivers/tf1729655579145upfd.cpp:34\n    #4 0x556a55798049 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x556a5572ec18 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f6a19b04d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f6a19b04e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x556a5572ed64 in _start (/dockerin/fuzz_drivers/tf1729655579145upfd.out+0x9fd64)\n\n0x602000001830 is located 0 bytes inside of 16-byte region [0x602000001830,0x602000001840)\nfreed by thread T0 here:\n    #0 0x7f6a1a72b537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x556a55742153 in CommTarget::deinit() /sourcecode/src/kernel/Communicator.cc:184\n    #2 0x556a55731b49 in CommSchedTarget::deinit() /sourcecode/src/kernel/CommScheduler.cc:89\n    #3 0x556a5572f48c in fuzzloop /dockerin/fuzz_drivers/tf1729655579145upfd.cpp:34\n    #4 0x556a55798049 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\npreviously allocated by thread T0 here:\n    #0 0x7f6a1a72b887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556a557412ff in CommTarget::init(sockaddr const*, unsigned int, int, int) /sourcecode/src/kernel/Communicator.cc:157\n    #2 0x556a55730fe2 in CommSchedTarget::init(sockaddr const*, unsigned int, int, int, unsigned long) /sourcecode/src/kernel/CommScheduler.cc:59\n    #3 0x556a5572f21b in fuzzloop /dockerin/fuzz_drivers/tf1729655579145upfd.cpp:29\n    #4 0x556a55798049 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: double-free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127 in __interceptor_free\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:51:31\n// Signature: CommSchedGroup::add(CommSchedTarget *target)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14CommSchedGroup3addEP15CommSchedTarget\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/CommScheduler.h\"\n\n#include <netinet/in.h> // Include for sockaddr_in and htons\n#include <arpa/inet.h>  // Include for inet_addr\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    CommSchedGroup group;\n    CommSchedTarget target;\n\n    group.init();\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(fuzzUint16(0));\n    addr.sin_addr.s_addr = inet_addr(fuzzString(1));\n\n    target.init((struct sockaddr *)&addr, sizeof(addr), fuzzInt32(2), fuzzInt32(3), fuzzUint32(4));\n\n    group.add(&target);\n\n    group.deinit();\n    target.deinit();\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n 181: void CommTarget::deinit()\n 182: {\n 183: \tpthread_mutex_destroy(&this->mutex);\n 184: \tfree(this->addr);\n 185: }\n 186: \nStacktrace #1:\nFile: /sourcecode/src/kernel/CommScheduler.cc\n  85: void CommSchedTarget::deinit()\n  86: {\n  87: \tpthread_cond_destroy(&this->cond);\n  88: \tpthread_mutex_destroy(&this->mutex);\n  89: \tthis->CommTarget::deinit();\n  90: }\n  91:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4986==ERROR: AddressSanitizer: global-buffer-overflow on address 0x557268e4d358 at pc 0x557268b89fc6 bp 0x7ffefff0cd40 sp 0x7ffefff0cd30\nREAD of size 8 at 0x557268e4d358 thread T0\n    #0 0x557268b89fc5 in http_date2rfc7231 /sourcecode/lib/facil/http/http.c:2200\n    #1 0x557268a7eb4d in fuzzloop /dockerin/fuzz_drivers/tf1730095527706kecl.c:28\n    #2 0x557268bfd649 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x557268a7dab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f46df723d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f46df723e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x557268a7dc04 in _start (/dockerin/fuzz_drivers/tf1730095527706kecl.out+0x1dbc04)\n\n0x557268e4d358 is located 8 bytes to the right of global variable '*.Lubsan_data1368' defined in '/sourcecode/lib/facil/http/http.c' (0x557268e4d340) of size 16\n0x557268e4d358 is located 40 bytes to the left of global variable '*.Lubsan_data1369' defined in '/sourcecode/lib/facil/http/http.c' (0x557268e4d380) of size 16\nSUMMARY: AddressSanitizer: global-buffer-overflow /sourcecode/lib/facil/http/http.c:2200 in http_date2rfc7231\nShadow bytes around the buggy address:\n  0x0aaecd1c1a10: 00 00 00 00 f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9\n  0x0aaecd1c1a20: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n  0x0aaecd1c1a30: 00 00 f9 f9 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n  0x0aaecd1c1a40: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n  0x0aaecd1c1a50: 00 00 f9 f9 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n=>0x0aaecd1c1a60: 00 00 00 00 f9 f9 f9 f9 00 00 f9[f9]f9 f9 f9 f9\n  0x0aaecd1c1a70: 00 00 f9 f9 f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9\n  0x0aaecd1c1a80: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n  0x0aaecd1c1a90: 00 00 00 00 f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9\n  0x0aaecd1c1aa0: 00 00 00 00 f9 f9 f9 f9 00 00 00 00 f9 f9 f9 f9\n  0x0aaecd1c1ab0: 00 00 f9 f9 f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:04:12\n// Signature: http_date2rfc7231(char *target, struct tm *tmbuf)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_date2rfc7231\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/http/http1.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    char target[32];\n    struct tm tmbuf;\n\n    tmbuf.tm_sec = fuzzInt8(0);\n    tmbuf.tm_min = fuzzInt8(1);\n    tmbuf.tm_hour = fuzzInt8(2);\n    tmbuf.tm_mday = fuzzInt8(3);\n    tmbuf.tm_mon = fuzzInt8(4);\n    tmbuf.tm_year = fuzzInt16(5);\n    tmbuf.tm_wday = fuzzInt8(6);\n    tmbuf.tm_yday = fuzzInt16(7);\n    tmbuf.tm_isdst = fuzzInt8(8);\n\n    http_date2rfc7231(target, &tmbuf);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2196: size_t http_date2rfc7231(char *target, struct tm *tmbuf) {\n2197:   /* note: day of month is always 2 digits */\n2198:   char *pos = target;\n2199:   uint16_t tmp;\n2200:   pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n2201:   pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n2202:   pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n2203:   pos[3] = ',';\n2204:   pos[4] = ' ';\n2205:   pos += 5;\n2206:   tmp = tmbuf->tm_mday / 10;\n2207:   pos[0] = '0' + tmp;\n2208:   pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n2209:   pos += 2;\n2210:   *(pos++) = ' ';\n2211:   pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n2212:   pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n2213:   pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n2214:   pos[3] = ' ';\n2215:   pos += 4;\n2216:   // write year.\n2217:   pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n2218:   *(pos++) = ' ';\n2219:   tmp = tmbuf->tm_hour / 10;\n2220:   pos[0] = '0' + tmp;\n2221:   pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n2222:   pos[2] = ':';\n2223:   tmp = tmbuf->tm_min / 10;\n2224:   pos[3] = '0' + tmp;\n2225:   pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n2226:   pos[5] = ':';\n2227:   tmp = tmbuf->tm_sec / 10;\n2228:   pos[6] = '0' + tmp;\n2229:   pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n2230:   pos += 8;\n2231:   pos[0] = ' ';\n2232:   pos[1] = GMT_STR[0];\n2233:   pos[2] = GMT_STR[1];\n2234:   pos[3] = GMT_STR[2];\n2235:   pos[4] = 0;\n2236:   pos += 4;\n2237:   return pos - target;\n2238: }\n2239:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==171==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55e2e8df0b3b at pc 0x55e2e8aab830 bp 0x7ffd37e4ca80 sp 0x7ffd37e4ca70\nREAD of size 1 at 0x55e2e8df0b3b thread T0\n    #0 0x55e2e8aab82f in mustache__load_data /sourcecode/lib/facil/fiobj/mustache_parser.h:812\n    #1 0x55e2e8ab44c4 in mustache_load /sourcecode/lib/facil/fiobj/mustache_parser.h:1193\n    #2 0x55e2e8abe9f7 in fiobj_mustache_new /sourcecode/lib/facil/fiobj/fiobj_mustache.c:46\n    #3 0x55e2e8aa6433 in fuzzloop /sharedockerin/ta1730101612191tajm/test_file.c:22\n    #4 0x55e2e8baf449 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55e2e8aa5a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fe0d9d87d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fe0d9d87e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55e2e8aa5be4 in _start (/sharedockerin/ta1730101612191tajm/clouditera+0x136be4)\n\n0x55e2e8df0b3b is located 23 bytes to the right of global variable 'FIO_LOG_LEVEL' defined in './lib/facil/fio.h:459:27' (0x55e2e8df0b20) of size 4\n0x55e2e8df0b3b is located 37 bytes to the left of global variable 'fio_hash_secret_marker1' defined in './lib/facil/fio.h:2459:31' (0x55e2e8df0b60) of size 1\n  'fio_hash_secret_marker1' is ascii string ''\nSUMMARY: AddressSanitizer: global-buffer-overflow /sourcecode/lib/facil/fiobj/mustache_parser.h:812 in mustache__load_data\nShadow bytes around the buggy address:\n  0x0abcdd1b6110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0abcdd1b6160: 00 00 00 00 04 f9 f9[f9]f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b6170: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 04 f9 f9 f9\n  0x0abcdd1b6180: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b6190: f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b61a0: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 00 00 00 00\n  0x0abcdd1b61b0: 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:01:17\n// Signature: fiobj_mustache_new(mustache_load_args_s args)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_mustache_new\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_mustache.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char *filename = fuzzFilename(0);\n    size_t filename_len = fuzzGetLen(0);\n    char *data = fuzzData(1);\n    size_t data_len = fuzzGetLen(1);\n    mustache_error_en err;\n\n    mustache_s *mustache = fiobj_mustache_new(.filename = filename, .filename_len = filename_len, .data = data, .data_len = data_len, .err = &err);\n    if (mustache) {\n        fiobj_mustache_free(mustache);\n    }\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n 799: static inline ssize_t mustache__load_data(mustache__loader_stack_s *s,\n 800:                                           const char *name, size_t name_len,\n 801:                                           const char *data, size_t data_len) {\n 802:   const size_t old_len = s->data_len;\n 803:   if (old_len + data_len > UINT32_MAX)\n 804:     goto too_long;\n 805:   s->data = realloc(s->data, old_len + data_len +\n 806:                                  mustache__data_segment_length(name_len) + 1);\n 807:   MUSTACHE_ASSERT(s->data,\n 808:                   \"failed to allocate memory for mustache template data\");\n 809:   size_t path_len = name_len;\n 810:   while (path_len) {\n 811:     --path_len;\n 812:     if (name[path_len] == '/' || name[path_len] == '\\\\') {\n 813:       ++path_len;\n 814:       break;\n 815:     }\n 816:   }\n 817:   mustache__data_segment_write(\n 818:       (uint8_t *)s->data + old_len,\n 819:       (mustache__data_segment_s){\n 820:           .filename = name,\n 821:           .filename_len = name_len,\n 822:           .inst_start = s->m->u.read_only.intruction_count,\n 823:           .next =\n 824:               s->data_len + data_len + mustache__data_segment_length(name_len),\n 825:           .path_len = path_len,\n 826:       });\n 827:   if (data) {\n 828:     memcpy(s->data + old_len + mustache__data_segment_length(name_len), data,\n 829:            data_len);\n 830:   }\n 831:   s->data_len += data_len + mustache__data_segment_length(name_len);\n 832:   s->data[s->data_len] = 0;\n 833:   s->m->u.read_only.data_length = s->data_len;\n 834: \n 835:   mustache__instruction_push(\n 836:       s, (mustache__instruction_s){.instruction = MUSTACHE_SECTION_START});\n 837:   /* advance stack frame */\n 838:   ++s->index;\n 839:   if (s->index >= MUSTACHE_NESTING_LIMIT)\n 840:     goto too_long;\n 841:   s->stack[s->index].data_pos =\n 842:       old_len + mustache__data_segment_length(name_len);\n 843:   s->stack[s->index].data_start = old_len;\n 844:   s->stack[s->index].data_end = s->data_len;\n 845:   /* reset delimiters */\n 846:   s->stack[s->index].del_start_len = 2;\n 847:   s->stack[s->index].del_end_len = 2;\n 848:   s->stack[s->index].del_start[0] = s->stack[s->index].del_start[1] = '{';\n 849:   s->stack[s->index].del_start[2] = 0;\n 850:   s->stack[s->index].del_end[0] = s->stack[s->index].del_end[1] = '}';\n 851:   s->stack[s->index].del_end[2] = 0;\n 852:   s->stack[s->index].open_sections = 0;\n 853:   return data_len;\n 854: too_long:\n 855:   *s->err = MUSTACHE_ERR_TOO_DEEP;\n 856:   return -1;\n 857: }\n 858: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n1166: MUSTACHE_FUNC mustache_s *(mustache_load)(mustache_load_args_s args) {\n1167:   mustache_error_en err_if_missing;\n1168:   mustache__loader_stack_s s;\n1169:   uint8_t flag = 0;\n1170: \n1171:   if (!args.err)\n1172:     args.err = &err_if_missing;\n1173:   s.path_capa = 0;\n1174:   s.path = NULL;\n1175:   s.data = NULL;\n1176:   s.data_len = 0;\n1177:   s.i = NULL;\n1178:   s.i_capa = 32;\n1179:   s.index = 0;\n1180:   s.padding = 0;\n1181:   s.m = malloc(sizeof(*s.m) + (sizeof(*s.i) * 32));\n1182:   MUSTACHE_ASSERT(s.m, \"failed to allocate memory for mustache data\");\n1183:   s.m->u.read_only_pt = 0;\n1184:   s.m->u.read_only.data_length = 0;\n1185:   s.m->u.read_only.intruction_count = 0;\n1186:   s.i = MUSTACH2INSTRUCTIONS(s.m);\n1187:   s.err = args.err;\n1188: \n1189:   if (!args.filename_len && args.filename)\n1190:     args.filename_len = strlen(args.filename);\n1191: \n1192:   if (args.data) {\n1193:     if (mustache__load_data(&s, args.filename, args.filename_len, args.data,\n1194:                             args.data_len) == -1) {\n1195:       goto error;\n1196:     }\n1197:   } else {\n1198:     if (mustache__load_file(&s, args.filename, args.filename_len) == -1) {\n1199:       goto error;\n1200:     }\n1201:   }\n1202: \n1203:   /* loop while there are templates to be parsed on the stack */\n1204:   while (s.index) {\n1205:     /* parsing loop */\n1206:     while (s.stack[s.index].data_pos < s.stack[s.index].data_end) {\n1207:       /* stand-alone tag flag, also containes padding length after bit 1 */\n1208:       uint32_t stand_alone = 0;\n1209:       uint32_t stand_alone_pos = 0;\n1210:       /* start parsing at current position */\n1211:       const char *start = s.data + s.stack[s.index].data_pos;\n1212:       /* find the next instruction (beg == beginning) */\n1213:       char *beg = strstr(start, s.stack[s.index].del_start);\n1214:       const char *org_beg = beg;\n1215:       if (!beg || beg >= s.data + s.stack[s.index].data_end) {\n1216:         /* no instructions left, only text */\n1217:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1218:                                         s.stack[s.index].data_end -\n1219:                                             s.stack[s.index].data_pos);\n1220:         s.stack[s.index].data_pos = s.stack[s.index].data_end;\n1221:         continue;\n1222:       }\n1223:       if (beg != start) {\n1224:         /* there's text before the instruction */\n1225:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1226:                                         (uint32_t)(uintptr_t)(beg - start));\n1227:       }\n1228:       /* move beg (reading position) after the delimiter */\n1229:       beg += s.stack[s.index].del_start_len;\n1230:       /* seek the end of the instruction delimiter */\n1231:       char *end = strstr(beg, s.stack[s.index].del_end);\n1232:       if (!end || end >= s.data + s.stack[s.index].data_end) {\n1233:         /* delimiter not closed */\n1234:         *args.err = MUSTACHE_ERR_CLOSURE_MISMATCH;\n1235:         goto error;\n1236:       }\n1237: \n1238:       /* update reading position in the stack */\n1239:       s.stack[s.index].data_pos = (end - s.data) + s.stack[s.index].del_end_len;\n1240: \n1241:       /* Test for stand-alone tags */\n1242:       if (!end[s.stack[s.index].del_end_len] ||\n1243:           end[s.stack[s.index].del_end_len] == '\\n' ||\n1244:           (end[s.stack[s.index].del_end_len] == '\\r' &&\n1245:            end[1 + s.stack[s.index].del_end_len] == '\\n')) {\n1246:         char *pad = beg - (s.stack[s.index].del_start_len + 1);\n1247:         while (pad >= start && (pad[0] == ' ' || pad[0] == '\\t'))\n1248:           --pad;\n1249:         if (pad[0] == '\\n' || pad[0] == 0) {\n1250:           /* Yes, this a stand-alone tag, store padding length + flag  */\n1251:           ++pad;\n1252:           stand_alone_pos = pad - s.data;\n1253:           stand_alone =\n1254:               ((beg - (pad + s.stack[s.index].del_start_len)) << 1) | 1;\n1255:         }\n1256:       }\n1257: \n1258:       /* parse instruction content */\n1259:       flag = 1;\n1260: \n1261:       switch (beg[0]) {\n1262:       case '!':\n1263:         /* comment, do nothing... almost */\n1264:         mustache__stand_alone_adjust(&s, stand_alone);\n1265:         break;\n1266: \n1267:       case '=':\n1268:         /* define new seperators */\n1269:         mustache__stand_alone_adjust(&s, stand_alone);\n1270:         ++beg;\n1271:         --end;\n1272:         if (end[0] != '=') {\n1273:           *args.err = MUSTACHE_ERR_CLOSURE_MISMATCH;\n1274:           goto error;\n1275:         }\n1276:         --end;\n1277:         MUSTACHE_IGNORE_WHITESPACE(beg, 1);\n1278:         MUSTACHE_IGNORE_WHITESPACE(end, -1);\n1279:         ++end;\n1280:         {\n1281:           char *div = beg;\n1282:           while (div < end && !isspace(*div)) {\n1283:             ++div;\n1284:           }\n1285:           if (div == end || div == beg) {\n...skip...\nStacktrace #2:\nFile: /sourcecode/lib/facil/fiobj/fiobj_mustache.c\n  45: mustache_s *fiobj_mustache_new FIO_IGNORE_MACRO(mustache_load_args_s args) {\n  46:   return mustache_load FIO_IGNORE_MACRO(args);\n  47: }\n  48:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1963==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5633c3412b24 at pc 0x7f0d943c3397 bp 0x7fff98081c70 sp 0x7fff98081418\nREAD of size 691 at 0x5633c3412b24 thread T0\n    #0 0x7f0d943c3396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x5633c30d00d3 in mustache__load_file /sourcecode/lib/facil/fiobj/mustache_parser.h:899\n    #2 0x5633c30d64e5 in mustache_load /sourcecode/lib/facil/fiobj/mustache_parser.h:1198\n    #3 0x5633c30e08e8 in fiobj_mustache_load /sourcecode/lib/facil/fiobj/fiobj_mustache.c:32\n    #4 0x5633c30c83db in fuzzloop /dockerin/fuzz_drivers/tf1729823101556tsvr.c:19\n    #5 0x5633c31d13d9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x5633c30c7a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f0d93a64d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f0d93a64e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x5633c30c7be4 in _start (/dockerin/fuzz_drivers/tf1729823101556tsvr.out+0x136be4)\n\n0x5633c3412b24 is located 0 bytes to the right of global variable 'FIO_LOG_LEVEL' defined in './lib/facil/fio.h:459:27' (0x5633c3412b20) of size 4\n0x5633c3412b24 is located 60 bytes to the left of global variable 'fio_hash_secret_marker1' defined in './lib/facil/fio.h:2459:31' (0x5633c3412b60) of size 1\n  'fio_hash_secret_marker1' is ascii string ''\nSUMMARY: AddressSanitizer: global-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0ac6f867a510: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0ac6f867a520: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0ac6f867a530: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0ac6f867a540: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0ac6f867a550: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0ac6f867a560: 00 00 00 00[04]f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0ac6f867a570: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 04 f9 f9 f9\n  0x0ac6f867a580: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0ac6f867a590: f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0ac6f867a5a0: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 00 00 00 00\n  0x0ac6f867a5b0: 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:24:44\n// Signature: fiobj_mustache_load(fio_str_info_s filename)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_mustache_load\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_mustache.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char *filename = fuzzFilename(0);\n    int filename_len = fuzzGetLen(0);\n    fio_str_info_s filename_info = {.data = filename, .len = filename_len};\n    mustache_s *mustache = fiobj_mustache_load(filename_info);\n    if (mustache) {\n        fiobj_mustache_free(mustache);\n    }\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n 859: static inline ssize_t mustache__load_file(mustache__loader_stack_s *s,\n 860:                                           const char *name, size_t name_len) {\n 861:   struct stat f_data;\n 862:   uint16_t i = s->index;\n 863:   uint32_t old_path_len = 0;\n 864:   if (!name_len) {\n 865:     goto name_missing_error;\n 866:   }\n 867:   if (name_len >= 8192)\n 868:     goto name_length_error;\n 869:   /* test file names by walking the stack backwards and matching paths */\n 870:   do {\n 871:     mustache__data_segment_s seg;\n 872:     if (s->data)\n 873:       seg = mustache__data_segment_read((uint8_t *)s->data +\n 874:                                         s->stack[i].data_start);\n 875:     else\n 876:       seg = (mustache__data_segment_s){\n 877:           .path_len = 0,\n 878:       };\n 879:     /* did we test this path for the file? */\n 880:     if (old_path_len && (old_path_len == seg.path_len &&\n 881:                          !memcmp(s->path, seg.filename, old_path_len))) {\n 882:       continue;\n 883:     }\n 884:     old_path_len = seg.path_len;\n 885:     /* make sure s->path capacity is enough. */\n 886:     if (s->path_capa < seg.path_len + name_len + 10) {\n 887:       s->path = realloc(s->path, seg.path_len + name_len + 10);\n 888:       MUSTACHE_ASSERT(s->path,\n...skip...\n 869:   /* test file names by walking the stack backwards and matching paths */\n 870:   do {\n 871:     mustache__data_segment_s seg;\n 872:     if (s->data)\n 873:       seg = mustache__data_segment_read((uint8_t *)s->data +\n 874:                                         s->stack[i].data_start);\n 875:     else\n 876:       seg = (mustache__data_segment_s){\n 877:           .path_len = 0,\n 878:       };\n 879:     /* did we test this path for the file? */\n 880:     if (old_path_len && (old_path_len == seg.path_len &&\n 881:                          !memcmp(s->path, seg.filename, old_path_len))) {\n 882:       continue;\n 883:     }\n 884:     old_path_len = seg.path_len;\n 885:     /* make sure s->path capacity is enough. */\n 886:     if (s->path_capa < seg.path_len + name_len + 10) {\n 887:       s->path = realloc(s->path, seg.path_len + name_len + 10);\n 888:       MUSTACHE_ASSERT(s->path,\n 889:                       \"failed to allocate memory for mustache template data\");\n 890:       s->path_capa = seg.path_len + name_len + 10;\n 891:     }\n 892:     /* if testing local folder, there's no need to keep looping */\n 893:     if (!seg.path_len) {\n 894:       i = 1;\n 895:     } else {\n 896:       memcpy(s->path, seg.filename, seg.path_len);\n 897:     }\n 898:     /* copy name to path */\n 899:     memcpy(s->path + seg.path_len, name, name_len);\n 900:     s->path[name_len + seg.path_len] = 0;\n 901:     /* test if file exists */\n 902:     if (!stat(s->path, &f_data) && S_ISREG(f_data.st_mode)) {\n 903:       old_path_len = name_len + seg.path_len;\n 904:       goto file_found;\n 905:     }\n 906:     /* add default extension  */\n 907:     memcpy(s->path + seg.path_len + name_len, \".mustache\", 9);\n 908:     s->path[name_len + seg.path_len + 9] = 0;\n 909:     /* test if new filename file exists */\n 910:     if (!stat(s->path, &f_data) && S_ISREG(f_data.st_mode)) {\n 911:       old_path_len = name_len + seg.path_len + 9;\n 912:       goto file_found;\n 913:     }\n 914:   } while (--i);\n 915: \n 916:   /* test if the file is \"virtual\" (only true for the first template loaded) */\n 917:   if (s->data) {\n 918:     mustache__data_segment_s seg =\n 919:         mustache__data_segment_read((uint8_t *)s->data);\n 920:     if (seg.filename_len == name_len && !memcmp(seg.filename, name, name_len)) {\n 921:       /* this name points to the original (root) template, and it's virtual */\n 922:       if (mustache__instruction_push(\n 923:               s, (mustache__instruction_s){\n 924:                      .instruction = MUSTACHE_SECTION_GOTO,\n 925:                      .data =\n 926:                          {\n 927:                              .len = 0,\n 928:                              .end = s->m->u.read_only.intruction_count,\n...skip...\n 968:     goto unknown_error;\n 969:   int fd = open(s->path, O_RDONLY);\n 970:   if (fd == -1)\n 971:     goto file_err;\n 972:   if (pread(fd, s->data + s->data_len - f_data.st_size, f_data.st_size, 0) !=\n 973:       f_data.st_size)\n 974:     goto file_err;\n 975:   close(fd);\n 976:   return f_data.st_size;\n 977: \n 978: name_missing_error:\n 979:   *s->err = MUSTACHE_ERR_FILE_NAME_TOO_SHORT;\n 980:   return -1;\n 981: \n 982: name_length_error:\n 983:   *s->err = MUSTACHE_ERR_FILE_NAME_TOO_LONG;\n 984:   return -1;\n 985: \n 986: file_too_big:\n 987:   *s->err = MUSTACHE_ERR_FILE_TOO_BIG;\n 988:   return -1;\n 989: \n 990: file_err:\n 991:   *s->err = MUSTACHE_ERR_UNKNOWN;\n 992:   return -1;\n 993: \n 994: unknown_error:\n 995:   return -1;\n 996: }\n 997: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n1166: MUSTACHE_FUNC mustache_s *(mustache_load)(mustache_load_args_s args) {\n1167:   mustache_error_en err_if_missing;\n1168:   mustache__loader_stack_s s;\n1169:   uint8_t flag = 0;\n1170: \n1171:   if (!args.err)\n1172:     args.err = &err_if_missing;\n1173:   s.path_capa = 0;\n1174:   s.path = NULL;\n1175:   s.data = NULL;\n1176:   s.data_len = 0;\n1177:   s.i = NULL;\n1178:   s.i_capa = 32;\n1179:   s.index = 0;\n1180:   s.padding = 0;\n1181:   s.m = malloc(sizeof(*s.m) + (sizeof(*s.i) * 32));\n1182:   MUSTACHE_ASSERT(s.m, \"failed to allocate memory for mustache data\");\n1183:   s.m->u.read_only_pt = 0;\n1184:   s.m->u.read_only.data_length = 0;\n1185:   s.m->u.read_only.intruction_count = 0;\n1186:   s.i = MUSTACH2INSTRUCTIONS(s.m);\n1187:   s.err = args.err;\n1188: \n1189:   if (!args.filename_len && args.filename)\n1190:     args.filename_len = strlen(args.filename);\n1191: \n1192:   if (args.data) {\n1193:     if (mustache__load_data(&s, args.filename, args.filename_len, args.data,\n1194:                             args.data_len) == -1) {\n1195:       goto error;\n...skip...\n1168:   mustache__loader_stack_s s;\n1169:   uint8_t flag = 0;\n1170: \n1171:   if (!args.err)\n1172:     args.err = &err_if_missing;\n1173:   s.path_capa = 0;\n1174:   s.path = NULL;\n1175:   s.data = NULL;\n1176:   s.data_len = 0;\n1177:   s.i = NULL;\n1178:   s.i_capa = 32;\n1179:   s.index = 0;\n1180:   s.padding = 0;\n1181:   s.m = malloc(sizeof(*s.m) + (sizeof(*s.i) * 32));\n1182:   MUSTACHE_ASSERT(s.m, \"failed to allocate memory for mustache data\");\n1183:   s.m->u.read_only_pt = 0;\n1184:   s.m->u.read_only.data_length = 0;\n1185:   s.m->u.read_only.intruction_count = 0;\n1186:   s.i = MUSTACH2INSTRUCTIONS(s.m);\n1187:   s.err = args.err;\n1188: \n1189:   if (!args.filename_len && args.filename)\n1190:     args.filename_len = strlen(args.filename);\n1191: \n1192:   if (args.data) {\n1193:     if (mustache__load_data(&s, args.filename, args.filename_len, args.data,\n1194:                             args.data_len) == -1) {\n1195:       goto error;\n1196:     }\n1197:   } else {\n1198:     if (mustache__load_file(&s, args.filename, args.filename_len) == -1) {\n1199:       goto error;\n1200:     }\n1201:   }\n1202: \n1203:   /* loop while there are templates to be parsed on the stack */\n1204:   while (s.index) {\n1205:     /* parsing loop */\n1206:     while (s.stack[s.index].data_pos < s.stack[s.index].data_end) {\n1207:       /* stand-alone tag flag, also containes padding length after bit 1 */\n1208:       uint32_t stand_alone = 0;\n1209:       uint32_t stand_alone_pos = 0;\n1210:       /* start parsing at current position */\n1211:       const char *start = s.data + s.stack[s.index].data_pos;\n1212:       /* find the next instruction (beg == beginning) */\n1213:       char *beg = strstr(start, s.stack[s.index].del_start);\n1214:       const char *org_beg = beg;\n1215:       if (!beg || beg >= s.data + s.stack[s.index].data_end) {\n1216:         /* no instructions left, only text */\n1217:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1218:                                         s.stack[s.index].data_end -\n1219:                                             s.stack[s.index].data_pos);\n1220:         s.stack[s.index].data_pos = s.stack[s.index].data_end;\n1221:         continue;\n1222:       }\n1223:       if (beg != start) {\n1224:         /* there's text before the instruction */\n1225:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1226:                                         (uint32_t)(uintptr_t)(beg - start));\n1227:       }\n...skip...\n1508:     /* complete padding switch*/\n1509:     if (flag) {\n1510:       mustache__instruction_push(&s, (mustache__instruction_s){\n1511:                                          .instruction = MUSTACHE_PADDING_WRITE,\n1512:                                      });\n1513:       flag = 0;\n1514:     }\n1515:     /* pop stack */\n1516:     --s.index;\n1517:   }\n1518: \n1519:   s.m = realloc(s.m, sizeof(*s.m) +\n1520:                          (sizeof(*s.i) * s.m->u.read_only.intruction_count) +\n1521:                          s.data_len);\n1522:   MUSTACHE_ASSERT(s.m,\n1523:                   \"failed to allocate memory for consolidated mustache data\");\n1524:   memcpy(MUSTACH2DATA(s.m), s.data, s.data_len);\n1525:   free(s.data);\n1526:   free(s.path);\n1527: \n1528:   *args.err = MUSTACHE_OK;\n1529:   return s.m;\n1530: \n1531: error:\n1532:   free(s.data);\n1533:   free(s.path);\n1534:   free(s.m);\n1535:   return NULL;\n1536: }\n1537: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fiobj/fiobj_mustache.c\n  31: mustache_s *fiobj_mustache_load(fio_str_info_s filename) {\n  32:   return mustache_load(.filename = filename.data, .filename_len = filename.len);\n  33: }\n  34:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==171==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55e2e8df0b24 at pc 0x7fe0da6e6397 bp 0x7ffd37e4c980 sp 0x7ffd37e4c128\nREAD of size 348 at 0x55e2e8df0b24 thread T0\n    #0 0x7fe0da6e6396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x55e2e8aa8d5d in mustache__data_segment_write /sourcecode/lib/facil/fiobj/mustache_parser.h:672\n    #2 0x55e2e8aabb26 in mustache__load_data /sourcecode/lib/facil/fiobj/mustache_parser.h:817\n    #3 0x55e2e8ab44c4 in mustache_load /sourcecode/lib/facil/fiobj/mustache_parser.h:1193\n    #4 0x55e2e8abe9f7 in fiobj_mustache_new /sourcecode/lib/facil/fiobj/fiobj_mustache.c:46\n    #5 0x55e2e8aa6433 in fuzzloop /sharedockerin/ta1730101612191tajm/test_file.c:22\n    #6 0x55e2e8baf449 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55e2e8aa5a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7fe0d9d87d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7fe0d9d87e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55e2e8aa5be4 in _start (/sharedockerin/ta1730101612191tajm/clouditera+0x136be4)\n\n0x55e2e8df0b24 is located 0 bytes to the right of global variable 'FIO_LOG_LEVEL' defined in './lib/facil/fio.h:459:27' (0x55e2e8df0b20) of size 4\n0x55e2e8df0b24 is located 60 bytes to the left of global variable 'fio_hash_secret_marker1' defined in './lib/facil/fio.h:2459:31' (0x55e2e8df0b60) of size 1\n  'fio_hash_secret_marker1' is ascii string ''\nSUMMARY: AddressSanitizer: global-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0abcdd1b6110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0abcdd1b6150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0abcdd1b6160: 00 00 00 00[04]f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b6170: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 04 f9 f9 f9\n  0x0abcdd1b6180: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b6190: f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9\n  0x0abcdd1b61a0: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9 00 00 00 00\n  0x0abcdd1b61b0: 01 f9 f9 f9 f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:01:17\n// Signature: fiobj_mustache_new(mustache_load_args_s args)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_mustache_new\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_mustache.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char *filename = fuzzFilename(0);\n    size_t filename_len = fuzzGetLen(0);\n    char *data = fuzzData(1);\n    size_t data_len = fuzzGetLen(1);\n    mustache_error_en err;\n\n    mustache_s *mustache = fiobj_mustache_new(.filename = filename, .filename_len = filename_len, .data = data, .data_len = data_len, .err = &err);\n    if (mustache) {\n        fiobj_mustache_free(mustache);\n    }\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n 657: static inline size_t\n 658: mustache__data_segment_write(uint8_t *dest, mustache__data_segment_s data) {\n 659:   dest[0] = 0xFF & data.inst_start;\n 660:   dest[1] = 0xFF & (data.inst_start >> 1);\n 661:   dest[2] = 0xFF & (data.inst_start >> 2);\n 662:   dest[3] = 0xFF & (data.inst_start >> 3);\n 663:   dest[4] = 0xFF & data.next;\n 664:   dest[5] = 0xFF & (data.next >> 1);\n 665:   dest[6] = 0xFF & (data.next >> 2);\n 666:   dest[7] = 0xFF & (data.next >> 3);\n 667:   dest[8] = 0xFF & data.filename_len;\n 668:   dest[9] = 0xFF & (data.filename_len >> 1);\n 669:   dest[10] = 0xFF & data.path_len;\n 670:   dest[11] = 0xFF & (data.path_len >> 1);\n 671:   if (data.filename_len)\n 672:     memcpy(dest + 12, data.filename, data.filename_len);\n 673:   (dest + 12)[data.filename_len] = 0;\n 674:   return 13 + data.filename_len;\n 675: }\n 676: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n 799: static inline ssize_t mustache__load_data(mustache__loader_stack_s *s,\n 800:                                           const char *name, size_t name_len,\n 801:                                           const char *data, size_t data_len) {\n 802:   const size_t old_len = s->data_len;\n 803:   if (old_len + data_len > UINT32_MAX)\n 804:     goto too_long;\n 805:   s->data = realloc(s->data, old_len + data_len +\n 806:                                  mustache__data_segment_length(name_len) + 1);\n 807:   MUSTACHE_ASSERT(s->data,\n 808:                   \"failed to allocate memory for mustache template data\");\n 809:   size_t path_len = name_len;\n 810:   while (path_len) {\n 811:     --path_len;\n 812:     if (name[path_len] == '/' || name[path_len] == '\\\\') {\n 813:       ++path_len;\n 814:       break;\n 815:     }\n 816:   }\n 817:   mustache__data_segment_write(\n 818:       (uint8_t *)s->data + old_len,\n 819:       (mustache__data_segment_s){\n 820:           .filename = name,\n 821:           .filename_len = name_len,\n 822:           .inst_start = s->m->u.read_only.intruction_count,\n 823:           .next =\n 824:               s->data_len + data_len + mustache__data_segment_length(name_len),\n 825:           .path_len = path_len,\n 826:       });\n 827:   if (data) {\n 828:     memcpy(s->data + old_len + mustache__data_segment_length(name_len), data,\n 829:            data_len);\n 830:   }\n 831:   s->data_len += data_len + mustache__data_segment_length(name_len);\n 832:   s->data[s->data_len] = 0;\n 833:   s->m->u.read_only.data_length = s->data_len;\n 834: \n 835:   mustache__instruction_push(\n 836:       s, (mustache__instruction_s){.instruction = MUSTACHE_SECTION_START});\n 837:   /* advance stack frame */\n 838:   ++s->index;\n 839:   if (s->index >= MUSTACHE_NESTING_LIMIT)\n 840:     goto too_long;\n 841:   s->stack[s->index].data_pos =\n 842:       old_len + mustache__data_segment_length(name_len);\n 843:   s->stack[s->index].data_start = old_len;\n 844:   s->stack[s->index].data_end = s->data_len;\n 845:   /* reset delimiters */\n 846:   s->stack[s->index].del_start_len = 2;\n 847:   s->stack[s->index].del_end_len = 2;\n 848:   s->stack[s->index].del_start[0] = s->stack[s->index].del_start[1] = '{';\n 849:   s->stack[s->index].del_start[2] = 0;\n 850:   s->stack[s->index].del_end[0] = s->stack[s->index].del_end[1] = '}';\n 851:   s->stack[s->index].del_end[2] = 0;\n 852:   s->stack[s->index].open_sections = 0;\n 853:   return data_len;\n 854: too_long:\n 855:   *s->err = MUSTACHE_ERR_TOO_DEEP;\n 856:   return -1;\n 857: }\n 858: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fiobj/mustache_parser.h\n1166: MUSTACHE_FUNC mustache_s *(mustache_load)(mustache_load_args_s args) {\n1167:   mustache_error_en err_if_missing;\n1168:   mustache__loader_stack_s s;\n1169:   uint8_t flag = 0;\n1170: \n1171:   if (!args.err)\n1172:     args.err = &err_if_missing;\n1173:   s.path_capa = 0;\n1174:   s.path = NULL;\n1175:   s.data = NULL;\n1176:   s.data_len = 0;\n1177:   s.i = NULL;\n1178:   s.i_capa = 32;\n1179:   s.index = 0;\n1180:   s.padding = 0;\n1181:   s.m = malloc(sizeof(*s.m) + (sizeof(*s.i) * 32));\n1182:   MUSTACHE_ASSERT(s.m, \"failed to allocate memory for mustache data\");\n1183:   s.m->u.read_only_pt = 0;\n1184:   s.m->u.read_only.data_length = 0;\n1185:   s.m->u.read_only.intruction_count = 0;\n1186:   s.i = MUSTACH2INSTRUCTIONS(s.m);\n1187:   s.err = args.err;\n1188: \n1189:   if (!args.filename_len && args.filename)\n1190:     args.filename_len = strlen(args.filename);\n1191: \n1192:   if (args.data) {\n1193:     if (mustache__load_data(&s, args.filename, args.filename_len, args.data,\n1194:                             args.data_len) == -1) {\n1195:       goto error;\n1196:     }\n1197:   } else {\n1198:     if (mustache__load_file(&s, args.filename, args.filename_len) == -1) {\n1199:       goto error;\n1200:     }\n1201:   }\n1202: \n1203:   /* loop while there are templates to be parsed on the stack */\n1204:   while (s.index) {\n1205:     /* parsing loop */\n1206:     while (s.stack[s.index].data_pos < s.stack[s.index].data_end) {\n1207:       /* stand-alone tag flag, also containes padding length after bit 1 */\n1208:       uint32_t stand_alone = 0;\n1209:       uint32_t stand_alone_pos = 0;\n1210:       /* start parsing at current position */\n1211:       const char *start = s.data + s.stack[s.index].data_pos;\n1212:       /* find the next instruction (beg == beginning) */\n1213:       char *beg = strstr(start, s.stack[s.index].del_start);\n1214:       const char *org_beg = beg;\n1215:       if (!beg || beg >= s.data + s.stack[s.index].data_end) {\n1216:         /* no instructions left, only text */\n1217:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1218:                                         s.stack[s.index].data_end -\n1219:                                             s.stack[s.index].data_pos);\n1220:         s.stack[s.index].data_pos = s.stack[s.index].data_end;\n1221:         continue;\n1222:       }\n1223:       if (beg != start) {\n1224:         /* there's text before the instruction */\n1225:         mustache__push_text_instruction(&s, s.stack[s.index].data_pos,\n1226:                                         (uint32_t)(uintptr_t)(beg - start));\n1227:       }\n1228:       /* move beg (reading position) after the delimiter */\n1229:       beg += s.stack[s.index].del_start_len;\n1230:       /* seek the end of the instruction delimiter */\n1231:       char *end = strstr(beg, s.stack[s.index].del_end);\n1232:       if (!end || end >= s.data + s.stack[s.index].data_end) {\n1233:         /* delimiter not closed */\n1234:         *args.err = MUSTACHE_ERR_CLOSURE_MISMATCH;\n1235:         goto error;\n1236:       }\n1237: \n1238:       /* update reading position in the stack */\n1239:       s.stack[s.index].data_pos = (end - s.data) + s.stack[s.index].del_end_len;\n1240: \n1241:       /* Test for stand-alone tags */\n1242:       if (!end[s.stack[s.index].del_end_len] ||\n1243:           end[s.stack[s.index].del_end_len] == '\\n' ||\n1244:           (end[s.stack[s.index].del_end_len] == '\\r' &&\n1245:            end[1 + s.stack[s.index].del_end_len] == '\\n')) {\n1246:         char *pad = beg - (s.stack[s.index].del_start_len + 1);\n1247:         while (pad >= start && (pad[0] == ' ' || pad[0] == '\\t'))\n1248:           --pad;\n1249:         if (pad[0] == '\\n' || pad[0] == 0) {\n1250:           /* Yes, this a stand-alone tag, store padding length + flag  */\n1251:           ++pad;\n1252:           stand_alone_pos = pad - s.data;\n1253:           stand_alone =\n1254:               ((beg - (pad + s.stack[s.index].del_start_len)) << 1) | 1;\n1255:         }\n1256:       }\n1257: \n1258:       /* parse instruction content */\n1259:       flag = 1;\n1260: \n1261:       switch (beg[0]) {\n1262:       case '!':\n1263:         /* comment, do nothing... almost */\n1264:         mustache__stand_alone_adjust(&s, stand_alone);\n1265:         break;\n1266: \n1267:       case '=':\n1268:         /* define new seperators */\n1269:         mustache__stand_alone_adjust(&s, stand_alone);\n1270:         ++beg;\n1271:         --end;\n1272:         if (end[0] != '=') {\n1273:           *args.err = MUSTACHE_ERR_CLOSURE_MISMATCH;\n1274:           goto error;\n1275:         }\n1276:         --end;\n1277:         MUSTACHE_IGNORE_WHITESPACE(beg, 1);\n1278:         MUSTACHE_IGNORE_WHITESPACE(end, -1);\n1279:         ++end;\n1280:         {\n1281:           char *div = beg;\n1282:           while (div < end && !isspace(*div)) {\n1283:             ++div;\n1284:           }\n1285:           if (div == end || div == beg) {\n...skip...\nStacktrace #3:\nFile: /sourcecode/lib/facil/fiobj/fiobj_mustache.c\n  45: mustache_s *fiobj_mustache_new FIO_IGNORE_MACRO(mustache_load_args_s args) {\n  46:   return mustache_load FIO_IGNORE_MACRO(args);\n  47: }\n  48:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==66603==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55e7f999be01 at pc 0x55e7f961d209 bp 0x7ffeca6d0f70 sp 0x7ffeca6d0f60\nREAD of size 1 at 0x55e7f999be01 thread T0\n    #0 0x55e7f961d208 in SDL_ultoa_REAL /sourcecode/src/stdlib/SDL_string.c:820\n    #1 0x55e7f8db4fec in SDL_ultoa_DEFAULT /sourcecode/src/dynapi/SDL_dynapi_procs.h:441\n    #2 0x55e7f8dc2a39 in SDL_ultoa /sourcecode/src/dynapi/SDL_dynapi_procs.h:441\n    #3 0x55e7f8dafa29 in fuzzloop /dockerin/fuzz_drivers/tf1728900807599rhea.c:27\n    #4 0x55e7f966b239 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55e7f8daf7c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f1f05187d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f1f05187e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55e7f8daf914 in _start (/dockerin/fuzz_drivers/tf1728900807599rhea.out+0xc77914)\n\n0x55e7f999be01 is located 25 bytes to the right of global variable 'VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6550:39' (0x55e7f999bde0) of size 8\n0x55e7f999be01 is located 31 bytes to the left of global variable 'VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6551:39' (0x55e7f999be20) of size 8\nSUMMARY: AddressSanitizer: global-buffer-overflow /sourcecode/src/stdlib/SDL_string.c:820 in SDL_ultoa_REAL\nShadow bytes around the buggy address:\n  0x0abd7f32b770: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b780: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b790: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b7a0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b7b0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n=>0x0abd7f32b7c0:[f9]f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b7d0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b7e0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b7f0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b800: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0abd7f32b810: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/dynapi -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_stdinc.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_stdinc.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_ultoa\n// Sign: SDL_ultoa(unsigned long a, char *b, int c)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"SDL_config.h\" //extract\n#include \"SDL_dynapi.h\" //extract\n#include \"SDL.h\" //extract\n#include \"SDL_syswm.h\" //extract\n#include \"SDL_vulkan.h\" //extract\n#include \"build/include/SDL2/SDL_stdinc.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long a = (unsigned long)fuzzUint64(0);\n    char * b = fuzzString(1);\n    int c = fuzzInt32(2);\n    char * ret = SDL_ultoa(a, b, c);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_string.c\n 811: char *SDL_ultoa(unsigned long value, char *string, int radix)\n 812: {\n 813: #if defined(HAVE__ULTOA)\n 814:     return _ultoa(value, string, radix);\n 815: #else\n 816:     char *bufp = string;\n 817: \n 818:     if (value) {\n 819:         while (value > 0) {\n 820:             *bufp++ = ntoa_table[value % radix];\n 821:             value /= radix;\n 822:         }\n 823:     } else {\n 824:         *bufp++ = '0';\n 825:     }\n 826:     *bufp = '\\0';\n 827: \n 828:     /* The numbers went into the string backwards. :) */\n 829:     SDL_strrev(string);\n 830: \n 831:     return string;\n 832: #endif /* HAVE__ULTOA */\n 833: }\n 834: \nStacktrace #1:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 441: SDL_DYNAPI_PROC(char*,SDL_ultoa,(unsigned long a, char *b, int c),(a,b,c),return)\n 442: \nStacktrace #2:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 441: SDL_DYNAPI_PROC(char*,SDL_ultoa,(unsigned long a, char *b, int c),(a,b,c),return)\n 442:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==28865==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55be2957f084 at pc 0x55be28c9a16e bp 0x7ffdb02e1f10 sp 0x7ffdb02e1f00\nREAD of size 1 at 0x55be2957f084 thread T0\n    #0 0x55be28c9a16d in SDL_ultoa_REAL /sourcecode/src/stdlib/SDL_string.c:820\n    #1 0x55be28c988e9 in fuzzloop /dockerin/fuzz_drivers/tf1728900807926xwvk.c:22\n    #2 0x55be2950ede9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55be28c98688 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fe8176a9d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fe8176a9e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55be28c987d4 in _start (/dockerin/fuzz_drivers/tf1728900807926xwvk.out+0xc2b7d4)\n\n0x55be2957f084 is located 28 bytes to the right of global variable 'VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6738:39' (0x55be2957f060) of size 8\n0x55be2957f084 is located 28 bytes to the left of global variable 'VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6739:39' (0x55be2957f0a0) of size 8\nSUMMARY: AddressSanitizer: global-buffer-overflow /sourcecode/src/stdlib/SDL_string.c:820 in SDL_ultoa_REAL\nShadow bytes around the buggy address:\n  0x0ab8452a7dc0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7dd0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7de0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7df0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e00: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n=>0x0ab8452a7e10:[f9]f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e20: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e30: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e40: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e50: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab8452a7e60: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/stdlib -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_ultoa_REAL\n// Sign: SDL_ultoa_REAL(unsigned long value, char *string, int radix)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../SDL_internal.h\" //extract\n#include \"SDL_stdinc.h\" //extract\n#include \"SDL_vacopy.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long value = (unsigned long)fuzzUint64(0);\n    char * string = fuzzString(1);\n    int radix = fuzzInt32(2);\n    char * ret = SDL_ultoa_REAL(value, string, radix);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_string.c\n 811: char *SDL_ultoa(unsigned long value, char *string, int radix)\n 812: {\n 813: #if defined(HAVE__ULTOA)\n 814:     return _ultoa(value, string, radix);\n 815: #else\n 816:     char *bufp = string;\n 817: \n 818:     if (value) {\n 819:         while (value > 0) {\n 820:             *bufp++ = ntoa_table[value % radix];\n 821:             value /= radix;\n 822:         }\n 823:     } else {\n 824:         *bufp++ = '0';\n 825:     }\n 826:     *bufp = '\\0';\n 827: \n 828:     /* The numbers went into the string backwards. :) */\n 829:     SDL_strrev(string);\n 830: \n 831:     return string;\n 832: #endif /* HAVE__ULTOA */\n 833: }\n 834:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==42470==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55ca128942cf at pc 0x55ca11fb15bf bp 0x7ffe86e056f0 sp 0x7ffe86e056e0\nREAD of size 1 at 0x55ca128942cf thread T0\n    #0 0x55ca11fb15be in SDL_ulltoa_REAL /sourcecode/src/stdlib/SDL_string.c:862\n    #1 0x55ca11fb1421 in SDL_lltoa_REAL /sourcecode/src/stdlib/SDL_string.c:846\n    #2 0x55ca11faf8e9 in fuzzloop /dockerin/fuzz_drivers/tf1728900807112kenm.c:22\n    #3 0x55ca12825de9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55ca11faf688 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f0acc153d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f0acc153e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55ca11faf7d4 in _start (/dockerin/fuzz_drivers/tf1728900807112kenm.out+0xc2b7d4)\n\n0x55ca128942cf is located 39 bytes to the right of global variable 'VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6589:39' (0x55ca128942a0) of size 8\n0x55ca128942cf is located 17 bytes to the left of global variable 'VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV' defined in '/sourcecode/src/events/../video/./khronos/vulkan/vulkan_core.h:6590:39' (0x55ca128942e0) of size 8\nSUMMARY: AddressSanitizer: global-buffer-overflow /sourcecode/src/stdlib/SDL_string.c:862 in SDL_ulltoa_REAL\nShadow bytes around the buggy address:\n  0x0ab9c250a800: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a810: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a820: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a830: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a840: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n=>0x0ab9c250a850: f9 f9 f9 f9 00 f9 f9 f9 f9[f9]f9 f9 00 f9 f9 f9\n  0x0ab9c250a860: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a870: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a880: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a890: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\n  0x0ab9c250a8a0: f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/stdlib -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_lltoa_REAL\n// Sign: SDL_lltoa_REAL(Sint64 value, char *string, int radix)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../SDL_internal.h\" //extract\n#include \"SDL_stdinc.h\" //extract\n#include \"SDL_vacopy.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    long value = (long)fuzzInt64(0);\n    char * string = fuzzString(1);\n    int radix = fuzzInt32(2);\n    char * ret = SDL_lltoa_REAL(value, string, radix);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_string.c\n 853: char *SDL_ulltoa(Uint64 value, char *string, int radix)\n 854: {\n 855: #if defined(HAVE__UI64TOA)\n 856:     return _ui64toa(value, string, radix);\n 857: #else\n 858:     char *bufp = string;\n 859: \n 860:     if (value) {\n 861:         while (value > 0) {\n 862:             *bufp++ = ntoa_table[value % radix];\n 863:             value /= radix;\n 864:         }\n 865:     } else {\n 866:         *bufp++ = '0';\n 867:     }\n 868:     *bufp = '\\0';\n 869: \n 870:     /* The numbers went into the string backwards. :) */\n 871:     SDL_strrev(string);\n 872: \n 873:     return string;\n 874: #endif /* HAVE__UI64TOA */\n 875: }\n 876: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_string.c\n 835: char *SDL_lltoa(Sint64 value, char *string, int radix)\n 836: {\n 837: #if defined(HAVE__I64TOA)\n 838:     return _i64toa(value, string, radix);\n 839: #else\n 840:     char *bufp = string;\n 841: \n 842:     if (value < 0) {\n 843:         *bufp++ = '-';\n 844:         SDL_ulltoa(-value, bufp, radix);\n 845:     } else {\n 846:         SDL_ulltoa(value, bufp, radix);\n 847:     }\n 848: \n 849:     return string;\n 850: #endif /* HAVE__I64TOA */\n 851: }\n 852:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==634411==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x564b8554478b bp 0x7ffe7b542300 sp 0x7ffe7b5422f0\nWRITE of size 8 at 0x602000000120 thread T0\n    #0 0x564b8554478a in SubTask::set_pointer(void*) /sourcecode/_include/workflow/SubTask.h:39\n    #1 0x564b8554c589 in SeriesWork::push_back(SubTask*) /sourcecode/src/factory/Workflow.cc:103\n    #2 0x564b85542833 in WFGraphTask::create_graph_node(SubTask*) /sourcecode/src/factory/WFGraphTask.cc:52\n    #3 0x564b8553baa9 in fuzzloop /dockerin/fuzz_drivers/tf1729655933303gguj.cpp:27\n    #4 0x564b8555e1a9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x564b8553b5c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fbe71043d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fbe71043e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x564b8553b714 in _start (/dockerin/fuzz_drivers/tf1729655933303gguj.out+0x43714)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fbe71c6a887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x564b8555e3bc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/_include/workflow/SubTask.h:39 in SubTask::set_pointer(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:56:53\n// Signature: WFGraphTask::create_graph_node(SubTask *task)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN11WFGraphTask17create_graph_nodeEP7SubTask\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/WFGraphTask.h\"\n#include <memory> // Include for std::unique_ptr\n\n// Custom deleter for WFGraphTask that does not call the destructor\nstruct WFGraphTaskDeleter {\n    void operator()(WFGraphTask* ptr) const {\n        // Do nothing to avoid calling the protected destructor\n        (void)ptr;\n    }\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    auto task = std::unique_ptr<WFGraphTask, WFGraphTaskDeleter>(new WFGraphTask([](WFGraphTask *task) {}));\n    SubTask *subtask = (SubTask *)fuzzData(0);\n    task->create_graph_node(subtask);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/_include/workflow/SubTask.h\n  39: \tvoid set_pointer(void *pointer) { this->pointer = pointer; }\n  40: \nStacktrace #1:\nFile: /sourcecode/src/factory/Workflow.cc\n 100: void SeriesWork::push_back(SubTask *task)\n 101: {\n 102: \tthis->mutex.lock();\n 103: \ttask->set_pointer(this);\n 104: \tthis->queue[this->back] = task;\n 105: \tif (++this->back == this->queue_size)\n 106: \t\tthis->back = 0;\n 107: \n 108: \tif (this->front == this->back)\n 109: \t\tthis->expand_queue();\n 110: \n 111: \tthis->mutex.unlock();\n 112: }\n 113: \nStacktrace #2:\nFile: /sourcecode/src/factory/WFGraphTask.cc\n  47: WFGraphNode& WFGraphTask::create_graph_node(SubTask *task)\n  48: {\n  49: \tWFGraphNode *node = new WFGraphNode;\n  50: \tSeriesWork *series = Workflow::create_series_work(node, node, nullptr);\n  51: \n  52: \tseries->push_back(task);\n  53: \tthis->parallel->add_series(series);\n  54: \treturn *node;\n  55: }\n  56:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==158411==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000c0 at pc 0x55c5633698d6 bp 0x7ffef3b7feb0 sp 0x7ffef3b7fea0\nREAD of size 8 at 0x6060000000c0 thread T0\n    #0 0x55c5633698d5 in UPSWeightedRandomPolicy::recover_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:584\n    #1 0x55c56335304c in fuzzloop /dockerin/fuzz_drivers/tf1729593105363twbj.cpp:41\n    #2 0x55c563520ee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55c563352978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f1559321d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f1559321e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55c563352ac4 in _start (/dockerin/fuzz_drivers/tf1729593105363twbj.out+0x381ac4)\n\n0x6060000000c0 is located 8 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7f1559f4a1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55c5633542db in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x55c563352d99 in fuzzloop /dockerin/fuzz_drivers/tf1729593105363twbj.cpp:39\n    #3 0x55c563520ee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:584 in UPSWeightedRandomPolicy::recover_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00 fa[fa]fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSWeightedRandomPolicy::recover_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy18recover_one_serverEPK15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/UpstreamPolicies.h\" //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"URIParser.h\" //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    bool try_another = fuzzBool(0);\n    auto upsweightedrandompolicy = std::make_unique<UPSWeightedRandomPolicy>(try_another);\n    std::string address = fuzzString(1);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsweightedrandompolicy->recover_one_server(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 579: void UPSWeightedRandomPolicy::recover_one_server(const EndpointAddress *addr)\n 580: {\n 581: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 582: \n 583: \tthis->nalives++;\n 584: \tif (params->group->nalives++ == 0 && params->group->id > 0)\n 585: \t\tthis->available_weight += params->group->weight;\n 586: \n 587: \tif (params->group_id < 0 && params->server_type == 0)\n 588: \t\tthis->available_weight += params->weight;\n 589: }\n 590:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3830==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x55fa6337c15a bp 0x7ffc9b4bd540 sp 0x7ffc9b4bd530\nREAD of size 8 at 0x602000000120 thread T0\n    #0 0x55fa6337c159 in rb_replace_node /sourcecode/src/kernel/rbtree.c:372\n    #1 0x55fa6337587e in fuzzloop /dockerin/fuzz_drivers/tf1729593326323kjve.cpp:33\n    #2 0x55fa63384d69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55fa63375348 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f7ae8527d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f7ae8527e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55fa63375494 in _start (/dockerin/fuzz_drivers/tf1729593326323kjve.out+0x17494)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f7ae914e887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55fa63384f7c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/rbtree.c:372 in rb_replace_node\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa 00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa 01 fa fa fa 01 fa fa fa 00 04\n  0x0c047fff8040: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8050: fa fa 00 04 fa fa 01 fa fa fa 01 fa fa fa 00 04\n  0x0c047fff8060: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:34:56\n// Signature: rb_replace_node(struct rb_node *victim, struct rb_node *newnode, struct rb_root *root)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: rb_replace_node\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/rbtree.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    struct rb_node victim = {\n        .rb_parent = (struct rb_node *)fuzzData(0),\n        .rb_right = (struct rb_node *)fuzzData(1),\n        .rb_left = (struct rb_node *)fuzzData(2),\n        .rb_color = fuzzUint8(3)\n    };\n\n    struct rb_node newnode = {\n        .rb_parent = (struct rb_node *)fuzzData(4),\n        .rb_right = (struct rb_node *)fuzzData(5),\n        .rb_left = (struct rb_node *)fuzzData(6),\n        .rb_color = fuzzUint8(7)\n    };\n\n    struct rb_root root = {\n        .rb_node = (struct rb_node *)fuzzData(8)\n    };\n\n    rb_replace_node(&victim, &newnode, &root);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/rbtree.c\n 365: void rb_replace_node(struct rb_node *victim, struct rb_node *newnode,\n 366: \t\t     struct rb_root *root)\n 367: {\n 368: \tstruct rb_node *parent = victim->rb_parent;\n 369: \n 370: \t/* Set the surrounding nodes to point to the replacement */\n 371: \tif (parent) {\n 372: \t\tif (victim == parent->rb_left)\n 373: \t\t\tparent->rb_left = newnode;\n 374: \t\telse\n 375: \t\t\tparent->rb_right = newnode;\n 376: \t} else {\n 377: \t\troot->rb_node = newnode;\n 378: \t}\n 379: \tif (victim->rb_left)\n 380: \t\tvictim->rb_left->rb_parent = newnode;\n 381: \tif (victim->rb_right)\n 382: \t\tvictim->rb_right->rb_parent = newnode;\n 383: \n 384: \t/* Copy the pointers/colour from the victim to the replacement */\n 385: \t*newnode = *victim;\n 386: }\n 387:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==551378==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55884ec7e208 bp 0x7fffa26ef5f0 sp 0x7fffa26ef5e0\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x55884ec7e207 in StringUtil::url_decode(char*, unsigned long) /sourcecode/src/util/StringUtil.cc:76\n    #1 0x55884ec7d9fa in fuzzloop /dockerin/fuzz_drivers/tf1729593388901mobm.cpp:17\n    #2 0x55884ec8e849 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55884ec7d7a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7ff454028d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7ff454028e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55884ec7d8f4 in _start (/dockerin/fuzz_drivers/tf1729593388901mobm.out+0x1c8f4)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7ff454c4f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55884ec8ea5c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/util/StringUtil.cc:76 in StringUtil::url_decode(char*, unsigned long)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:36:01\n// Signature: StringUtil::url_decode(char *str, size_t len)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN10StringUtil10url_decodeEPcm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/StringUtil.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    char* data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    StringUtil::url_decode(data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/util/StringUtil.cc\n  52: size_t StringUtil::url_decode(char *str, size_t len)\n  53: {\n  54: \tchar *dest = str;\n  55: \tchar *data = str;\n  56: \n  57: \twhile (len--)\n  58: \t{\n  59: \t\tif (*data == '%' && len >= 2\n  60: \t\t\t&& isxdigit(*(data + 1))\n  61: \t\t\t&& isxdigit(*(data + 2)))\n  62: \t\t{\n  63: \t\t\t*dest = __htoi((unsigned char *)data + 1);\n  64: \t\t\tdata += 2;\n  65: \t\t\tlen -= 2;\n  66: \t\t}\n  67: \t\telse if (*data == '+')\n  68: \t\t\t*dest = ' ';\n  69: \t\telse\n  70: \t\t\t*dest = *data;\n  71: \n  72: \t\tdata++;\n  73: \t\tdest++;\n  74: \t}\n  75: \n  76: \t*dest = '\\0';\n  77: \treturn dest - str;\n  78: }\n  79:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==202==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000004cb at pc 0x55e9350ea0fb bp 0x7ffd0317ad60 sp 0x7ffd0317ad50\nWRITE of size 1 at 0x6020000004cb thread T0\n    #0 0x55e9350ea0fa in http_decode_url_unsafe /sourcecode/lib/facil/http/http.c:2433\n    #1 0x55e934fd780a in fuzzloop /sharedockerin/ta1729829438469rhkp/test_file.c:29\n    #2 0x55e935156249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e934fd6ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f8c08d78d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f8c08d78e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e934fd6c04 in _start (/sharedockerin/ta1729829438469rhkp/clouditera+0x1dbc04)\n\n0x6020000004cb is located 171 bytes to the right of 16-byte region [0x602000000410,0x602000000420)\nallocated by thread T0 here:\n    #0 0x7f8c09751887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e93515645c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:2433 in http_decode_url_unsafe\nShadow bytes around the buggy address:\n  0x0c047fff8040: fa fa 05 fa fa fa 00 00 fa fa 05 fa fa fa 00 04\n  0x0c047fff8050: fa fa 00 04 fa fa 05 fa fa fa 07 fa fa fa 05 fa\n  0x0c047fff8060: fa fa 05 fa fa fa 00 fa fa fa 00 01 fa fa 00 01\n  0x0c047fff8070: fa fa 05 fa fa fa 00 04 fa fa 00 04 fa fa fd fd\n  0x0c047fff8080: fa fa 00 00 fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff8090: fa fa fd fa fa fa fd fa fa[fa]fd fa fa fa fd fa\n  0x0c047fff80a0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80c0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff80d0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80e0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: http_decode_url_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_url_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_url_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2416: ssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n2417:   char *pos = dest;\n2418:   while (*url_data) {\n2419:     if (*url_data == '+') {\n2420:       // decode space\n2421:       *(pos++) = ' ';\n2422:       ++url_data;\n2423:     } else if (*url_data == '%') {\n2424:       // decode hex value\n2425:       // this is a percent encoded value.\n2426:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2427:         return -1;\n2428:       pos++;\n2429:       url_data += 3;\n2430:     } else\n2431:       *(pos++) = *(url_data++);\n2432:   }\n2433:   *pos = 0;\n2434:   return pos - dest;\n2435: }\n2436:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200002e793 at pc 0x7f240bc29397 bp 0x7ffec82fcbb0 sp 0x7ffec82fc358\nREAD of size 3 at 0x60200002e793 thread T0\n    #0 0x7f240bc29396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x556c194f6cf3 in uint3korr /sourcecode/src/protocol/mysql_byteorder.h:179\n    #2 0x556c194f7255 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:53\n    #3 0x556c194f672e in fuzzloop /sharedockerin/ta1729664329765ysdw/test_file.cpp:24\n    #4 0x556c194fff29 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x556c194f63a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f240b07cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f240b07ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x556c194f64f4 in _start (/sharedockerin/ta1729664329765ysdw/clouditera+0xf4f4)\n\n0x60200002e793 is located 0 bytes to the right of 3-byte region [0x60200002e790,0x60200002e793)\nallocated by thread T0 here:\n    #0 0x7f240bca3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556c1950013c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fffdca0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffdcb0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffdcc0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffdcd0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffdce0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n=>0x0c047fffdcf0: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffdd00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffdd10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffdd20: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffdd30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffdd40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:40:09\n// Signature: decode_length_safe(unsigned long long *res, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_length_safe\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    unsigned long long res;\n    const unsigned char *pos;\n    const unsigned char *end;\n\n    char *data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    pos = reinterpret_cast<const unsigned char*>(data);\n    end = reinterpret_cast<const unsigned char*>(data + len);\n\n    decode_length_safe(&res, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n 176: static inline uint32_t uint3korr(const unsigned char *A)\n 177: {\n 178: \tuint32_t ret = 0;\n 179: \tmemcpy(&ret, A, 3);\n 180: \treturn ret;\n 181: }\n 182: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==208==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000142f3 at pc 0x7f9c7b7fd397 bp 0x7ffd5263deb0 sp 0x7ffd5263d658\nREAD of size 3 at 0x6020000142f3 thread T0\n    #0 0x7f9c7b7fd396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x56133dd4f986 in uint3korr /sourcecode/src/protocol/mysql_byteorder.h:179\n    #2 0x56133dd4fee8 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:53\n    #3 0x56133dd4cea3 in parse_field_count /sourcecode/src/protocol/mysql_parser.c:357\n    #4 0x56133dd49262 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x56133dd4777b in fuzzloop /sharedockerin/ta1729664331891fgfr/test_file.cpp:21\n    #6 0x56133dd58bc9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x56133dd47448 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7f9c7ac50d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7f9c7ac50e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x56133dd47594 in _start (/sharedockerin/ta1729664331891fgfr/clouditera+0x19594)\n\n0x6020000142f3 is located 0 bytes to the right of 3-byte region [0x6020000142f0,0x6020000142f3)\nallocated by thread T0 here:\n    #0 0x7f9c7b877887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56133dd58ddc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fffa800: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa810: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa820: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa830: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa840: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fffa850: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[03]fa\n  0x0c047fffa860: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffa870: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffa880: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fa fa\n  0x0c047fffa890: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa8a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:59:26\n// Signature: mysql_parser_get_net_state(char **net_state_str, size_t *net_state_len, mysql_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: mysql_parser_get_net_state\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/MySQLResult.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    mysql_parser_t parser;\n    mysql_parser_init(&parser);\n\n    char *buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n\n    mysql_parser_parse(buf, len, &parser);\n\n    const char *net_state_str;\n    size_t net_state_len;\n    mysql_parser_get_net_state(&net_state_str, &net_state_len, &parser);\n\n    mysql_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n 176: static inline uint32_t uint3korr(const unsigned char *A)\n 177: {\n 178: \tuint32_t ret = 0;\n 179: \tmemcpy(&ret, A, 3);\n 180: \treturn ret;\n 181: }\n 182: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 349: static int parse_field_count(const void *buf, size_t len, mysql_parser_t *parser)\n 350: {\n 351: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 352: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 353: \n 354: \tunsigned long long field_count;\n 355: \tstruct __mysql_result_set *result_set;\n 356: \n 357: \tif (decode_length_safe(&field_count, &p, buf_end) <= 0)\n 358: \t\treturn -2;\n 359: \n 360: \tfield_count = (field_count == ~0ULL) ? 0 : field_count;\n 361: \n 362: \tif (field_count)\n 363: \t{\n 364: \t\tresult_set = (struct __mysql_result_set *)malloc(sizeof (struct __mysql_result_set));\n 365: \t\tif (result_set == NULL)\n 366: \t\t\treturn -1;\n 367: \n 368: \t\tresult_set->fields = (mysql_field_t **)calloc(field_count, sizeof (mysql_field_t *));\n 369: \t\tif (result_set->fields == NULL)\n 370: \t\t{\n 371: \t\t\tfree(result_set);\n 372: \t\t\treturn -1;\n 373: \t\t}\n 374: \n 375: \t\tresult_set->field_count = field_count;\n 376: \t\tresult_set->row_count = 0;\n 377: \t\tresult_set->type = MYSQL_PACKET_GET_RESULT;\n 378: \n 379: \t\tlist_add_tail(&result_set->list, &parser->result_set_list);\n 380: \t\tparser->current_result_set = result_set;\n 381: \t\tparser->current_field_count = 0;\n 382: \t\tparser->result_set_count++;\n 383: \t\tparser->packet_type = MYSQL_PACKET_GET_RESULT;\n 384: \n 385: \t\tparser->parse = parse_column_def_packet;\n 386: \t\tparser->offset = p - (const unsigned char *)buf;\n 387: \t} else {\n 388: \t\tparser->parse = parse_ok_packet;\n 389: \t}\n 390: \treturn 0;\n 391: }\n 392: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==6226==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000008 at pc 0x55b2ec897a6d bp 0x7ffc613c80c0 sp 0x7ffc613c80b0\nWRITE of size 2 at 0x602000000008 thread T0\n    #0 0x55b2ec897a6c in block_free /sourcecode/lib/facil/fio.c:7837\n    #1 0x55b2ec89853b in block_slice_free /sourcecode/lib/facil/fio.c:7935\n    #2 0x55b2ec898e11 in fio_free /sourcecode/lib/facil/fio.c:8097\n    #3 0x55b2ec898e8a in fio_realloc2 /sourcecode/lib/facil/fio.c:8129\n    #4 0x55b2ec898fca in fio_realloc /sourcecode/lib/facil/fio.c:8136\n    #5 0x55b2ec82126e in fuzzloop /dockerin/fuzz_drivers/tf1729828850338ecip.c:39\n    #6 0x55b2ec8d0e69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55b2ec8209d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7fac7132cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7fac7132ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55b2ec820b24 in _start (/dockerin/fuzz_drivers/tf1729828850338ecip.out+0xc5b24)\n\n0x602000000008 is located 8 bytes to the left of 15-byte region [0x602000000010,0x60200000001f)\nallocated by thread T0 here:\n    #0 0x7fac71d05887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7fac713ab58e in strdup (/lib/x86_64-linux-gnu/libc.so.6+0xa858e)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:7837 in block_free\nShadow bytes around the buggy address:\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c047fff8000: fa[fa]00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa fd fd\n  0x0c047fff8020: fa fa fd fd fa fa fd fa fa fa fd fa fa fa 00 04\n  0x0c047fff8030: fa fa 00 fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8050: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: fio_realloc(void *ptr, size_t new_size)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_realloc\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ptr = (void *)fuzzData(0);\n    size_t new_size = (size_t)fuzzUint64(1);\n    void * ret = fio_realloc(ptr, new_size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7836: static inline void block_free(block_s *blk) {\n7837:   if (fio_atomic_sub(&blk->ref, 1))\n7838:     return;\n7839: \n7840:   memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n7841:   fio_lock(&memory.lock);\n7842:   fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n7843: \n7844:   blk = blk->parent;\n7845: \n7846:   if (fio_atomic_sub(&blk->root_ref, 1)) {\n7847:     fio_unlock(&memory.lock);\n7848:     return;\n7849:   }\n7850:   // fio_unlock(&memory.lock);\n7851:   // return;\n7852: \n7853:   /* remove all of the root block's children (slices) from the memory pool */\n7854:   for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n7855:     block_node_s *pos =\n7856:         (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));\n7857:     fio_ls_embd_remove(&pos->node);\n7858:   }\n7859: \n7860:   fio_unlock(&memory.lock);\n7861:   sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n7862:   FIO_LOG_DEBUG(\"memory allocator returned %p to the system\", (void *)blk);\n7863:   FIO_MEMORY_ON_BLOCK_FREE();\n7864: }\n7865: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n7932: static inline void block_slice_free(void *mem) {\n7933:   /* locate block boundary */\n7934:   block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n7935:   block_free(blk);\n7936: }\n7937: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8088: void fio_free(void *ptr) {\n8089:   if (!ptr || ptr == (void *)&on_malloc_zero)\n8090:     return;\n8091:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8092:     /* big allocation - direct from the system */\n8093:     big_free(ptr);\n8094:     return;\n8095:   }\n8096:   /* allocated within block */\n8097:   block_slice_free(ptr);\n8098: }\n8099: \nStacktrace #3:\nFile: /sourcecode/lib/facil/fio.c\n8106: void *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n8107:   if (!ptr || ptr == (void *)&on_malloc_zero) {\n8108:     return fio_malloc(new_size);\n8109:   }\n8110:   if (!new_size) {\n8111:     goto zero_size;\n8112:   }\n8113:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8114:     /* big reallocation - direct from the system */\n8115:     return big_realloc(ptr, new_size);\n8116:   }\n8117:   /* allocated within block - don't even try to expand the allocation */\n8118:   /* ceiling for 16 byte alignement, translated to 16 byte units */\n8119:   void *new_mem = fio_malloc(new_size);\n8120:   if (!new_mem)\n8121:     return NULL;\n8122:   new_size = ((new_size >> 4) + (!!(new_size & 15)));\n8123:   copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n8124:   fio_memcpy(new_mem, ptr, copy_length > new_size ? new_size : copy_length);\n8125: \n8126:   block_slice_free(ptr);\n8127:   return new_mem;\n8128: zero_size:\n8129:   fio_free(ptr);\n8130:   return fio_malloc(0);\n8131: }\n8132: \nStacktrace #4:\nFile: /sourcecode/lib/facil/fio.c\n8133: void *fio_realloc(void *ptr, size_t new_size) {\n8134:   const size_t max_old =\n8135:       FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK);\n8136:   return fio_realloc2(ptr, new_size, max_old);\n8137: }\n8138:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4171==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000069c at pc 0x7fcdc14b204f bp 0x7ffcd8d78110 sp 0x7ffcd8d778a0\nWRITE of size 13 at 0x60200000069c thread T0\n    #0 0x7fcdc14b204e in __interceptor_vsprintf ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1687\n    #1 0x7fcdc14b227e in __interceptor_sprintf ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1730\n    #2 0x555cbf4b51c5 in fio_ftoa /sourcecode/lib/facil/fio.c:4997\n    #3 0x555cbf471288 in fuzzloop /dockerin/fuzz_drivers/tf1729822402974mtmw.c:26\n    #4 0x555cbf520e69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x555cbf4709d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fcdc0b2ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fcdc0b2ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x555cbf470b24 in _start (/dockerin/fuzz_drivers/tf1729822402974mtmw.out+0xc5b24)\n\n0x60200000069c is located 0 bytes to the right of 12-byte region [0x602000000690,0x60200000069c)\nallocated by thread T0 here:\n    #0 0x7fcdc1507887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x555cbf52107c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1687 in __interceptor_vsprintf\nShadow bytes around the buggy address:\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80a0: fa fa 00 04 fa fa fd fd fa fa 00 fa fa fa fd fa\n  0x0c047fff80b0: fa fa 01 fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff80c0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n=>0x0c047fff80d0: fa fa 00[04]fa fa 00 fa fa fa 01 fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_ftoa(char *dest, double num, uint8_t base)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_ftoa\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <fio.h> //extract\n#include <stdarg.h> //extract\n#include <stdint.h> //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    double num = fuzzDouble(1);\n    uint8_t base = fuzzUint8(2);\n    size_t ret = fio_ftoa(dest, num, base);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4987:  */\n4988: size_t fio_ftoa(char *dest, double num, uint8_t base) {\n4989:   if (base == 2 || base == 16) {\n4990:     /* handle the binary / Hex representation the same as if it were an\n4991:      * int64_t\n4992:      */\n4993:     int64_t *i = (void *)&num;\n4994:     return fio_ltoa(dest, *i, base);\n4995:   }\n4996: \n4997:   size_t written = sprintf(dest, \"%g\", num);\n4998:   uint8_t need_zero = 1;\n4999:   char *start = dest;\n5000:   while (*start) {\n5001:     if (*start == ',') // locale issues?\n5002:       *start = '.';\n5003:     if (*start == '.' || *start == 'e') {\n5004:       need_zero = 0;\n5005:       break;\n5006:     }\n5007:     start++;\n5008:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000037391 at pc 0x56551533e989 bp 0x7fff18d98920 sp 0x7fff18d98910\nREAD of size 2 at 0x602000037391 thread T0\n    #0 0x56551533e988 in uint2korr /sourcecode/src/protocol/mysql_byteorder.h:44\n    #1 0x56551533f126 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:45\n    #2 0x56551533f592 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x56551533e73c in fuzzloop /sharedockerin/ta1729664330266xzik/test_file.cpp:22\n    #4 0x565515347f59 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x56551533e3a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f99e539fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f99e539fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x56551533e4f4 in _start (/sharedockerin/ta1729664330266xzik/clouditera+0xf4f4)\n\n0x602000037392 is located 0 bytes to the right of 2-byte region [0x602000037390,0x602000037392)\nallocated by thread T0 here:\n    #0 0x7f99e5fc6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56551534816c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_byteorder.h:44 in uint2korr\nShadow bytes around the buggy address:\n  0x0c047fffee20: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffee30: fa fa fd fa fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffee40: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd\n  0x0c047fffee50: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\n  0x0c047fffee60: fa fa fd fd fa fa fd fd fa fa 00 00 fa fa fd fd\n=>0x0c047fffee70: fa fa[02]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffee80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffee90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffeea0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffeeb0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffeec0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:37:15\n// Signature: decode_string(unsigned char **str, unsigned long long *len, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_string\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    const unsigned char *data = reinterpret_cast<const unsigned char*>(fuzzData(0));\n    int len = fuzzGetLen(0);\n    const unsigned char *pos = data;\n    const unsigned char *end = data + len;\n    unsigned long long length;\n    const unsigned char *str;\n\n    decode_string(&str, &length, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  42: static inline uint16_t uint2korr(const unsigned char *A)\n  43: {\n  44: \tuint16_t ret;\n  45: \tmemcpy(&ret, A, sizeof(ret));\n  46: \treturn ret;\n  47: }\n  48: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==148925==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000b8 at pc 0x55eca9ee875c bp 0x7fff60758590 sp 0x7fff60758580\nREAD of size 4 at 0x6060000000b8 thread T0\n    #0 0x55eca9ee875b in UPSGroupPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:292\n    #1 0x55eca9eee8c9 in UPSWeightedRandomPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:480\n    #2 0x55eca9ef6aa8 in UPSVNSWRRPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:655\n    #3 0x55eca9edaff0 in fuzzloop /dockerin/fuzz_drivers/tf1729593105364aiic.cpp:40\n    #4 0x55ecaa0a96a9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55eca9eda978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f970e3c4d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f970e3c4e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55eca9edaac4 in _start (/dockerin/fuzz_drivers/tf1729593105364aiic.out+0x382ac4)\n\n0x6060000000b8 is located 0 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7f970efed1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55eca9edca2d in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() (/dockerin/fuzz_drivers/tf1729593105364aiic.out+0x384a2d)\n    #2 0x55eca9edad3d in fuzzloop /dockerin/fuzz_drivers/tf1729593105364aiic.cpp:38\n    #3 0x55ecaa0a96a9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:292 in UPSGroupPolicy::add_server_locked(EndpointAddress*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSVNSWRRPolicy::add_server_locked(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN15UPSVNSWRRPolicy17add_server_lockedEP15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/UpstreamPolicies.h\" //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"URIParser.h\" //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    auto upsvnswrrpolicy = std::make_unique<UPSVNSWRRPolicy>();\n    std::string address = fuzzString(0);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsvnswrrpolicy->add_server_locked(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 289: void UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n 290: {\n 291: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 292: \tint group_id = params->group_id;\n 293: \trb_node **p = &this->group_map.rb_node;\n 294: \trb_node *parent = NULL;\n 295: \tEndpointGroup *group;\n 296: \n 297: \tthis->server_map[addr->address].push_back(addr);\n 298: \n 299: \tif (params->server_type == 0)\n 300: \t\tthis->servers.push_back(addr);\n 301: \n 302: \twhile (*p)\n 303: \t{\n 304: \t\tparent = *p;\n 305: \t\tgroup = rb_entry(*p, EndpointGroup, rb);\n 306: \n 307: \t\tif (group_id < group->id)\n 308: \t\t\tp = &(*p)->rb_left;\n 309: \t\telse if (group_id > group->id)\n 310: \t\t\tp = &(*p)->rb_right;\n 311: \t\telse\n 312: \t\t\tbreak;\n 313: \t}\n 314: \n 315: \tif (*p == NULL)\n 316: \t{\n 317: \t\tgroup = new EndpointGroup(group_id, this);\n 318: \t\trb_link_node(&group->rb, parent, p);\n 319: \t\trb_insert_color(&group->rb, &this->group_map);\n 320: \t}\n 321: \n 322: \tpthread_mutex_lock(&group->mutex);\n 323: \tparams->group = group;\n 324: \tthis->recover_one_server(addr);\n 325: \tif (params->server_type == 0)\n 326: \t{\n 327: \t\tgroup->mains.push_back(addr);\n 328: \t\tgroup->weight += params->weight;\n 329: \t}\n 330: \telse\n 331: \t\tgroup->backups.push_back(addr);\n 332: \tpthread_mutex_unlock(&group->mutex);\n 333: }\n 334: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 476: void UPSWeightedRandomPolicy::add_server_locked(EndpointAddress *addr)\n 477: {\n 478: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 479: \n 480: \tUPSGroupPolicy::add_server_locked(addr);\n 481: \tif (params->server_type == 0)\n 482: \t\tthis->total_weight += params->weight;\n 483: }\n 484: \nStacktrace #2:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 653: void UPSVNSWRRPolicy::add_server_locked(EndpointAddress *addr)\n 654: {\n 655: \tUPSWeightedRandomPolicy::add_server_locked(addr);\n 656: \tinit();\n 657: }\n 658:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1495==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55e4154e480b bp 0x7fff5465c340 sp 0x7fff5465c330\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x55e4154e480a in fio_ltoa /sourcecode/lib/facil/fio.c:4949\n    #1 0x55e41559fdaa in http_date2rfc7231 /sourcecode/lib/facil/http/http.c:2217\n    #2 0x55e41557c4f6 in http_date2str /sourcecode/lib/facil/http/http.h:923\n    #3 0x55e4155a4d90 in http_time2str /sourcecode/lib/facil/http/http.c:2353\n    #4 0x55e41549380a in fuzzloop /dockerin/fuzz_drivers/tf1729828200445vlro.c:29\n    #5 0x55e415612249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55e415492ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f49e8339d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f49e8339e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55e415492c04 in _start (/dockerin/fuzz_drivers/tf1729828200445vlro.out+0x1dbc04)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f49e8d12887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e41561245c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:4949 in fio_ltoa\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 03:49:50\n// Signature: http_time2str(char *target, time_t t)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_time2str\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * target = fuzzString(0);\n    long t = (long)fuzzInt64(1);\n    size_t ret = http_time2str(target, t);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4821: size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n4822:   const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n4823:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n4824: \n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n...skip...\n4865:       }\n4866:       dest[len++] = '0';\n4867: \n4868:       while (num) {\n4869:         buf[l++] = '0' + (num & 7);\n4870:         num = num >> 3;\n4871:       }\n4872:       while (l) {\n4873:         --l;\n4874:         dest[len++] = buf[l];\n4875:       }\n4876:       dest[len] = 0;\n4877:       return len;\n4878:     }\n4879: \n4880:   case 16:\n4881:     /* Base 16 */\n4882:     {\n4883:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4884:       uint8_t i = 0;    /* counting bits */\n4885:       dest[len++] = '0';\n4886:       dest[len++] = 'x';\n4887:       while (i < 8 && (n & 0xFF00000000000000) == 0) {\n4888:         n = n << 8;\n4889:         i++;\n4890:       }\n4891:       /* make sure the Hex representation doesn't appear misleadingly signed. */\n4892:       if (i && (n & 0x8000000000000000)) {\n4893:         dest[len++] = '0';\n4894:         dest[len++] = '0';\n4895:       }\n4896:       /* write the damn thing, high to low */\n4897:       while (i < 8) {\n4898:         uint8_t tmp = (n & 0xF000000000000000) >> 60;\n4899:         dest[len++] = notation[tmp];\n4900:         tmp = (n & 0x0F00000000000000) >> 56;\n4901:         dest[len++] = notation[tmp];\n4902:         i++;\n4903:         n = n << 8;\n4904:       }\n4905:       dest[len] = 0;\n4906:       return len;\n4907:     }\n4908:   case 3: /* fallthrough */\n4909:   case 4: /* fallthrough */\n4910:   case 5: /* fallthrough */\n4911:   case 6: /* fallthrough */\n4912:   case 7: /* fallthrough */\n4913:   case 9: /* fallthrough */\n4914:     /* rare bases */\n4915:     if (num < 0) {\n4916:       dest[len++] = '-';\n4917:       num = 0 - num;\n4918:     }\n4919:     uint64_t l = 0;\n4920:     while (num) {\n4921:       uint64_t t = num / base;\n4922:       buf[l++] = '0' + (num - (t * base));\n4923:       num = t;\n4924:     }\n4925:     while (l) {\n4926:       --l;\n4927:       dest[len++] = buf[l];\n4928:     }\n4929:     dest[len] = 0;\n4930:     return len;\n4931: \n4932:   default:\n4933:     break;\n4934:   }\n4935:   /* Base 10, the default base */\n4936: \n4937:   if (num < 0) {\n4938:     dest[len++] = '-';\n4939:     num = 0 - num;\n4940:   }\n4941:   uint64_t l = 0;\n4942:   while (num) {\n4943:     uint64_t t = num / 10;\n4944:     buf[l++] = '0' + (num - (t * 10));\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960:     break;\n4961:   case 8:\n4962:     dest[len++] = '0';\n4963:     break;\n4964:   case 16:\n4965:     dest[len++] = '0';\n4966:     dest[len++] = 'x';\n4967:     dest[len++] = '0';\n4968:     break;\n4969:   }\n4970:   dest[len++] = '0';\n4971:   dest[len] = 0;\n4972:   return len;\n4973: }\n4974: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2196: size_t http_date2rfc7231(char *target, struct tm *tmbuf) {\n2197:   /* note: day of month is always 2 digits */\n2198:   char *pos = target;\n2199:   uint16_t tmp;\n2200:   pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n2201:   pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n2202:   pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n2203:   pos[3] = ',';\n2204:   pos[4] = ' ';\n2205:   pos += 5;\n2206:   tmp = tmbuf->tm_mday / 10;\n2207:   pos[0] = '0' + tmp;\n2208:   pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n2209:   pos += 2;\n2210:   *(pos++) = ' ';\n2211:   pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n2212:   pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n2213:   pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n2214:   pos[3] = ' ';\n2215:   pos += 4;\n2216:   // write year.\n2217:   pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n2218:   *(pos++) = ' ';\n2219:   tmp = tmbuf->tm_hour / 10;\n2220:   pos[0] = '0' + tmp;\n2221:   pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n2222:   pos[2] = ':';\n2223:   tmp = tmbuf->tm_min / 10;\n2224:   pos[3] = '0' + tmp;\n2225:   pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n2226:   pos[5] = ':';\n2227:   tmp = tmbuf->tm_sec / 10;\n2228:   pos[6] = '0' + tmp;\n2229:   pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n2230:   pos += 8;\n2231:   pos[0] = ' ';\n2232:   pos[1] = GMT_STR[0];\n2233:   pos[2] = GMT_STR[1];\n2234:   pos[3] = GMT_STR[2];\n2235:   pos[4] = 0;\n2236:   pos += 4;\n2237:   return pos - target;\n2238: }\n2239: \nStacktrace #2:\nFile: /sourcecode/lib/facil/http/http.h\n 922: static inline size_t http_date2str(char *target, struct tm *tmbuf) {\n 923:   return http_date2rfc7231(target, tmbuf);\n 924: }\n 925: \nStacktrace #3:\nFile: /sourcecode/lib/facil/http/http.c\n2343: size_t http_time2str(char *target, const time_t t) {\n2344:   /* pre-print time every 1 or 2 seconds or so. */\n2345:   static __thread time_t cached_tick;\n2346:   static __thread char cached_httpdate[48];\n2347:   static __thread size_t cached_len;\n2348:   time_t last_tick = fio_last_tick().tv_sec;\n2349:   if ((t | 7) < last_tick) {\n2350:     /* this is a custom time, not \"now\", pass through */\n2351:     struct tm tm;\n2352:     http_gmtime(t, &tm);\n2353:     return http_date2str(target, &tm);\n2354:   }\n2355:   if (last_tick > cached_tick) {\n2356:     struct tm tm;\n2357:     cached_tick = last_tick; /* refresh every second */\n2358:     http_gmtime(last_tick, &tm);\n2359:     cached_len = http_date2str(cached_httpdate, &tm);\n2360:   }\n2361:   memcpy(target, cached_httpdate, cached_len);\n2362:   return cached_len;\n2363: }\n2364:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==28796==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000d71 at pc 0x562ba18ea8c4 bp 0x7ffc2ddbde60 sp 0x7ffc2ddbde50\nWRITE of size 1 at 0x602000000d71 thread T0\n    #0 0x562ba18ea8c3 in to_hex include/internal/to_hex.h:17\n    #1 0x562ba18ec169 in ossl_to_hex crypto/o_str.c:433\n    #2 0x562ba18ea6e0 in fuzzloop /dockerin/fuzz_drivers/tf1730183726674jmdv.c:26\n    #3 0x562ba18f4aa9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x562ba18ea408 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fe2549fbd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fe2549fbe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x562ba18ea554 in _start (/dockerin/fuzz_drivers/tf1730183726674jmdv.out+0xf554)\n\n0x602000000d71 is located 0 bytes to the right of 1-byte region [0x602000000d70,0x602000000d71)\nallocated by thread T0 here:\n    #0 0x7fe255287887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562ba18f4cbc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow include/internal/to_hex.h:17 in to_hex\nShadow bytes around the buggy address:\n  0x0c047fff8150: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8160: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8170: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8180: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8190: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\n=>0x0c047fff81a0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa[01]fa\n  0x0c047fff81b0: fa fa 01 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:25:53\n// Signature: ossl_to_hex(char *buf, uint8_t n)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_to_hex\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/e_os.h\" //extract\n#include <string.h> //extract\n#include <limits.h> //extract\n#include <openssl/crypto.h> //extract\n#include \"crypto/ctype.h\" //extract\n#include \"internal/cryptlib.h\" //extract\n#include \"internal/thread_once.h\" //extract\n#include \"internal/to_hex.h\" //extract\n\nint fuzzloop() {\n    char * buf = fuzzString(0);\n    uint8_t n = fuzzUint8(1);\n    size_t ret = ossl_to_hex(buf, n);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/internal/to_hex.h\n  14: static ossl_inline size_t to_hex(char *buf, uint8_t n, const char hexdig[17])\n  15: {\n  16:     *buf++ = hexdig[(n >> 4) & 0xf];\n  17:     *buf = hexdig[n & 0xf];\n  18:     return 2;\n  19: }\n  20: \nStacktrace #1:\nFile: /sourcecode/crypto/o_str.c\n 429: size_t ossl_to_hex(char *buf, uint8_t n)\n 430: {\n 431:     static const char hexdig[] = \"0123456789ABCDEF\";\n 432: \n 433:     return to_hex(buf, n, hexdig);\n 434: }\n 435:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3036==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x560db30199fb bp 0x7ffd1b6d64e0 sp 0x7ffd1b6d64d0\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x560db30199fa in fio_rand_bytes /sourcecode/lib/facil/fio.c:8219\n    #1 0x560db2fa126e in fuzzloop /dockerin/fuzz_drivers/tf1729822402999banr.c:39\n    #2 0x560db3050e49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x560db2fa09d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f31f91c2d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f31f91c2e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x560db2fa0b24 in _start (/dockerin/fuzz_drivers/tf1729822402999banr.out+0xc5b24)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f31f9b9b887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x560db305105c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:8219 in fio_rand_bytes\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_rand_bytes(void *data_, size_t len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_rand_bytes\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data_ = (void *)fuzzData(0);\n    size_t len = (size_t)fuzzUint64(1);\n    fio_rand_bytes(data_, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n8208: void fio_rand_bytes(void *data_, size_t len) {\n8209:   if (!data_ || !len)\n8210:     return;\n8211:   uint8_t *data = data_;\n8212:   /* unroll 32 bytes / 256 bit writes */\n8213:   for (size_t i = (len >> 5); i; --i) {\n8214:     const uint64_t t0 = fio_rand64();\n8215:     const uint64_t t1 = fio_rand64();\n8216:     const uint64_t t2 = fio_rand64();\n8217:     const uint64_t t3 = fio_rand64();\n8218:     fio_u2str64(data, t0);\n8219:     fio_u2str64(data + 8, t1);\n8220:     fio_u2str64(data + 16, t2);\n8221:     fio_u2str64(data + 24, t3);\n8222:     data += 32;\n8223:   }\n8224:   uint64_t tmp;\n8225:   /* 64 bit steps  */\n8226:   switch (len & 24) {\n8227:   case 24:\n8228:     tmp = fio_rand64();\n8229:     fio_u2str64(data + 16, tmp);\n8230:     /* fallthrough */\n8231:   case 16:\n8232:     tmp = fio_rand64();\n8233:     fio_u2str64(data + 8, tmp);\n8234:     /* fallthrough */\n8235:   case 8:\n8236:     tmp = fio_rand64();\n8237:     fio_u2str64(data, tmp);\n8238:     data += len & 24;\n8239:   }\n8240:   if ((len & 7)) {\n8241:     tmp = fio_rand64();\n8242:     /* leftover bytes */\n8243:     switch ((len & 7)) {\n8244:     case 7:\n8245:       data[6] = (tmp >> 8) & 0xFF;\n8246:       /* fallthrough */\n8247:     case 6:\n8248:       data[5] = (tmp >> 16) & 0xFF;\n8249:       /* fallthrough */\n8250:     case 5:\n8251:       data[4] = (tmp >> 24) & 0xFF;\n8252:       /* fallthrough */\n8253:     case 4:\n8254:       data[3] = (tmp >> 32) & 0xFF;\n8255:       /* fallthrough */\n8256:     case 3:\n8257:       data[2] = (tmp >> 40) & 0xFF;\n8258:       /* fallthrough */\n8259:     case 2:\n8260:       data[1] = (tmp >> 48) & 0xFF;\n8261:       /* fallthrough */\n8262:     case 1:\n8263:       data[0] = (tmp >> 56) & 0xFF;\n8264:     }\n8265:   }\n8266: }\n8267:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==25302==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000118 at pc 0x5559cc6716fa bp 0x7ffd62c116d0 sp 0x7ffd62c116c0\nREAD of size 8 at 0x602000000118 thread T0\n    #0 0x5559cc6716f9 in Executor::executor_thread_routine(void*) /sourcecode/src/kernel/Executor.cc:83\n    #1 0x5559cc670874 in fuzzloop /dockerin/fuzz_drivers/tf1729593105326rbnn.cpp:25\n    #2 0x5559cc680079 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x5559cc670638 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7faf5ac0fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7faf5ac0fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x5559cc670784 in _start (/dockerin/fuzz_drivers/tf1729593105326rbnn.out+0x1a784)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7faf5b836887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5559cc68028c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Executor.cc:83 in Executor::executor_thread_routine(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Executor::executor_thread_routine(void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8Executor23executor_thread_routineEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <errno.h> //extract\n#include <stdlib.h> //extract\n#include <pthread.h> //extract\n#include \"list.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"Executor.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(0);\n    Executor::executor_thread_routine(context);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Executor.cc\n  76: void Executor::executor_thread_routine(void *context)\n  77: {\n  78: \tExecQueue *queue = (ExecQueue *)context;\n  79: \tstruct ExecSessionEntry *entry;\n  80: \tExecSession *session;\n  81: \tint empty;\n  82: \n  83: \tentry = list_entry(queue->session_list.next, struct ExecSessionEntry, list);\n  84: \tpthread_mutex_lock(&queue->mutex);\n  85: \tlist_del(&entry->list);\n  86: \tempty = list_empty(&queue->session_list);\n  87: \tpthread_mutex_unlock(&queue->mutex);\n  88: \n  89: \tsession = entry->session;\n  90: \tif (!empty)\n  91: \t{\n  92: \t\tstruct thrdpool_task task = {\n  93: \t\t\t.routine\t=\tExecutor::executor_thread_routine,\n  94: \t\t\t.context\t=\tqueue\n  95: \t\t};\n  96: \t\t__thrdpool_schedule(&task, entry, entry->thrdpool);\n  97: \t}\n  98: \telse\n  99: \t\tfree(entry);\n 100: \n 101: \tsession->execute();\n 102: \tsession->handle(ES_STATE_FINISHED, 0);\n 103: }\n 104:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==13071==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000b8 at pc 0x55bbaa3025ae bp 0x7ffeb3487d00 sp 0x7ffeb3487cf0\nREAD of size 4 at 0x6060000000b8 thread T0\n    #0 0x55bbaa3025ad in UPSGroupPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:292\n    #1 0x55bbaa2f5ff0 in fuzzloop /dockerin/fuzz_drivers/tf1729593105357fnjc.cpp:39\n    #2 0x55bbaa4c37c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55bbaa2f5978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f3f440f6d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f3f440f6e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55bbaa2f5ac4 in _start (/dockerin/fuzz_drivers/tf1729593105357fnjc.out+0x380ac4)\n\n0x6060000000b8 is located 0 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7f3f44d1f1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55bbaa2f6bfb in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x55bbaa2f5d3d in fuzzloop /dockerin/fuzz_drivers/tf1729593105357fnjc.cpp:37\n    #3 0x55bbaa4c37c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:292 in UPSGroupPolicy::add_server_locked(EndpointAddress*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14UPSGroupPolicy17add_server_lockedEP15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"URIParser.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    auto upsgrouppolicy = std::make_unique<UPSGroupPolicy>();\n    std::string address = fuzzString(0);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsgrouppolicy->add_server_locked(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 289: void UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n 290: {\n 291: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 292: \tint group_id = params->group_id;\n 293: \trb_node **p = &this->group_map.rb_node;\n 294: \trb_node *parent = NULL;\n 295: \tEndpointGroup *group;\n 296: \n 297: \tthis->server_map[addr->address].push_back(addr);\n 298: \n 299: \tif (params->server_type == 0)\n 300: \t\tthis->servers.push_back(addr);\n 301: \n 302: \twhile (*p)\n 303: \t{\n 304: \t\tparent = *p;\n 305: \t\tgroup = rb_entry(*p, EndpointGroup, rb);\n 306: \n 307: \t\tif (group_id < group->id)\n 308: \t\t\tp = &(*p)->rb_left;\n 309: \t\telse if (group_id > group->id)\n 310: \t\t\tp = &(*p)->rb_right;\n 311: \t\telse\n 312: \t\t\tbreak;\n 313: \t}\n 314: \n 315: \tif (*p == NULL)\n 316: \t{\n 317: \t\tgroup = new EndpointGroup(group_id, this);\n 318: \t\trb_link_node(&group->rb, parent, p);\n 319: \t\trb_insert_color(&group->rb, &this->group_map);\n 320: \t}\n 321: \n 322: \tpthread_mutex_lock(&group->mutex);\n 323: \tparams->group = group;\n 324: \tthis->recover_one_server(addr);\n 325: \tif (params->server_type == 0)\n 326: \t{\n 327: \t\tgroup->mains.push_back(addr);\n 328: \t\tgroup->weight += params->weight;\n 329: \t}\n 330: \telse\n 331: \t\tgroup->backups.push_back(addr);\n 332: \tpthread_mutex_unlock(&group->mutex);\n 333: }\n 334:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==751==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000015c at pc 0x560e8da6f03e bp 0x7ffdc63abf20 sp 0x7ffdc63abf10\nREAD of size 1 at 0x60200000015c thread T0\n    #0 0x560e8da6f03d in http_decode_url /sourcecode/lib/facil/http/http.c:2391\n    #1 0x560e8d95d81c in fuzzloop /dockerin/fuzz_drivers/tf1729675748915apso.c:29\n    #2 0x560e8dadb289 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x560e8d95cab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fac1dcf6d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fac1dcf6e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x560e8d95cc04 in _start (/dockerin/fuzz_drivers/tf1729675748915apso.out+0x1dac04)\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7fac1e6cf887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x560e8dadb49c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:2391 in http_decode_url\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00[04]fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n// Version: dev-v2.4.5-20241014-c950afb\n// Target: http_decode_url\n// Sign: http_decode_url(char *dest, char *url_data, size_t length)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    size_t length = (size_t)fuzzUint64(2);\n    ssize_t ret = http_decode_url(dest, url_data, length);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2387: ssize_t http_upgrade2ws(char *dest, const char *url_data, size_t length) {\n2388:   char *pos = dest;\n2389:   const char *end = url_data + length;\n2390:   while (url_data < end) {\n2391:     if (*url_data == '+') {\n2392:       // decode space\n2393:       *(pos++) = ' ';\n2394:       ++url_data;\n2395:     } else if (*url_data == '%') {\n2396:       // decode hex value\n2397:       // this is a percent encoded value.\n2398:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2399:         return -1;\n2400:       pos++;\n2401:       url_data += 3;\n2402:     } else\n2403:       *(pos++) = *(url_data++);\n2404:   }\n2405:   *pos = 0;\n2406:   return pos - dest;\n2407: }\n2408:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==46296==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000004ffc at pc 0x7f30d1fd1397 bp 0x7ffe3d8b39b0 sp 0x7ffe3d8b3158\nREAD of size 65535 at 0x602000004ffc thread T0\n    #0 0x7f30d1fd1396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x7f30d13e0dfb in ASN1_STRING_set crypto/asn1/asn1_lib.c:323\n    #2 0x7f30d19d998c in X509_ATTRIBUTE_set1_data crypto/x509/x509_att.c:365\n    #3 0x7f30d19d9511 in X509_ATTRIBUTE_create_by_OBJ crypto/x509/x509_att.c:303\n    #4 0x7f30d19d93b1 in X509_ATTRIBUTE_create_by_NID crypto/x509/x509_att.c:279\n    #5 0x7f30d19d8cf5 in ossl_x509at_add1_attr_by_NID crypto/x509/x509_att.c:178\n    #6 0x7f30d19d8e8c in X509at_add1_attr_by_NID crypto/x509/x509_att.c:201\n    #7 0x7f30d19d77cc in X509_ACERT_add1_attr_by_NID crypto/x509/x509_acert.c:238\n    #8 0x55d5d89a447c in fuzzloop /dockerin/fuzz_drivers/tf1730183724668yxhp.c:31\n    #9 0x55d5d89aca79 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x55d5d89a41e8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7f30d0a8fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7f30d0a8fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x55d5d89a4334 in _start (/dockerin/fuzz_drivers/tf1730183724668yxhp.out+0xe334)\n\n0x602000004ffc is located 0 bytes to the right of 12-byte region [0x602000004ff0,0x602000004ffc)\nallocated by thread T0 here:\n    #0 0x7f30d204b887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55d5d89acc8c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff89a0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff89b0: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa fd fa\n  0x0c047fff89c0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa 00 04\n  0x0c047fff89d0: fa fa 00 04 fa fa 00 04 fa fa fd fa fa fa fd fa\n  0x0c047fff89e0: fa fa fd fd fa fa fd fa fa fa 00 04 fa fa 00 04\n=>0x0c047fff89f0: fa fa 00 04 fa fa 04 fa fa fa 04 fa fa fa 00[04]\n  0x0c047fff8a00: fa fa 04 fa fa fa 00 00 fa fa fa fa fa fa fa fa\n  0x0c047fff8a10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8a20: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8a30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8a40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:23:48\n// Signature: X509_ACERT_add1_attr_by_NID(X509_ACERT *x, int nid, int type, void *bytes, int len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: X509_ACERT_add1_attr_by_NID\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto/x509 -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <string.h> //extract\n#include <crypto/ctype.h> //extract\n#include <openssl/asn1t.h> //extract\n#include <openssl/err.h> //extract\n#include <openssl/x509.h> //extract\n#include <openssl/x509v3.h> //extract\n#include \"x509_acert.h\" //extract\n\nint fuzzloop() {\n    X509_ACERT * x = X509_ACERT_new();\n    if (x == NULL)\n        return 0;\n    int nid = fuzzInt32(0);\n    int type = fuzzInt32(1);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * bytes = (void *)fuzzData(2);\n    int len = fuzzInt32(3);\n    int ret = X509_ACERT_add1_attr_by_NID(x, nid, type, bytes, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/asn1/asn1_lib.c\n 286: int ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len_in)\n 287: {\n 288:     unsigned char *c;\n 289:     const char *data = _data;\n 290:     size_t len;\n 291: \n 292:     if (len_in < 0) {\n 293:         if (data == NULL)\n 294:             return 0;\n 295:         len = strlen(data);\n 296:     } else {\n 297:         len = (size_t)len_in;\n 298:     }\n 299:     /*\n 300:      * Verify that the length fits within an integer for assignment to\n 301:      * str->length below.  The additional 1 is subtracted to allow for the\n 302:      * '\\0' terminator even though this isn't strictly necessary.\n 303:      */\n 304:     if (len > INT_MAX - 1) {\n 305:         ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);\n 306:         return 0;\n 307:     }\n 308:     if ((size_t)str->length <= len || str->data == NULL) {\n 309:         c = str->data;\n 310: #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n 311:         /* No NUL terminator in fuzzing builds */\n 312:         str->data = OPENSSL_realloc(c, len != 0 ? len : 1);\n 313: #else\n 314:         str->data = OPENSSL_realloc(c, len + 1);\n 315: #endif\n 316:         if (str->data == NULL) {\n 317:             str->data = c;\n 318:             return 0;\n 319:         }\n 320:     }\n 321:     str->length = len;\n 322:     if (data != NULL) {\n 323:         memcpy(str->data, data, len);\n 324: #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n 325:         /* Set the unused byte to something non NUL and printable. */\n 326:         if (len == 0)\n 327:             str->data[len] = '~';\n 328: #else\n 329:         /*\n 330:          * Add a NUL terminator. This should not be necessary - but we add it as\n 331:          * a safety precaution\n 332:          */\n 333:         str->data[len] = '\\0';\n 334: #endif\n 335:     }\n 336:     return 1;\n 337: }\n 338: \nStacktrace #1:\nFile: /sourcecode/crypto/x509/x509_att.c\n 344: int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,\n 345:                              const void *data, int len)\n 346: {\n 347:     ASN1_TYPE *ttmp = NULL;\n 348:     ASN1_STRING *stmp = NULL;\n 349:     int atype = 0;\n 350: \n 351:     if (attr == NULL) {\n 352:         ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);\n 353:         return 0;\n 354:     }\n 355:     if ((attrtype & MBSTRING_FLAG) != 0) {\n 356:         stmp = ASN1_STRING_set_by_NID(NULL, data, len, attrtype,\n 357:                                       OBJ_obj2nid(attr->object));\n 358:         if (stmp == NULL) {\n 359:             ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);\n 360:             return 0;\n 361:         }\n 362:         atype = stmp->type;\n 363:     } else if (len != -1) {\n 364:         if ((stmp = ASN1_STRING_type_new(attrtype)) == NULL\n 365:             || !ASN1_STRING_set(stmp, data, len)) {\n 366:             ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);\n 367:             goto err;\n 368:         }\n 369:         atype = attrtype;\n 370:     }\n 371:     /*\n 372:      * This is a bit naughty because the attribute should really have at\n 373:      * least one value but some types use and zero length SET and require\n 374:      * this.\n 375:      */\n 376:     if (attrtype == 0) {\n 377:         ASN1_STRING_free(stmp);\n 378:         return 1;\n 379:     }\n 380:     if ((ttmp = ASN1_TYPE_new()) == NULL) {\n 381:         ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);\n 382:         goto err;\n 383:     }\n 384:     if (len == -1 && (attrtype & MBSTRING_FLAG) == 0) {\n 385:         if (!ASN1_TYPE_set1(ttmp, attrtype, data)) {\n 386:             ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);\n 387:             goto err;\n 388:         }\n 389:     } else {\n 390:         ASN1_TYPE_set(ttmp, atype, stmp);\n 391:         stmp = NULL;\n 392:     }\n 393:     if (!sk_ASN1_TYPE_push(attr->set, ttmp)) {\n 394:         ERR_raise(ERR_LIB_X509, ERR_R_CRYPTO_LIB);\n 395:         goto err;\n 396:     }\n 397:     return 1;\n 398:  err:\n 399:     ASN1_TYPE_free(ttmp);\n 400:     ASN1_STRING_free(stmp);\n 401:     return 0;\n 402: }\n 403: \nStacktrace #2:\nFile: /sourcecode/crypto/x509/x509_att.c\n 285: X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,\n 286:                                              const ASN1_OBJECT *obj,\n 287:                                              int atrtype, const void *data,\n 288:                                              int len)\n 289: {\n 290:     X509_ATTRIBUTE *ret;\n 291: \n 292:     if (attr == NULL || *attr == NULL) {\n 293:         if ((ret = X509_ATTRIBUTE_new()) == NULL) {\n 294:             ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);\n 295:             return NULL;\n 296:         }\n 297:     } else {\n 298:         ret = *attr;\n 299:     }\n 300: \n 301:     if (!X509_ATTRIBUTE_set1_object(ret, obj))\n 302:         goto err;\n 303:     if (!X509_ATTRIBUTE_set1_data(ret, atrtype, data, len))\n 304:         goto err;\n 305: \n 306:     if (attr != NULL && *attr == NULL)\n 307:         *attr = ret;\n 308:     return ret;\n 309:  err:\n 310:     if (attr == NULL || ret != *attr)\n 311:         X509_ATTRIBUTE_free(ret);\n 312:     return NULL;\n 313: }\n 314: \nStacktrace #3:\nFile: /sourcecode/crypto/x509/x509_att.c\n 268: X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,\n 269:                                              int atrtype, const void *data,\n 270:                                              int len)\n 271: {\n 272:     ASN1_OBJECT *obj = OBJ_nid2obj(nid);\n 273:     X509_ATTRIBUTE *ret;\n 274: \n 275:     if (obj == NULL) {\n 276:         ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_NID);\n 277:         return NULL;\n 278:     }\n 279:     ret = X509_ATTRIBUTE_create_by_OBJ(attr, obj, atrtype, data, len);\n 280:     if (ret == NULL)\n 281:         ASN1_OBJECT_free(obj);\n 282:     return ret;\n 283: }\n 284: \nStacktrace #4:\nFile: /sourcecode/crypto/x509/x509_att.c\n 170: STACK_OF(X509_ATTRIBUTE) *ossl_x509at_add1_attr_by_NID(STACK_OF(X509_ATTRIBUTE) **x,\n 171:                                                        int nid, int type,\n 172:                                                        const unsigned char *bytes,\n 173:                                                        int len)\n 174: {\n 175:     X509_ATTRIBUTE *attr;\n 176:     STACK_OF(X509_ATTRIBUTE) *ret;\n 177: \n 178:     attr = X509_ATTRIBUTE_create_by_NID(NULL, nid, type, bytes, len);\n 179:     if (attr == NULL)\n 180:         return 0;\n 181:     ret = ossl_x509at_add1_attr(x, attr);\n 182:     X509_ATTRIBUTE_free(attr);\n 183:     return ret;\n 184: }\n 185: \nStacktrace #5:\nFile: /sourcecode/crypto/x509/x509_att.c\n 186: STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr_by_NID(STACK_OF(X509_ATTRIBUTE)\n 187:                                                   **x, int nid, int type,\n 188:                                                   const unsigned char *bytes,\n 189:                                                   int len)\n 190: {\n 191:     if (x == NULL) {\n 192:         ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);\n 193:         return NULL;\n 194:     }\n 195:     if (*x != NULL && X509at_get_attr_by_NID(*x, nid, -1) != -1) {\n 196:         ERR_raise_data(ERR_LIB_X509, X509_R_DUPLICATE_ATTRIBUTE,\n 197:                        \"name=%s\", OBJ_nid2sn(nid));\n 198:         return NULL;\n 199:     }\n 200: \n 201:     return ossl_x509at_add1_attr_by_NID(x, nid, type, bytes, len);\n 202: }\n 203: \nStacktrace #6:\nFile: /sourcecode/crypto/x509/x509_acert.c\n 233: int X509_ACERT_add1_attr_by_NID(X509_ACERT *x, int nid, int type,\n 234:                                 const void *bytes, int len)\n 235: {\n 236:     STACK_OF(X509_ATTRIBUTE) **attrs = &x->acinfo->attributes;\n 237: \n 238:     return X509at_add1_attr_by_NID(attrs, nid, type, bytes, len) != NULL;\n 239: }\n 240:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==172==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000a81a at pc 0x55f80eff3f66 bp 0x7ffe2fb91070 sp 0x7ffe2fb91060\nREAD of size 1 at 0x60200000a81a thread T0\n    #0 0x55f80eff3f65 in fio_atol_consume_hex /sourcecode/lib/facil/fio.c:4699\n    #1 0x55f80eff55da in fio_atol /sourcecode/lib/facil/fio.c:4776\n    #2 0x55f80efa4c47 in fio_json_parse /sourcecode/lib/facil/fiobj/fio_json_parser.h:453\n    #3 0x55f80efb334c in fiobj_json2obj /sourcecode/lib/facil/fiobj/fiobj_json.c:379\n    #4 0x55f80ef9e3be in fuzzloop /sharedockerin/ta1730101611730qass/test_file.c:19\n    #5 0x55f80f0a3cb9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55f80ef9da98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f9eec816d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f9eec816e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55f80ef9dbe4 in _start (/sharedockerin/ta1730101611730qass/clouditera+0x134be4)\n\n0x60200000a81a is located 0 bytes to the right of 10-byte region [0x60200000a810,0x60200000a81a)\nallocated by thread T0 here:\n    #0 0x7f9eed1ef887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f80f0a3ecc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:4699 in fio_atol_consume_hex\nShadow bytes around the buggy address:\n  0x0c047fff94b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff94c0: fa fa 00 00 fa fa 03 fa fa fa 00 07 fa fa fd fa\n  0x0c047fff94d0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff94e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff94f0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n=>0x0c047fff9500: fa fa 00[02]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9510: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9520: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9530: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9540: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9550: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:04:53\n// Signature: fiobj_json2obj(FIOBJ *pobj, void *data, size_t len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_json2obj\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_json.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FIOBJ obj;\n    char *data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    fiobj_json2obj(&obj, data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4694: FIO_FUNC inline uint64_t fio_atol_consume_hex(char **pstr) {\n4695:   uint64_t result = 0;\n4696:   const uint64_t limit = UINT64_MAX - (16 * 16);\n4697:   for (; result <= limit;) {\n4698:     uint8_t tmp;\n4699:     if (**pstr >= '0' && **pstr <= '9')\n4700:       tmp = **pstr - '0';\n4701:     else if (**pstr >= 'A' && **pstr <= 'F')\n4702:       tmp = **pstr - ('A' - 10);\n4703:     else if (**pstr >= 'a' && **pstr <= 'f')\n4704:       tmp = **pstr - ('a' - 10);\n4705:     else\n4706:       return result;\n4707:     result = (result << 4) | tmp;\n4708:     ++(*pstr);\n4709:   }\n4710:   return result;\n4711: }\n4712: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n4742: int64_t fio_atol(char **pstr) {\n4743:   /* No binary representation in strtol */\n4744:   char *str = *pstr;\n4745:   uint64_t result = 0;\n4746:   uint8_t invert = 0;\n4747:   while (isspace(*str))\n4748:     ++(str);\n4749:   if (str[0] == '-') {\n4750:     invert ^= 1;\n4751:     ++str;\n4752:   } else if (*str == '+') {\n4753:     ++(str);\n4754:   }\n4755: \n4756:   if (str[0] == 'B' || str[0] == 'b' ||\n4757:       (str[0] == '0' && (str[1] == 'b' || str[1] == 'B'))) {\n4758:     /* base 2 */\n4759:     if (str[0] == '0')\n4760:       str++;\n4761:     str++;\n4762:     fio_atol_skip_zero(&str);\n4763:     while (str[0] == '0' || str[0] == '1') {\n4764:       result = (result << 1) | (str[0] - '0');\n4765:       str++;\n4766:     }\n4767:     goto sign; /* no overlow protection, since sign might be embedded */\n4768: \n4769:   } else if (str[0] == 'x' || str[0] == 'X' ||\n4770:              (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))) {\n4771:     /* base 16 */\n4772:     if (str[0] == '0')\n4773:       str++;\n4774:     str++;\n4775:     fio_atol_skip_zero(&str);\n4776:     result = fio_atol_consume_hex(&str);\n4777:     if (fio_atol_skip_hex_test(&str)) /* too large for a number */\n4778:       return 0;\n4779:     goto sign; /* no overlow protection, since sign might be embedded */\n4780:   } else if (str[0] == '0') {\n4781:     fio_atol_skip_zero(&str);\n4782:     /* base 8 */\n4783:     result = fio_atol_consume(&str, 8);\n4784:     if (fio_atol_skip_test(&str, 8)) /* too large for a number */\n4785:       return 0;\n4786:   } else {\n4787:     /* base 10 */\n4788:     result = fio_atol_consume(&str, 10);\n4789:     if (fio_atol_skip_test(&str, 10)) /* too large for a number */\n4790:       return 0;\n4791:   }\n4792:   if (result & ((uint64_t)1 << 63))\n4793:     result = INT64_MAX; /* signed overflow protection */\n4794: sign:\n4795:   if (invert)\n4796:     result = 0 - result;\n4797:   *pstr = str;\n4798:   return (int64_t)result;\n4799: }\n4800: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fiobj/fio_json_parser.h\n 310: static size_t __attribute__((unused))\n 311: fio_json_parse(json_parser_s *parser, const char *buffer, size_t length) {\n 312:   if (!length || !buffer)\n 313:     return 0;\n 314:   uint8_t *pos = (uint8_t *)buffer;\n 315:   const uint8_t *limit = pos + length;\n 316:   do {\n 317:     while (pos < limit && JSON_SEPERATOR[*pos])\n 318:       ++pos;\n 319:     if (pos == limit)\n 320:       goto stop;\n 321:     switch (*pos) {\n 322:     case '\"': {\n 323:       uint8_t *tmp = pos + 1;\n 324:       if (seek2eos(&tmp, limit) == 0)\n 325:         goto stop;\n 326:       if (parser->key) {\n 327:         uint8_t *key = tmp + 1;\n 328:         while (key < limit && JSON_SEPERATOR[*key])\n 329:           ++key;\n 330:         if (key >= limit)\n 331:           goto stop;\n 332:         if (*key != ':')\n 333:           goto error;\n 334:         ++pos;\n 335:         fio_json_on_string(parser, pos, (uintptr_t)(tmp - pos));\n 336:         pos = key + 1;\n 337:         parser->key = 0;\n 338:         continue; /* skip tests */\n 339:       } else {\n...skip...\n 423:       break;\n 424:     case 'f':\n 425:       if (pos + 4 >= limit)\n 426:         goto stop;\n 427:       if (pos + 4 < limit && pos[1] == 'a' && pos[2] == 'l' && pos[3] == 's' &&\n 428:           pos[4] == 'e')\n 429:         fio_json_on_false(parser);\n 430:       else\n 431:         goto error;\n 432:       pos += 5;\n 433:       break;\n 434:     case '-': /* overflow */\n 435:     case '0': /* overflow */\n 436:     case '1': /* overflow */\n 437:     case '2': /* overflow */\n 438:     case '3': /* overflow */\n 439:     case '4': /* overflow */\n 440:     case '5': /* overflow */\n 441:     case '6': /* overflow */\n 442:     case '7': /* overflow */\n 443:     case '8': /* overflow */\n 444:     case '9': /* overflow */\n 445:     case '.': /* overflow */\n 446:     case 'e': /* overflow */\n 447:     case 'E': /* overflow */\n 448:     case 'x': /* overflow */\n 449:     case 'i': /* overflow */\n 450:     case 'I': /* overflow */\n 451:     numeral : {\n 452:       uint8_t *tmp = pos;\n 453:       long long i = fio_atol((char **)&tmp);\n 454:       if (tmp > limit)\n 455:         goto stop;\n 456:       if (!tmp || JSON_NUMERAL[*tmp]) {\n 457:         tmp = pos;\n 458:         double f = fio_atof((char **)&tmp);\n 459:         if (tmp > limit)\n 460:           goto stop;\n 461:         if (!tmp || JSON_NUMERAL[*tmp])\n 462:           goto error;\n 463:         fio_json_on_float(parser, f);\n 464:         pos = tmp;\n 465:       } else {\n 466:         fio_json_on_number(parser, i);\n 467:         pos = tmp;\n 468:       }\n 469:       break;\n 470:     }\n 471:     case '#': /* Ruby style comment */\n 472:     {\n 473:       uint8_t *tmp = memchr(pos, '\\n', (uintptr_t)(limit - pos));\n 474:       if (!tmp)\n 475:         goto stop;\n 476:       pos = tmp + 1;\n 477:       continue; /* skip tests */\n 478:       ;\n 479:     }\n 480:     case '/': /* C style / Javascript style comment */\n 481:       if (pos[1] == '*') {\n 482:         if (pos + 4 > limit)\n...skip...\n 486:           tmp = memchr(tmp, '/', (uintptr_t)(limit - tmp));\n 487:         } while (tmp && tmp[-1] != '*');\n 488:         if (!tmp)\n 489:           goto stop;\n 490:         pos = tmp + 1;\n 491:       } else if (pos[1] == '/') {\n 492:         uint8_t *tmp = memchr(pos, '\\n', (uintptr_t)(limit - pos));\n 493:         if (!tmp)\n 494:           goto stop;\n 495:         pos = tmp + 1;\n 496:       } else\n 497:         goto error;\n 498:       continue; /* skip tests */\n 499:       ;\n 500:     default:\n 501:       goto error;\n 502:     }\n 503:     if (parser->depth == 0) {\n 504:       fio_json_on_json(parser);\n 505:       goto stop;\n 506:     }\n 507:     parser->key = (parser->dict & 1);\n 508:   } while (pos < limit);\n 509: stop:\n 510:   return (size_t)((uintptr_t)pos - (uintptr_t)buffer);\n 511: error:\n 512:   fio_json_on_error(parser);\n 513:   return 0;\n 514: }\n 515: \nStacktrace #3:\nFile: /sourcecode/lib/facil/fiobj/fiobj_json.c\n 377: size_t fiobj_json2obj(FIOBJ *pobj, const void *data, size_t len) {\n 378:   fiobj_json_parser_s p = {.top = FIOBJ_INVALID};\n 379:   size_t consumed = fio_json_parse(&p.p, data, len);\n 380:   if (!consumed || p.p.depth) {\n 381:     fiobj_free(fio_json_stack_get(&p.stack, 0));\n 382:     p.top = FIOBJ_INVALID;\n 383:   }\n 384:   fio_json_stack_free(&p.stack);\n 385:   fiobj_free(p.key);\n 386:   *pobj = p.top;\n 387:   return consumed;\n 388: }\n 389:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==880==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x7fb2bce5ab39 bp 0x7ffc422f15e0 sp 0x7ffc422f0d88\nREAD of size 13 at 0x60200000011c thread T0\n    #0 0x7fb2bce5ab38 in __interceptor_getaddrinfo ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:2594\n    #1 0x55661e9729b9 in fio_local_addr /sourcecode/lib/facil/fio.c:657\n    #2 0x55661e95626e in fuzzloop /dockerin/fuzz_drivers/tf1729822402978oeyf.c:38\n    #3 0x55661ea05e49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55661e9559d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fb2bc4a8d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fb2bc4a8e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55661e955b24 in _start (/dockerin/fuzz_drivers/tf1729822402978oeyf.out+0xc5b24)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fb2bce81887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55661ea0605c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:2594 in __interceptor_getaddrinfo\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_local_addr(char *dest, size_t limit)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_local_addr\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    size_t limit = (size_t)fuzzUint64(1);\n    size_t ret = fio_local_addr(dest, limit);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n 647: size_t fio_local_addr(char *dest, size_t limit) {\n 648:   if (gethostname(dest, limit))\n 649:     return 0;\n 650: \n 651:   struct addrinfo hints, *info;\n 652:   memset(&hints, 0, sizeof hints);\n 653:   hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6\n 654:   hints.ai_socktype = SOCK_STREAM; // TCP stream sockets\n 655:   hints.ai_flags = AI_CANONNAME;   // get cannonical name\n 656: \n 657:   if (getaddrinfo(dest, \"http\", &hints, &info) != 0)\n 658:     return 0;\n 659: \n 660:   for (struct addrinfo *pos = info; pos; pos = pos->ai_next) {\n 661:     if (pos->ai_canonname) {\n 662:       size_t len = strlen(pos->ai_canonname);\n 663:       if (len >= limit)\n 664:         len = limit - 1;\n 665:       memcpy(dest, pos->ai_canonname, len);\n 666:       dest[len] = 0;\n 667:       freeaddrinfo(info);\n 668:       return len;\n 669:     }\n 670:   }\n 671: \n 672:   freeaddrinfo(info);\n 673:   return 0;\n 674: }\n 675:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==152624==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x56501661c04f bp 0x7ffce95223d0 sp 0x7ffce95223c0\nREAD of size 8 at 0x602000000120 thread T0\n    #0 0x56501661c04e in rb_first /sourcecode/src/kernel/rbtree.c:306\n    #1 0x565016616666 in fuzzloop /dockerin/fuzz_drivers/tf1729594883504dqsh.cpp:18\n    #2 0x565016625ad9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x565016616348 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fb53ebc5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fb53ebc5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x565016616494 in _start (/dockerin/fuzz_drivers/tf1729594883504dqsh.out+0x17494)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fb53f7ec887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x565016625cec in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/rbtree.c:306 in rb_first\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 11:00:08\n// Signature: rb_first(struct rb_root *root)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: rb_first\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/rbtree.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    struct rb_root root = RB_ROOT;\n    struct rb_node *node = (struct rb_node *)fuzzData(0);\n    root.rb_node = node;\n    rb_first(&root);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/rbtree.c\n 299: struct rb_node *rb_first(struct rb_root *root)\n 300: {\n 301: \tstruct rb_node *n;\n 302: \n 303: \tn = root->rb_node;\n 304: \tif (!n)\n 305: \t\treturn (struct rb_node *)0;\n 306: \twhile (n->rb_left)\n 307: \t\tn = n->rb_left;\n 308: \treturn n;\n 309: }\n 310:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4958==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000001e0 at pc 0x557d426bb8a5 bp 0x7ffe8acf0c20 sp 0x7ffe8acf0c10\nREAD of size 2 at 0x6020000001e0 thread T0\n    #0 0x557d426bb8a4 in value_hash_function /sourcecode/src/compiler/hash_tables/value_set.c:11\n    #1 0x557d426bd49d in ht_remove /sourcecode/external/hash/hash_table_impl.h:199\n    #2 0x557d426bbe61 in fb_value_set_remove /sourcecode/src/compiler/hash_tables/value_set.c:26\n    #3 0x557d426af82e in fuzzloop /dockerin/fuzz_drivers/tf1727601035308xcel.c:36\n    #4 0x557d426c64c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x557d426a3548 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fa7170cdd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fa7170cde3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x557d426a3694 in _start (/dockerin/fuzz_drivers/tf1727601035308xcel.out+0x27694)\n\n0x6020000001e0 is located 4 bytes to the right of 12-byte region [0x6020000001d0,0x6020000001dc)\nallocated by thread T0 here:\n    #0 0x7fa717aa6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x557d426c66dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/hash_tables/value_set.c:11 in value_hash_function\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 fa\n=>0x0c047fff8030: fa fa 00 fa fa fa 00 04 fa fa 00 04[fa]fa 00 fa\n  0x0c047fff8040: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler/hash_tables -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: fb_value_set_remove\n// Sign: fb_value_set_remove(fb_value_set_t *ht, void *key, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../symbols.h\" //extract\n#include \"hash/ht_hash_function.h\" //extract\n#include \"external/hash/hash_table.h\" //autogen\n#include \"src/compiler/symbols.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //file: external/hash/hash_table.h:63\n    //struct hash_table {\n    //    void *table;\n    //    char *offsets;\n    //    size_t count;\n    //    /* May be stored as a direct count, or log2. */\n    //    size_t buckets;\n    //};\n    struct hash_table *ht = (struct hash_table *)driverAllocMem(sizeof(struct hash_table));\n    ht->table = (void *)fuzzData(0);\n    ht->offsets = fuzzString(1);\n    ht->buckets = (unsigned long)fuzzUint64(2);\n    \n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * key = (void *)fuzzData(3);\n    size_t len = (size_t)fuzzUint64(4);\n    fb_value_t * ret = fb_value_set_remove(ht, key, len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/hash_tables/value_set.c\n   5: static size_t value_hash_function(const void *key, size_t key_len)\n   6: {\n   7:     const fb_value_t *value = key;\n   8: \n   9:     (void)key_len;\n  10: \n  11:     switch (value->type) {\n  12:     case vt_int:\n  13:         return ht_int_hash_function((void *)(size_t)(value->i ^ value->type), sizeof(value->i));\n  14:     case vt_uint:\n  15:         return ht_int_hash_function((void *)(size_t)(value->u ^ value->type), sizeof(value->u));\n  16:     case vt_bool:\n  17:         return ht_int_hash_function((void *)(size_t)(value->b ^ value->type), sizeof(value->b));\n  18:     default:\n  19:         return 0;\n  20:     }\n  21: }\n  22: \nStacktrace #1:\nFile: /sourcecode/external/hash/hash_table_impl.h\n 189: static ht_item_t ht_remove(hash_table_t *ht, const void *key, size_t len)\n 190: {\n 191:     ht_item_t *T = ht->table;\n 192:     size_t N, i, j, k;\n 193:     ht_item_t item;\n 194: \n 195:     if (T == 0) {\n 196:         return 0;\n 197:     }\n 198:     N = ht->buckets - 1;\n 199:     k = HT_HASH_FUNCTION(key, len);\n 200:     i = 0;\n 201:     j = HT_PROBE(k, i, N);\n 202:     while ((item = T[j])) {\n 203:         if (item != HT_DELETED &&\n 204:                 ht_match(key, len, item)) {\n 205:             T[j] = HT_DELETED;\n 206:             --ht->count;\n 207:             return item;\n 208:         }\n 209:         ++i;\n 210:         j = HT_PROBE(k, i, N);\n 211:     }\n 212:     return 0;\n 213: }\n 214: \nStacktrace #2:\nFile: /sourcecode/src/compiler/hash_tables/value_set.c\n  26: DEFINE_HASH_TABLE(fb_value_set)\n  27:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==309==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000004bb8 at pc 0x55b9b0b38ed8 bp 0x7ffd4ca58240 sp 0x7ffd4ca58230\nREAD of size 8 at 0x602000004bb8 thread T0\n    #0 0x55b9b0b38ed7 in uint8korr /sourcecode/src/protocol/mysql_byteorder.h:58\n    #1 0x55b9b0b39742 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:61\n    #2 0x55b9b0b39909 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x55b9b0b340a8 in parse_ok_packet /sourcecode/src/protocol/mysql_parser.c:207\n    #4 0x55b9b0b3296a in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x55b9b0b31703 in fuzzloop /sharedockerin/ta1729664331306rwdc/test_file.cpp:21\n    #6 0x55b9b0b422c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55b9b0b313e8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7fc1c2daad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7fc1c2daae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55b9b0b31534 in _start (/sharedockerin/ta1729664331306rwdc/clouditera+0x18534)\n\n0x602000004bbf is located 0 bytes to the right of 15-byte region [0x602000004bb0,0x602000004bbf)\nallocated by thread T0 here:\n    #0 0x7fc1c39d1887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55b9b0b424dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_byteorder.h:58 in uint8korr\nShadow bytes around the buggy address:\n  0x0c047fff8920: fa fa fd fa fa fa 00 00 fa fa 00 04 fa fa fd fa\n  0x0c047fff8930: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fd\n  0x0c047fff8940: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8950: fa fa fa fa fa fa fd fa fa fa fd fa fa fa fd fd\n  0x0c047fff8960: fa fa fd fd fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8970: fa fa fa fa fa fa 00[07]fa fa fa fa fa fa fd fa\n  0x0c047fff8980: fa fa fa fa fa fa fd fa fa fa fd fd fa fa fd fd\n  0x0c047fff8990: fa fa fa fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff89a0: fa fa fd fd fa fa fd fd fa fa fa fa fa fa fd fa\n  0x0c047fff89b0: fa fa fd fa fa fa fa fa fa fa fd fa fa fa fd fa\n  0x0c047fff89c0: fa fa fd fa fa fa fd fd fa fa fa fa fa fa fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 11:01:23\n// Signature: mysql_parser_parse(void *buf, size_t len, mysql_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: mysql_parser_parse\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/mysql_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    mysql_parser_t parser;\n    mysql_parser_init(&parser);\n\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n\n    mysql_parser_parse(buf, len, &parser);\n\n    mysql_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  56: static inline uint64_t uint8korr(const unsigned char *A)\n  57: {\n  58: \tuint64_t ret;\n  59: \tmemcpy(&ret, A, sizeof(ret));\n  60: \treturn ret;\n  61: }\n  62: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 179: static int parse_ok_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 180: {\n 181: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 182: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 183: \n 184: \tunsigned long long affected_rows, insert_id, info_len;\n 185: \tconst unsigned char *str;\n 186: \tstruct __mysql_result_set *result_set;\n 187: \tunsigned int warning_count;\n 188: \tint server_status;\n 189: \n 190: \tp += 1;// 0x00\n 191: \tif (decode_length_safe(&affected_rows, &p, buf_end) <= 0)\n 192: \t\treturn -2;\n 193: \n 194: \tif (decode_length_safe(&insert_id, &p, buf_end) <= 0)\n 195: \t\treturn -2;\n 196: \n 197: \tif (p + 4 > buf_end)\n 198: \t\treturn -2;\n 199: \n 200: \tserver_status = uint2korr(p);\n 201: \tp += 2;\n 202: \twarning_count = uint2korr(p);\n 203: \tp += 2;\n 204: \n 205: \tif (p != buf_end)\n 206: \t{\n 207: \t\tif (decode_string(&str, &info_len, &p, buf_end) == 0)\n 208: \t\t\treturn -2;\n 209: \n 210: \t\tif (p != buf_end)\n 211: \t\t{\n 212: \t\t\tif (server_status & MYSQL_SERVER_SESSION_STATE_CHANGED)\n 213: \t\t\t{\n 214: \t\t\t\tconst unsigned char *tmp_str;\n 215: \t\t\t\tunsigned long long tmp_len;\n 216: \t\t\t\tif (decode_string(&tmp_str, &tmp_len, &p, buf_end) == 0)\n 217: \t\t\t\t\treturn -2;\n 218: \t\t\t} else\n 219: \t\t\t\treturn -2;\n 220: \t\t}\n 221: \t} else {\n 222: \t\tstr = p;\n 223: \t\tinfo_len = 0;\n 224: \t}\n 225: \n 226: \tresult_set = (struct __mysql_result_set *)malloc(sizeof(struct __mysql_result_set));\n 227: \tif (result_set == NULL)\n 228: \t\treturn -1;\n 229: \n 230: \tresult_set->info_offset = str - (const unsigned char *)buf;\n 231: \tresult_set->info_len = info_len;\n 232: \tresult_set->affected_rows = (affected_rows == ~0ULL) ? 0 : affected_rows;\n 233: \tresult_set->insert_id = (insert_id == ~0ULL) ? 0 : insert_id;\n 234: \tresult_set->server_status = server_status;\n 235: \tresult_set->warning_count = warning_count;\n 236: \tresult_set->type = MYSQL_PACKET_OK;\n 237: \tresult_set->field_count = 0;\n 238: \n 239: \tlist_add_tail(&result_set->list, &parser->result_set_list);\n 240: \tparser->current_result_set = result_set;\n 241: \tparser->result_set_count++;\n 242: \tparser->packet_type = MYSQL_PACKET_OK;\n 243: \n 244: \tparser->buf = buf;\n 245: \tparser->offset = p - (const unsigned char *)buf;\n 246: \n 247: \tif (server_status & MYSQL_SERVER_MORE_RESULTS_EXIST)\n 248: \t{\n 249: \t\tparser->parse = parse_base_packet;\n 250: \t\treturn 0;\n 251: \t}\n 252: \n 253: \treturn 1;\n 254: }\n 255: \nStacktrace #4:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3571==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000138 at pc 0x562337f74b6d bp 0x7ffc81052cf0 sp 0x7ffc81052ce0\nREAD of size 8 at 0x602000000138 thread T0\n    #0 0x562337f74b6c in http_upgrade2ws /sourcecode/lib/facil/http/http.c:697\n    #1 0x562337e7f92a in fuzzloop /dockerin/fuzz_drivers/tf1729823021368xeeh.c:22\n    #2 0x562337ffe3c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x562337e7eab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fad4091bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fad4091be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x562337e7ec04 in _start (/dockerin/fuzz_drivers/tf1729823021368xeeh.out+0x1dbc04)\n\n0x60200000013c is located 0 bytes to the right of 12-byte region [0x602000000130,0x60200000013c)\nallocated by thread T0 here:\n    #0 0x7fad412f4887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562337ffe5dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:697 in http_upgrade2ws\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00[04]fa fa 00 04 fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:22:13\n// Signature: http_upgrade2ws(http_s *h, websocket_settings_s args)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_upgrade2ws\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/http/http1.h\"\n#include \"lib/facil/http/http.h\" // Include for websocket_settings_s and ws_s\n#include \"lib/facil/fio.h\" // Include for fio_str_info_s\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    http_s *h = (http_s *)fuzzData(0);\n    websocket_settings_s args = {\n        .udata = (void *)fuzzData(1)\n    };\n    http_upgrade2ws(h, .udata = args.udata); // Use the macro version with named arguments\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n 692: int http_upgrade2ws(http_s *h, websocket_settings_s args) {\n 693:   if (!h) {\n 694:     FIO_LOG_ERROR(\"`http_upgrade2ws` requires a valid `http_s` handle.\");\n 695:     goto error;\n 696:   }\n 697:   if (HTTP_INVALID_HANDLE(h))\n 698:     goto error;\n 699:   return ((http_vtable_s *)h->private_data.vtbl)->http2websocket(h, &args);\n 700: error:\n 701:   if (args.on_close)\n 702:     args.on_close(-1, args.udata);\n 703:   return -1;\n 704: }\n 705:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1919==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x5591b9fa96a3 bp 0x7ffcdcf9e1b0 sp 0x7ffcdcf9e1a0\nWRITE of size 8 at 0x602000000120 thread T0\n    #0 0x5591b9fa96a2 in SubTask::set_pointer(void*) (/dockerin/fuzz_drivers/tf1729593940535brpk.out+0x326a2)\n    #1 0x5591b9faca5d in SeriesWork::SeriesWork(SubTask*, std::function<void (SeriesWork const*)>&&) /sourcecode/src/factory/Workflow.cc:37\n    #2 0x5591b9fa9c31 in Workflow::create_series_work(SubTask*, SubTask*, std::function<void (SeriesWork const*)>) (/dockerin/fuzz_drivers/tf1729593940535brpk.out+0x32c31)\n    #3 0x5591b9fa7b11 in fuzzloop /dockerin/fuzz_drivers/tf1729593940535brpk.cpp:18\n    #4 0x5591b9fc2829 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x5591b9fa75c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f55ff692d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f55ff692e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x5591b9fa7714 in _start (/dockerin/fuzz_drivers/tf1729593940535brpk.out+0x30714)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f56002b9887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5591b9fc2a3c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/dockerin/fuzz_drivers/tf1729593940535brpk.out+0x326a2) in SubTask::set_pointer(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa 00 04 fa fa 00 04 fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:38:41\n// Signature: ParallelWork::done()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12ParallelWork4doneEv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/Workflow.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    SubTask* task1 = (SubTask*)fuzzData(0);\n    SubTask* task2 = (SubTask*)fuzzData(1);\n    SeriesWork* series1 = Workflow::create_series_work(task1, task2, nullptr);\n    SeriesWork* series2 = Workflow::create_series_work(task2, task1, nullptr);\n    SeriesWork* series3 = Workflow::create_series_work(task1, task2, nullptr);\n    SeriesWork* series4 = Workflow::create_series_work(task2, task1, nullptr);\n\n    SeriesWork* all_series[] = {series1, series2, series3, series4};\n    ParallelWork* parallel = Workflow::create_parallel_work(all_series, 4, nullptr);\n\n    parallel->set_context((void*)fuzzData(2));\n    parallel->set_callback([](const ParallelWork* p) {\n        const_cast<ParallelWork*>(p)->done();\n    });\n\n    parallel->start();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/factory/Workflow.cc\n  27: SeriesWork::SeriesWork(SubTask *first, series_callback_t&& cb) :\n  28: \tcallback(std::move(cb))\n  29: {\n  30: \tthis->queue = this->buf;\n  31: \tthis->queue_size = sizeof this->buf / sizeof *this->buf;\n  32: \tthis->front = 0;\n  33: \tthis->back = 0;\n  34: \tthis->canceled = false;\n  35: \tthis->finished = false;\n  36: \tassert(!series_of(first));\n  37: \tfirst->set_pointer(this);\n  38: \tthis->first = first;\n  39: \tthis->last = NULL;\n  40: \tthis->context = NULL;\n  41: \tthis->in_parallel = NULL;\n  42: }\n  43:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==28260==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000228 at pc 0x55eafa0d0f82 bp 0x7ffc0e898d70 sp 0x7ffc0e898d60\nREAD of size 4 at 0x602000000228 thread T0\n    #0 0x55eafa0d0f81 in Communicator::accept(sockaddr const*, unsigned int, int, void*) /sourcecode/src/kernel/Communicator.cc:1365\n    #1 0x55eafa0b4ed3 in fuzzloop /dockerin/fuzz_drivers/tf1729593105311lowx.cpp:51\n    #2 0x55eafa10e3c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55eafa0b4b38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f859869dd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f859869de3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55eafa0b4c84 in _start (/dockerin/fuzz_drivers/tf1729593105311lowx.out+0x83c84)\n\n0x602000000228 is located 12 bytes to the right of 12-byte region [0x602000000210,0x60200000021c)\nallocated by thread T0 here:\n    #0 0x7f85992c4887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55eafa10e5dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Communicator.cc:1365 in Communicator::accept(sockaddr const*, unsigned int, int, void*)\nShadow bytes around the buggy address:\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 00\n  0x0c047fff8020: fa fa 00 00 fa fa 00 00 fa fa 00 00 fa fa 04 fa\n  0x0c047fff8030: fa fa 04 fa fa fa 04 fa fa fa 04 fa fa fa 00 04\n=>0x0c047fff8040: fa fa 00 04 fa[fa]fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Communicator::accept(struct sockaddr *addr, socklen_t addrlen, int sockfd, void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator6acceptEPK8sockaddrjiPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include \"/usr/include/x86_64-linux-gnu/bits/socket.h\" //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //file: /usr/include/x86_64-linux-gnu/bits/socket.h:180\n    //struct sockaddr\n    //  {\n    //    __SOCKADDR_COMMON (sa_);\t/* Common data: address family and length.  */\n    //    char sa_data[14];\t\t/* Address data.  */\n    //  };\n    sockaddr *addr = (sockaddr *)driverAllocMem(sizeof(sockaddr));\n    char *temp = fuzzFixBlob(0, sizeof(sockaddr));\n    memcpy(addr, temp, sizeof(addr));\n    unsigned int addrlen = fuzzUint32(1);\n    int sockfd = fuzzInt32(2);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(3);\n    void * ret = Communicator::accept(addr, addrlen, sockfd, context);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1357: void *Communicator::accept(const struct sockaddr *addr, socklen_t addrlen,\n1358: \t\t\t\t\t\t   int sockfd, void *context)\n1359: {\n1360: \tCommService *service = (CommService *)context;\n1361: \tCommServiceTarget *target = new CommServiceTarget;\n1362: \n1363: \tif (target)\n1364: \t{\n1365: \t\tif (target->init(addr, addrlen, 0, service->response_timeout) >= 0)\n1366: \t\t{\n1367: \t\t\tservice->incref();\n1368: \t\t\ttarget->service = service;\n1369: \t\t\ttarget->sockfd = sockfd;\n1370: \t\t\ttarget->ref = 1;\n1371: \t\t\treturn target;\n1372: \t\t}\n1373: \n1374: \t\tdelete target;\n1375: \t}\n1376: \n1377: \tclose(sockfd);\n1378: \treturn NULL;\n1379: }\n1380:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==267897==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000158 at pc 0x5598b42f6584 bp 0x7fffb5e2af30 sp 0x7fffb5e2af20\nREAD of size 8 at 0x602000000158 thread T0\n    #0 0x5598b42f6583 in Executor::request(ExecSession*, ExecQueue*) /sourcecode/src/kernel/Executor.cc:132\n    #1 0x5598b42f02ac in ExecRequest::dispatch() (/dockerin/fuzz_drivers/tf1729655213129bbmt.out+0x442ac)\n    #2 0x5598b42f0c5c in Workflow::start_series_work(SubTask*, std::function<void (SeriesWork const*)>) (/dockerin/fuzz_drivers/tf1729655213129bbmt.out+0x44c5c)\n    #3 0x5598b42f0df8 in WFGoTask::start() (/dockerin/fuzz_drivers/tf1729655213129bbmt.out+0x44df8)\n    #4 0x5598b42ede89 in fuzzloop /dockerin/fuzz_drivers/tf1729655213129bbmt.cpp:40\n    #5 0x5598b4312539 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x5598b42ed818 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7ff166957d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7ff166957e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x5598b42ed964 in _start (/dockerin/fuzz_drivers/tf1729655213129bbmt.out+0x41964)\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7ff16757e887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5598b431274c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Executor.cc:132 in Executor::request(ExecSession*, ExecQueue*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00[04]fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:48\n// Signature: WFGoTask::WFGoTask(ExecQueue *queue, Executor *executor)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8WFGoTaskC1EP9ExecQueueP8Executor\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/WFTask.h\"\n#include \"_include/workflow/ExecRequest.h\"\n#include \"_include/workflow/Executor.h\"\n\n// Derived class to implement the pure virtual functions\nclass WFGoTaskImpl : public WFGoTask\n{\npublic:\n    WFGoTaskImpl(ExecQueue *queue, Executor *executor) : WFGoTask(queue, executor) {}\n\nprotected:\n    virtual void execute() override {\n        // Implement the execute function\n    }\n\n    virtual void handle(int state, int error) override {\n        // Implement the handle function\n    }\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    ExecQueue *queue = reinterpret_cast<ExecQueue*>(fuzzData(0));\n    Executor *executor = reinterpret_cast<Executor*>(fuzzData(1));\n    WFGoTaskImpl task(queue, executor);\n    task.user_data = fuzzData(2);\n    task.set_callback([&](WFGoTask *t) {\n        // Callback function\n    });\n    task.start();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Executor.cc\n 123: int Executor::request(ExecSession *session, ExecQueue *queue)\n 124: {\n 125: \tstruct ExecSessionEntry *entry;\n 126: \n 127: \tsession->queue = queue;\n 128: \tentry = (struct ExecSessionEntry *)malloc(sizeof (struct ExecSessionEntry));\n 129: \tif (entry)\n 130: \t{\n 131: \t\tentry->session = session;\n 132: \t\tentry->thrdpool = this->thrdpool;\n 133: \t\tpthread_mutex_lock(&queue->mutex);\n 134: \t\tlist_add_tail(&entry->list, &queue->session_list);\n 135: \t\tif (queue->session_list.next == &entry->list)\n 136: \t\t{\n 137: \t\t\tstruct thrdpool_task task = {\n 138: \t\t\t\t.routine\t=\tExecutor::executor_thread_routine,\n 139: \t\t\t\t.context\t=\tqueue\n 140: \t\t\t};\n 141: \t\t\tif (thrdpool_schedule(&task, this->thrdpool) < 0)\n 142: \t\t\t{\n 143: \t\t\t\tlist_del(&entry->list);\n 144: \t\t\t\tfree(entry);\n 145: \t\t\t\tentry = NULL;\n 146: \t\t\t}\n 147: \t\t}\n 148: \n 149: \t\tpthread_mutex_unlock(&queue->mutex);\n 150: \t}\n 151: \n 152: \treturn -!entry;\n 153: }\n 154:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==299==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000003073 at pc 0x55cab905b08b bp 0x7ffe5cc8c080 sp 0x7ffe5cc8c070\nREAD of size 2 at 0x602000003073 thread T0\n    #0 0x55cab905b08a in uint2korr /sourcecode/src/protocol/mysql_byteorder.h:44\n    #1 0x55cab905b828 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:45\n    #2 0x55cab905626d in parse_ok_packet /sourcecode/src/protocol/mysql_parser.c:194\n    #3 0x55cab9054cf5 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #4 0x55cab906b087 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #5 0x55cab8ffd6ae in fuzzloop /sharedockerin/ta1729664328007pfbx/test_file.cpp:19\n    #6 0x55cab90a1929 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55cab8ffd2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7f0f05d35d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7f0f05d35e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55cab8ffd404 in _start (/sharedockerin/ta1729664328007pfbx/clouditera+0x109404)\n\n0x602000003074 is located 0 bytes to the right of 4-byte region [0x602000003070,0x602000003074)\nallocated by thread T0 here:\n    #0 0x7f0f0695c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55cab90a1b3c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_byteorder.h:44 in uint2korr\nShadow bytes around the buggy address:\n  0x0c047fff85b0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fd\n  0x0c047fff85c0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff85d0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff85e0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff85f0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff8600: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[04]fa\n  0x0c047fff8610: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8620: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8630: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8640: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8650: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:02\n// Signature: protocol::MySQLResponse::decode_packet(unsigned char *buf, size_t buflen)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponse13decode_packetEPKhm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n    protocol::MySQLResponse response;\n    response.decode_packet((const unsigned char*)buf, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  42: static inline uint16_t uint2korr(const unsigned char *A)\n  43: {\n  44: \tuint16_t ret;\n  45: \tmemcpy(&ret, A, sizeof(ret));\n  46: \treturn ret;\n  47: }\n  48: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 179: static int parse_ok_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 180: {\n 181: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 182: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 183: \n 184: \tunsigned long long affected_rows, insert_id, info_len;\n 185: \tconst unsigned char *str;\n 186: \tstruct __mysql_result_set *result_set;\n 187: \tunsigned int warning_count;\n 188: \tint server_status;\n 189: \n 190: \tp += 1;// 0x00\n 191: \tif (decode_length_safe(&affected_rows, &p, buf_end) <= 0)\n 192: \t\treturn -2;\n 193: \n 194: \tif (decode_length_safe(&insert_id, &p, buf_end) <= 0)\n 195: \t\treturn -2;\n 196: \n 197: \tif (p + 4 > buf_end)\n 198: \t\treturn -2;\n 199: \n 200: \tserver_status = uint2korr(p);\n 201: \tp += 2;\n 202: \twarning_count = uint2korr(p);\n 203: \tp += 2;\n 204: \n 205: \tif (p != buf_end)\n 206: \t{\n 207: \t\tif (decode_string(&str, &info_len, &p, buf_end) == 0)\n 208: \t\t\treturn -2;\n 209: \n 210: \t\tif (p != buf_end)\n 211: \t\t{\n 212: \t\t\tif (server_status & MYSQL_SERVER_SESSION_STATE_CHANGED)\n 213: \t\t\t{\n 214: \t\t\t\tconst unsigned char *tmp_str;\n 215: \t\t\t\tunsigned long long tmp_len;\n 216: \t\t\t\tif (decode_string(&tmp_str, &tmp_len, &p, buf_end) == 0)\n 217: \t\t\t\t\treturn -2;\n 218: \t\t\t} else\n 219: \t\t\t\treturn -2;\n 220: \t\t}\n 221: \t} else {\n 222: \t\tstr = p;\n 223: \t\tinfo_len = 0;\n 224: \t}\n 225: \n 226: \tresult_set = (struct __mysql_result_set *)malloc(sizeof(struct __mysql_result_set));\n 227: \tif (result_set == NULL)\n 228: \t\treturn -1;\n 229: \n 230: \tresult_set->info_offset = str - (const unsigned char *)buf;\n 231: \tresult_set->info_len = info_len;\n 232: \tresult_set->affected_rows = (affected_rows == ~0ULL) ? 0 : affected_rows;\n 233: \tresult_set->insert_id = (insert_id == ~0ULL) ? 0 : insert_id;\n 234: \tresult_set->server_status = server_status;\n 235: \tresult_set->warning_count = warning_count;\n 236: \tresult_set->type = MYSQL_PACKET_OK;\n 237: \tresult_set->field_count = 0;\n 238: \n 239: \tlist_add_tail(&result_set->list, &parser->result_set_list);\n 240: \tparser->current_result_set = result_set;\n 241: \tparser->result_set_count++;\n 242: \tparser->packet_type = MYSQL_PACKET_OK;\n 243: \n 244: \tparser->buf = buf;\n 245: \tparser->offset = p - (const unsigned char *)buf;\n 246: \n 247: \tif (server_status & MYSQL_SERVER_MORE_RESULTS_EXIST)\n 248: \t{\n 249: \t\tparser->parse = parse_base_packet;\n 250: \t\treturn 0;\n 251: \t}\n 252: \n 253: \treturn 1;\n 254: }\n 255: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #4:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1845==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55dda867d2b5 bp 0x7ffc4927ad80 sp 0x7ffc4927ad70\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x55dda867d2b4 in fio_siphash_xy /sourcecode/lib/facil/fio.c:8339\n    #1 0x55dda867e80e in fio_siphash13 /sourcecode/lib/facil/fio.c:8403\n    #2 0x55dda8602c4a in fuzzloop /dockerin/fuzz_drivers/tf1729828200290ivsd.c:23\n    #3 0x55dda86b27f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55dda86029d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f1455bc7d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f1455bc7e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55dda8602b24 in _start (/dockerin/fuzz_drivers/tf1729828200290ivsd.out+0xc4b24)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f14565a0887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55dda86b2a0c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:8339 in fio_siphash_xy\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 03:49:50\n// Signature: fio_siphash13(void *data, size_t len, uint64_t key1, uint64_t key2)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_siphash13\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio_siphash.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(0);\n    size_t len = (size_t)fuzzUint64(1);\n    uint64_t key1 = fuzzUint64(2);\n    uint64_t key2 = fuzzUint64(3);\n    uint64_t ret = fio_siphash13(data, len, key1, key2);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n8329:     v1 = fio_lrot64(v1, 13) ^ v0;                                              \\\n8330:     v0 = fio_lrot64(v0, 32);                                                   \\\n8331:     v2 += v1;                                                                  \\\n8332:     v0 += v3;                                                                  \\\n8333:     v1 = fio_lrot64(v1, 17) ^ v2;                                              \\\n8334:     v3 = fio_lrot64(v3, 21) ^ v0;                                              \\\n8335:     v2 = fio_lrot64(v2, 32);                                                   \\\n8336:   } while (0);\n8337: \n8338:   while (len >= 8) {\n8339:     word.i = sip_local64(fio_str2u64(w8));\n8340:     v3 ^= word.i;\n8341:     /* Sip Rounds */\n8342:     for (size_t i = 0; i < x; ++i) {\n8343:       hash_map_SipRound;\n8344:     }\n8345:     v0 ^= word.i;\n8346:     w8 += 8;\n8347:     len -= 8;\n8348:   }\n8349:   word.i = 0;\n8350: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n8393:   return v0;\n8394: }\n8395: \n8396: uint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n8397:                        uint64_t key2) {\n8398:   return fio_siphash_xy(data, len, 2, 4, key1, key2);\n8399: }\n8400: \n8401: uint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n8402:                        uint64_t key2) {\n8403:   return fio_siphash_xy(data, len, 1, 3, key1, key2);\n8404: }\n8405: \n8406: /* *****************************************************************************\n8407: SHA-1\n8408: ***************************************************************************** */\n8409: \n8410: static const uint8_t sha1_padding[64] = {0x80, 0};\n8411: \n8412: /**\n8413: Process the buffer once full.\n8414:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200007f033 at pc 0x7f99e5f4c397 bp 0x7fff18d98920 sp 0x7fff18d980c8\nREAD of size 3 at 0x60200007f033 thread T0\n    #0 0x7f99e5f4c396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x56551533ed17 in uint3korr /sourcecode/src/protocol/mysql_byteorder.h:179\n    #2 0x56551533f279 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:53\n    #3 0x56551533f592 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #4 0x56551533e73c in fuzzloop /sharedockerin/ta1729664330266xzik/test_file.cpp:22\n    #5 0x565515347f59 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x56551533e3a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f99e539fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f99e539fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x56551533e4f4 in _start (/sharedockerin/ta1729664330266xzik/clouditera+0xf4f4)\n\n0x60200007f033 is located 0 bytes to the right of 3-byte region [0x60200007f030,0x60200007f033)\nallocated by thread T0 here:\n    #0 0x7f99e5fc6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56551534816c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c0480007db0: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fd\n  0x0c0480007dc0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c0480007dd0: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c0480007de0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c0480007df0: fa fa fd fd fa fa 01 fa fa fa fd fa fa fa fd fa\n=>0x0c0480007e00: fa fa fd fa fa fa[03]fa fa fa fa fa fa fa fa fa\n  0x0c0480007e10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0480007e20: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0480007e30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0480007e40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0480007e50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:37:15\n// Signature: decode_string(unsigned char **str, unsigned long long *len, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_string\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    const unsigned char *data = reinterpret_cast<const unsigned char*>(fuzzData(0));\n    int len = fuzzGetLen(0);\n    const unsigned char *pos = data;\n    const unsigned char *end = data + len;\n    unsigned long long length;\n    const unsigned char *str;\n\n    decode_string(&str, &length, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n 176: static inline uint32_t uint3korr(const unsigned char *A)\n 177: {\n 178: \tuint32_t ret = 0;\n 179: \tmemcpy(&ret, A, 3);\n 180: \treturn ret;\n 181: }\n 182: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==5818==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000015c at pc 0x7f843da0108f bp 0x7fff02f6e7f0 sp 0x7fff02f6df98\nREAD of size 64797 at 0x60200000015c thread T0\n    #0 0x7f843da0108e in __interceptor_fwrite ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1160\n    #1 0x559e90e51d5f in __flatcc_fb_default_error_out /sourcecode/src/compiler/parser.c:25\n    #2 0x559e90e4feb6 in fuzzloop /dockerin/fuzz_drivers/tf1727601035232luzc.c:30\n    #3 0x559e90fc4b39 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x559e90e4e6f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f843d09cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f843d09ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x559e90e4e844 in _start (/dockerin/fuzz_drivers/tf1727601035232luzc.out+0x1e4844)\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f843da75887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x559e90fc4d4c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1160 in __interceptor_fwrite\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00[04]fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: __flatcc_fb_default_error_out\n// Sign: __flatcc_fb_default_error_out(void *err_ctx, char *buf, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <assert.h> //extract\n#include <stdarg.h> //extract\n#include \"semantics.h\" //extract\n#include \"codegen.h\" //extract\n#include \"fileio.h\" //extract\n#include \"pstrutil.h\" //extract\n#include \"flatcc/portable/pparseint.h\" //extract\n#include \"src/compiler/parser.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * err_ctx = (void *)fuzzData(0);\n    char * buf = fuzzString(1);\n    size_t len = (size_t)fuzzUint64(2);\n    __flatcc_fb_default_error_out(err_ctx, buf, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/parser.c\n  21: void fb_default_error_out(void *err_ctx, const char *buf, size_t len)\n  22: {\n  23:     (void)err_ctx;\n  24: \n  25:     fwrite(buf, 1, len, stderr);\n  26: }\n  27:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==775==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000008 at pc 0x562ec4a2cd96 bp 0x7fffa75e83f0 sp 0x7fffa75e83e0\nWRITE of size 2 at 0x602000000008 thread T0\n    #0 0x562ec4a2cd95 in block_free /sourcecode/lib/facil/fio.c:7837\n    #1 0x562ec4a2d864 in block_slice_free /sourcecode/lib/facil/fio.c:7935\n    #2 0x562ec4a2e13a in fio_free /sourcecode/lib/facil/fio.c:8097\n    #3 0x562ec49a45af in fio_str_free /sourcecode/lib/facil/fio.h:3853\n    #4 0x562ec49b2bae in fiobj_str_dealloc /sourcecode/lib/facil/fiobj/fiobj_str.c:65\n    #5 0x562ec499e77a in fiobj_free lib/facil/fiobj/fiobject.h:455\n    #6 0x562ec499e7ea in fuzzloop /dockerin/fuzz_drivers/tf1729823809899xkcw.c:20\n    #7 0x562ec4a8e619 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #8 0x562ec499da98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #9 0x7fa9a7bdcd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #10 0x7fa9a7bdce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #11 0x562ec499dbe4 in _start (/dockerin/fuzz_drivers/tf1729823809899xkcw.out+0x116be4)\n\n0x602000000008 is located 8 bytes to the left of 15-byte region [0x602000000010,0x60200000001f)\nallocated by thread T0 here:\n    #0 0x7fa9a85b5887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7fa9a7c5b58e in strdup (/lib/x86_64-linux-gnu/libc.so.6+0xa858e)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:7837 in block_free\nShadow bytes around the buggy address:\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c047fff8000: fa[fa]00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:36:34\n// Signature: fiobj_str_move(char *str, size_t len, size_t capacity)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_str_move\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_str.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char *str = fuzzData(0);\n    size_t len = fuzzGetLen(0);\n    size_t capacity = fuzzUint64(1);\n    FIOBJ obj = fiobj_str_move(str, len, capacity);\n    fiobj_free(obj);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7827:   blk->pos = FIO_MEMORY_BLOCK_START_POS;\n7828:   /* zero out linked list memory (everything else is already zero) */\n7829:   ((block_node_s *)blk)->node.next = NULL;\n7830:   ((block_node_s *)blk)->node.prev = NULL;\n7831:   /* bump parent reference count */\n7832:   fio_atomic_add(&blk->parent->root_ref, 1);\n7833: }\n7834: \n7835: /* intializes the block header for an available block of memory. */\n7836: static inline void block_free(block_s *blk) {\n7837:   if (fio_atomic_sub(&blk->ref, 1))\n7838:     return;\n7839: \n7840:   memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n7841:   fio_lock(&memory.lock);\n7842:   fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n7843: \n7844:   blk = blk->parent;\n7845: \n7846:   if (fio_atomic_sub(&blk->root_ref, 1)) {\n7847:     fio_unlock(&memory.lock);\n7848: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n7925:     block_free(blk);\n7926:     arena_last_used->block = NULL;\n7927:   }\n7928:   return (void *)mem;\n7929: }\n7930: \n7931: /* handle's a bock's reference count - called without a lock */\n7932: static inline void block_slice_free(void *mem) {\n7933:   /* locate block boundary */\n7934:   block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n7935:   block_free(blk);\n7936: }\n7937: \n7938: /* *****************************************************************************\n7939: Non-Block allocations (direct from the system)\n7940: ***************************************************************************** */\n7941: \n7942: /* allocates directly from the system adding size header - no lock required. */\n7943: static inline void *big_alloc(size_t size) {\n7944:   size = sys_round_size(size + 16);\n7945:   size_t *mem = sys_alloc(size, 1);\n7946: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8087: \n8088: void fio_free(void *ptr) {\n8089:   if (!ptr || ptr == (void *)&on_malloc_zero)\n8090:     return;\n8091:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8092:     /* big allocation - direct from the system */\n8093:     big_free(ptr);\n8094:     return;\n8095:   }\n8096:   /* allocated within block */\n8097:   block_slice_free(ptr);\n8098: }\n8099: \n8100: /**\n8101:  * Re-allocates memory. An attept to avoid copying the data is made only for big\n8102:  * memory allocations.\n8103:  *\n8104:  * This variation is slightly faster as it might copy less data\n8105:  */\n8106: void *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n8107:   if (!ptr || ptr == (void *)&on_malloc_zero) {\n8108: \nStacktrace #3:\nFile: /sourcecode/lib/facil/fio.h\n3847: inline FIO_FUNC int fio_str_free(fio_str_s *s) {\n3848: #ifndef FIO_STR_NO_REF\n3849:   if (!s || fio_atomic_sub(&s->ref, 1) != (uint32_t)-1)\n3850:     return -1;\n3851: #endif\n3852:   if (!s->small && s->dealloc)\n3853:     s->dealloc(s->data);\n3854:   *s = FIO_STR_INIT;\n3855:   return 0;\n3856: }\n3857: \nStacktrace #4:\nFile: /sourcecode/lib/facil/fiobj/fiobj_str.c\n  64: static void fiobj_str_dealloc(FIOBJ o, void (*task)(FIOBJ, void *), void *arg) {\n  65:   fio_str_free(&obj2str(o)->str);\n  66:   fio_free(FIOBJ2PTR(o));\n  67:   (void)task;\n  68:   (void)arg;\n  69: }\n  70: \nStacktrace #5:\nFile: /sourcecode/lib/facil/fiobj/fiobject.h\n 447: FIO_INLINE void fiobj_free(FIOBJ o) {\n 448:   if (!FIOBJ_IS_ALLOCATED(o))\n 449:     return;\n 450:   if (fiobj_ref_dec(o))\n 451:     return;\n 452:   if (FIOBJECT2VTBL(o)->each && FIOBJECT2VTBL(o)->count(o))\n 453:     fiobj_free_complex_object(o);\n 454:   else\n 455:     FIOBJECT2VTBL(o)->dealloc(o, NULL, NULL);\n 456: }\n 457:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==44400==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000015c at pc 0x7f7b820af84f bp 0x7ffe2796ecf0 sp 0x7ffe2796e498\nWRITE of size 20 at 0x60200000015c thread T0\n    #0 0x7f7b820af84e in __interceptor___xpg_strerror_r ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:3808\n    #1 0x5580532f7e8a in openssl_strerror_r crypto/o_str.c:390\n    #2 0x5580532f66f1 in fuzzloop /dockerin/fuzz_drivers/tf1730183725548oien.c:27\n    #3 0x558053300ab9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x5580532f6408 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f7b81892d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f7b81892e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x5580532f6554 in _start (/dockerin/fuzz_drivers/tf1730183725548oien.out+0xf554)\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f7b8211e887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x558053300ccc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:3808 in __interceptor___xpg_strerror_r\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 04 fa\n=>0x0c047fff8020: fa fa 04 fa fa fa 00 04 fa fa 00[04]fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:24:47\n// Signature: openssl_strerror_r(int errnum, char *buf, size_t buflen)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: openssl_strerror_r\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/e_os.h\" //extract\n#include <string.h> //extract\n#include <limits.h> //extract\n#include <openssl/crypto.h> //extract\n#include \"crypto/ctype.h\" //extract\n#include \"internal/cryptlib.h\" //extract\n#include \"internal/thread_once.h\" //extract\n#include \"internal/to_hex.h\" //extract\n\nint fuzzloop() {\n    int errnum = fuzzInt32(0);\n    char * buf = fuzzString(1);\n    size_t buflen = (size_t)fuzzUint64(2);\n    int ret = openssl_strerror_r(errnum, buf, buflen);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/o_str.c\n 358: int openssl_strerror_r(int errnum, char *buf, size_t buflen)\n 359: {\n 360: #if defined(_MSC_VER) && _MSC_VER>=1400 && !defined(_WIN32_WCE)\n 361:     return !strerror_s(buf, buflen, errnum);\n 362: #elif defined(_GNU_SOURCE)\n 363:     char *err;\n 364: \n 365:     /*\n 366:      * GNU strerror_r may not actually set buf.\n 367:      * It can return a pointer to some (immutable) static string in which case\n 368:      * buf is left unused.\n 369:      */\n 370:     err = strerror_r(errnum, buf, buflen);\n 371:     if (err == NULL || buflen == 0)\n 372:         return 0;\n 373:     /*\n 374:      * If err is statically allocated, err != buf and we need to copy the data.\n 375:      * If err points somewhere inside buf, OPENSSL_strlcpy can handle this,\n 376:      * since src and dest are not annotated with __restrict and the function\n 377:      * reads src byte for byte and writes to dest.\n 378:      * If err == buf we do not have to copy anything.\n 379:      */\n 380:     if (err != buf)\n 381:         OPENSSL_strlcpy(buf, err, buflen);\n 382:     return 1;\n 383: #elif (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n 384:       (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n 385:     /*\n 386:      * We can use \"real\" strerror_r. The OpenSSL version differs in that it\n 387:      * gives 1 on success and 0 on failure for consistency with other OpenSSL\n 388:      * functions. Real strerror_r does it the other way around\n 389:      */\n 390:     return !strerror_r(errnum, buf, buflen);\n 391: #else\n 392:     char *err;\n 393: \n 394:     /* Fall back to non-thread safe strerror()...its all we can do */\n 395:     if (buflen < 2)\n 396:         return 0;\n 397:     err = strerror(errnum);\n 398:     /* Can this ever happen? */\n 399:     if (err == NULL)\n 400:         return 0;\n 401:     OPENSSL_strlcpy(buf, err, buflen);\n 402:     return 1;\n 403: #endif\n 404: }\n 405:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2691==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000358 at pc 0x56261aabd937 bp 0x7ffc0b0a42a0 sp 0x7ffc0b0a4290\nREAD of size 8 at 0x602000000358 thread T0\n    #0 0x56261aabd936 in __flatcc_fb_clear_parser /sourcecode/src/compiler/parser.c:1502\n    #1 0x56261aac3f06 in flatcc_destroy_context /sourcecode/src/compiler/flatcc.c:519\n    #2 0x56261aaa497c in fuzzloop /dockerin/fuzz_drivers/tf1727601035340zgjo.c:25\n    #3 0x56261ac195c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x56261aaa46f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f8b9d7e0d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f8b9d7e0e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x56261aaa4844 in _start (/dockerin/fuzz_drivers/tf1727601035340zgjo.out+0x1e3844)\n\n0x602000000358 is located 572 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f8b9e1b9887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56261ac197dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/parser.c:1502 in __flatcc_fb_clear_parser\nShadow bytes around the buggy address:\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_destroy_context\n// Sign: flatcc_destroy_context(flatcc_context_t ctx)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <assert.h> //extract\n#include \"config.h\" //extract\n#include \"parser.h\" //extract\n#include \"semantics.h\" //extract\n#include \"fileio.h\" //extract\n#include \"codegen.h\" //extract\n#include \"flatcc/flatcc.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ctx = (void *)fuzzData(0);\n    flatcc_destroy_context(ctx);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/parser.c\n1497: void fb_clear_parser(fb_parser_t *P)\n1498: {\n1499:     fb_symbol_t *sym;\n1500:     fb_compound_type_t *ct;\n1501: \n1502:     for (sym = P->schema.symbols; sym; sym = sym->link) {\n1503:         switch (sym->kind) {\n1504:         case fb_is_struct:\n1505:         case fb_is_table:\n1506:         case fb_is_rpc_service:\n1507:         case fb_is_enum:\n1508:         case fb_is_union:\n1509:             ct = (fb_compound_type_t *)sym;\n1510:             fb_symbol_table_clear(&ct->index);\n1511:             fb_value_set_clear(&ct->value_set);\n1512:         }\n1513:     }\n1514:     fb_schema_table_clear(&P->schema.root_schema_instance.include_index);\n1515:     fb_name_table_clear(&P->schema.root_schema_instance.attribute_index);\n1516:     ptr_set_clear(&P->schema.visible_schema);\n1517:     if (P->tmp_field_marker) {\n1518:         free(P->tmp_field_marker);\n1519:     }\n1520:     if (P->tmp_field_index) {\n1521:         free(P->tmp_field_index);\n1522:     }\n1523:     if (P->ts) {\n1524:         free(P->ts);\n1525:     }\n1526:     if (P->schema.basename) {\n1527:         free((void *)P->schema.basename);\n1528:     }\n1529:     if (P->schema.basenameup) {\n1530:         free((void *)P->schema.basenameup);\n1531:     }\n1532:     if (P->schema.errorname) {\n1533:         free((void *)P->schema.errorname);\n1534:     }\n1535:     /*\n1536:      * P->referer_path in included files points to parent P->path, so\n1537:      * don't free it, and don't access it after this point.\n1538:      */\n1539:     if (P->path) {\n1540:         free((void *)P->path);\n1541:     }\n1542:     fb_scope_table_destroy(&P->schema.root_schema_instance.scope_index,\n1543:             __destroy_scope_item, 0);\n1544:     /* Destroy last since destructor has references into elem buffer. */\n1545:     clear_elem_buffers(P);\n1546:     if (P->managed_input) {\n1547:         free((void *)P->managed_input);\n1548:     }\n1549:     memset(P, 0, sizeof(*P));\n1550: }\n1551: \nStacktrace #1:\nFile: /sourcecode/src/compiler/flatcc.c\n 513: void flatcc_destroy_context(flatcc_context_t ctx)\n 514: {\n 515:     fb_parser_t *P = ctx, *dep = 0;\n 516: \n 517:     while (P) {\n 518:         dep = P->dependencies;\n 519:         fb_clear_parser(P);\n 520:         free(P);\n 521:         P = dep;\n 522:     }\n 523: }\n 524:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==299==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x619000019941 at pc 0x55cab90581b3 bp 0x7ffe5cc8c210 sp 0x7ffe5cc8c200\nREAD of size 1 at 0x619000019941 thread T0\n    #0 0x55cab90581b2 in parse_row_packet /sourcecode/src/protocol/mysql_parser.c:332\n    #1 0x55cab9054cf5 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #2 0x55cab906b087 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #3 0x55cab8ffd6ae in fuzzloop /sharedockerin/ta1729664328007pfbx/test_file.cpp:19\n    #4 0x55cab90a1929 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55cab8ffd2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f0f05d35d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f0f05d35e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55cab8ffd404 in _start (/sharedockerin/ta1729664328007pfbx/clouditera+0x109404)\n\n0x619000019941 is located 0 bytes to the right of 961-byte region [0x619000019580,0x619000019941)\nallocated by thread T0 here:\n    #0 0x7f0f0695c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55cab90a1b3c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_parser.c:332 in parse_row_packet\nShadow bytes around the buggy address:\n  0x0c327fffb2d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c327fffb2e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c327fffb2f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c327fffb300: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c327fffb310: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c327fffb320: 00 00 00 00 00 00 00 00[01]fa fa fa fa fa fa fa\n  0x0c327fffb330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c327fffb340: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c327fffb350: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c327fffb360: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c327fffb370: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:02\n// Signature: protocol::MySQLResponse::decode_packet(unsigned char *buf, size_t buflen)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponse13decode_packetEPKhm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n    protocol::MySQLResponse response;\n    response.decode_packet((const unsigned char*)buf, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 306: static int parse_row_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 307: {\n 308: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 309: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 310: \n 311: \tunsigned long long cell_len;\n 312: \tconst unsigned char *cell_data;\n 313: \n 314: \tsize_t i;\n 315: \n 316: \tif (*p == MYSQL_PACKET_HEADER_ERROR)\n 317: \t{\n 318: \t\tparser->parse = parse_error_packet;\n 319: \t\treturn 0;\n 320: \t}\n 321: \n 322: \tif (*p == MYSQL_PACKET_HEADER_EOF)\n 323: \t{\n 324: \t\tparser->parse = parse_eof_packet;\n 325: \t\tparser->current_result_set->rows_end_offset = parser->offset;\n 326: \n 327: \t\treturn 0;\n 328: \t}\n 329: \n 330: \tfor (i = 0; i < parser->current_result_set->field_count; i++)\n 331: \t{\n 332: \t\tif (*p == MYSQL_PACKET_HEADER_NULL)\n 333: \t\t{\n 334: \t\t\tp++;\n 335: \t\t} else {\n 336: \t\t\tif (decode_string(&cell_data, &cell_len, &p, buf_end) == 0)\n 337: \t\t\t\tbreak;\n 338: \t\t}\n 339: \t}\n 340: \n 341: \tif (i != parser->current_result_set->field_count)\n 342: \t\treturn -2;\n 343: \n 344: \tparser->current_result_set->row_count++;\n 345: \tparser->offset = p - (const unsigned char *)buf;\n 346: \treturn 0;\n 347: }\n 348: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #2:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==7059==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55e9878185e4 bp 0x7ffe937a7d20 sp 0x7ffe937a7d10\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x55e9878185e3 in __flatcc_fb_create_make_path_n /sourcecode/src/compiler/fileio.c:114\n    #1 0x55e987817559 in fuzzloop /dockerin/fuzz_drivers/tf1727601035232dfxr.c:19\n    #2 0x55e987821ee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e987817308 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fcd7767ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fcd7767ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e987817454 in _start (/dockerin/fuzz_drivers/tf1727601035232dfxr.out+0x11454)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fcd78053887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e9878220fc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/fileio.c:114 in __flatcc_fb_create_make_path_n\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: __flatcc_fb_create_make_path_n\n// Sign: __flatcc_fb_create_make_path_n(char *path, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"src/compiler/fileio.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * path = fuzzString(0);\n    size_t len = (size_t)fuzzUint64(1);\n    char * ret = __flatcc_fb_create_make_path_n(path, len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/fileio.c\n  96: char *fb_create_make_path_n(const char *path, size_t len)\n  97: {\n  98:     size_t i, j, n;\n  99:     char *s;\n 100: \n 101:     if (len == 1 && (path[0] == ' ' || path[0] == '\\\\')) {\n 102:         if (!(s = malloc(3))) {\n 103:             return 0;\n 104:         }\n 105:         s[0] = '\\\\';\n 106:         s[1] = path[0];\n 107:         s[2] = '\\0';\n 108:         return s;\n 109:     }\n 110:     if (len <= 1) {\n 111:         return fb_copy_path_n(path, len);\n 112:     }\n 113:     for (i = 0, n = len; i < len - 1; ++i) {\n 114:         if (path[i] == '\\\\' && path[i + 1] == ' ') {\n 115:             ++n;\n 116:         }\n 117:         n += path[i] == ' ';\n 118:     }\n 119:     n += path[i] == ' ';\n 120:     if (!(s = malloc(n + 1))) {\n 121:         return 0;\n 122:     }\n 123:     for (i = 0, j = 0; i < len - 1; ++i, ++j) {\n 124:         if (path[i] == '\\\\' && path[i + 1] == ' ') {\n 125:             s[j++] = '\\\\';\n 126:         }\n 127:         if (path[i] == ' ') {\n 128:             s[j++] = '\\\\';\n 129:         }\n 130:         s[j] = path[i];\n 131:     }\n 132:     if (path[i] == ' ') {\n 133:         s[j++] = '\\\\';\n 134:     }\n 135:     s[j++] = path[i];\n 136:     s[j] = 0;\n 137:     return s;\n 138: }\n 139:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==39761==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000d50 at pc 0x55b1bd85896a bp 0x7ffccbab9ef0 sp 0x7ffccbab9ee0\nREAD of size 8 at 0x602000000d50 thread T0\n    #0 0x55b1bd858969 in pitem_new ssl/pqueue.c:25\n    #1 0x55b1bd8586c4 in fuzzloop /dockerin/fuzz_drivers/tf1730183726689zlwt.c:22\n    #2 0x55b1bd861799 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55b1bd8582d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f67dcf0dd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f67dcf0de3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55b1bd858424 in _start (/dockerin/fuzz_drivers/tf1730183726689zlwt.out+0xe424)\n\n0x602000000d57 is located 0 bytes to the right of 7-byte region [0x602000000d50,0x602000000d57)\nallocated by thread T0 here:\n    #0 0x7f67dd799887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55b1bd8619ac in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ssl/pqueue.c:25 in pitem_new\nShadow bytes around the buggy address:\n  0x0c047fff8150: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fd\n  0x0c047fff8160: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8170: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8180: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8190: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n=>0x0c047fff81a0: fa fa fd fd fa fa fd fd fa fa[07]fa fa fa 00 04\n  0x0c047fff81b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff81f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:25:53\n// Signature: pitem_new(unsigned char *prio64be, void *data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: pitem_new\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Issl -DAES_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"ssl_local.h\" //extract\n#include <openssl/bn.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned char * prio64be = (unsigned char *)fuzzData(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(1);\n    pitem * ret = pitem_new(prio64be, data);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/ssl/pqueue.c\n  18: pitem *pitem_new(unsigned char *prio64be, void *data)\n  19: {\n  20:     pitem *item = OPENSSL_malloc(sizeof(*item));\n  21: \n  22:     if (item == NULL)\n  23:         return NULL;\n  24: \n  25:     memcpy(item->priority, prio64be, sizeof(item->priority));\n  26:     item->data = data;\n  27:     item->next = NULL;\n  28:     return item;\n  29: }\n  30:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==198==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000e133 at pc 0x55e9350e9252 bp 0x7ffd0317ad30 sp 0x7ffd0317ad20\nWRITE of size 1 at 0x60200000e133 thread T0\n    #0 0x55e9350e9251 in hex2byte /sourcecode/lib/facil/http/http.c:2380\n    #1 0x55e9350e9ed0 in http_decode_url_unsafe /sourcecode/lib/facil/http/http.c:2426\n    #2 0x55e934fd780a in fuzzloop /sharedockerin/ta1729829438469rhkp/test_file.c:29\n    #3 0x55e935156249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55e934fd6ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f8c08d78d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f8c08d78e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55e934fd6c04 in _start (/sharedockerin/ta1729829438469rhkp/clouditera+0x1dbc04)\n\n0x60200000e133 is located 1 bytes to the right of 2-byte region [0x60200000e130,0x60200000e132)\nallocated by thread T0 here:\n    #0 0x7f8c09751887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e93515645c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:2380 in hex2byte\nShadow bytes around the buggy address:\n  0x0c047fff9bd0: fa fa fd fa fa fa 00 01 fa fa fd fa fa fa fd fa\n  0x0c047fff9be0: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff9bf0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff9c00: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\n  0x0c047fff9c10: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fa\n=>0x0c047fff9c20: fa fa fd fd fa fa[02]fa fa fa fa fa fa fa fa fa\n  0x0c047fff9c30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9c40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9c50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9c60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9c70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: http_decode_url_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_url_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_url_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2375: static inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n2376:   if (source[0] >= '0' && source[0] <= '9')\n2377:     *dest = (source[0] - '0');\n2378:   else if ((source[0] >= 'a' && source[0] <= 'f') ||\n2379:            (source[0] >= 'A' && source[0] <= 'F'))\n2380:     *dest = (source[0] | 32) - 87;\n2381:   else\n2382:     return -1;\n2383:   *dest <<= 4;\n2384:   if (source[1] >= '0' && source[1] <= '9')\n2385:     *dest |= (source[1] - '0');\n2386:   else if ((source[1] >= 'a' && source[1] <= 'f') ||\n2387:            (source[1] >= 'A' && source[1] <= 'F'))\n2388:     *dest |= (source[1] | 32) - 87;\n2389:   else\n2390:     return -1;\n2391:   return 0;\n2392: }\n2393: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2416: ssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n2417:   char *pos = dest;\n2418:   while (*url_data) {\n2419:     if (*url_data == '+') {\n2420:       // decode space\n2421:       *(pos++) = ' ';\n2422:       ++url_data;\n2423:     } else if (*url_data == '%') {\n2424:       // decode hex value\n2425:       // this is a percent encoded value.\n2426:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2427:         return -1;\n2428:       pos++;\n2429:       url_data += 3;\n2430:     } else\n2431:       *(pos++) = *(url_data++);\n2432:   }\n2433:   *pos = 0;\n2434:   return pos - dest;\n2435: }\n2436:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==16137==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000001e8 at pc 0x55782368d89b bp 0x7fffb211ed50 sp 0x7fffb211ed40\nREAD of size 1 at 0x6020000001e8 thread T0\n    #0 0x55782368d89a in ossl_pw_get_passphrase crypto/passphrase.c:222\n    #1 0x55782368e4e5 in ossl_pw_get_password crypto/passphrase.c:318\n    #2 0x55782368e641 in ossl_pw_pem_password crypto/passphrase.c:326\n    #3 0x55782368c87f in fuzzloop /dockerin/fuzz_drivers/tf1730183726274lwoy.c:27\n    #4 0x557823696d79 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55782368c588 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f7bbcbf5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f7bbcbf5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55782368c6d4 in _start (/dockerin/fuzz_drivers/tf1730183726274lwoy.out+0xf6d4)\n\n0x6020000001e8 is located 12 bytes to the right of 12-byte region [0x6020000001d0,0x6020000001dc)\nallocated by thread T0 here:\n    #0 0x7f7bbd481887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x557823696f8c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow crypto/passphrase.c:222 in ossl_pw_get_passphrase\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 04 fa fa fa 04 fa fa fa 04 fa\n=>0x0c047fff8030: fa fa 04 fa fa fa 00 04 fa fa 00 04 fa[fa]fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:25:31\n// Signature: ossl_pw_pem_password(char *buf, int size, int rwflag, void *userdata)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_pw_pem_password\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <openssl/err.h> //extract\n#include <openssl/ui.h> //extract\n#include <openssl/core_names.h> //extract\n#include \"internal/cryptlib.h\" //extract\n#include \"internal/passphrase.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * buf = fuzzString(0);\n    int size = fuzzInt32(1);\n    int rwflag = fuzzInt32(2);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * userdata = (void *)fuzzData(3);\n    int ret = ossl_pw_pem_password(buf, size, rwflag, userdata);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/passphrase.c\n 204: int ossl_pw_get_passphrase(char *pass, size_t pass_size, size_t *pass_len,\n 205:                            const OSSL_PARAM params[], int verify,\n 206:                            struct ossl_passphrase_data_st *data)\n 207: {\n 208:     const char *source = NULL;\n 209:     size_t source_len = 0;\n 210:     const char *prompt_info = NULL;\n 211:     const UI_METHOD *ui_method = NULL;\n 212:     UI_METHOD *allocated_ui_method = NULL;\n 213:     void *ui_data = NULL;\n 214:     const OSSL_PARAM *p = NULL;\n 215:     int ret;\n 216: \n 217:     /* Handle explicit and cached passphrases */\n 218: \n 219:     if (data->type == is_expl_passphrase) {\n 220:         source = data->_.expl_passphrase.passphrase_copy;\n 221:         source_len = data->_.expl_passphrase.passphrase_len;\n 222:     } else if (data->flag_cache_passphrase && data->cached_passphrase != NULL) {\n 223:         source = data->cached_passphrase;\n 224:         source_len = data->cached_passphrase_len;\n 225:     }\n 226: \n 227:     if (source != NULL) {\n 228:         if (source_len > pass_size)\n 229:             source_len = pass_size;\n 230:         memcpy(pass, source, source_len);\n 231:         *pass_len = source_len;\n 232:         return 1;\n 233:     }\n 234: \n 235:     /* Handle the is_ossl_passphrase case...  that's pretty direct */\n 236: \n 237:     if (data->type == is_ossl_passphrase) {\n 238:         OSSL_PASSPHRASE_CALLBACK *cb = data->_.ossl_passphrase.passphrase_cb;\n 239:         void *cbarg = data->_.ossl_passphrase.passphrase_cbarg;\n 240: \n 241:         ret = cb(pass, pass_size, pass_len, params, cbarg);\n 242:         goto do_cache;\n 243:     }\n 244: \n 245:     /* Handle the is_pem_password and is_ui_method cases */\n 246: \n 247:     if ((p = OSSL_PARAM_locate_const(params,\n 248:                                      OSSL_PASSPHRASE_PARAM_INFO)) != NULL) {\n 249:         if (p->data_type != OSSL_PARAM_UTF8_STRING) {\n 250:             ERR_raise_data(ERR_LIB_CRYPTO, ERR_R_PASSED_INVALID_ARGUMENT,\n 251:                            \"Prompt info data type incorrect\");\n 252:             return 0;\n 253:         }\n 254:         prompt_info = p->data;\n 255:     }\n 256: \n 257:     if (data->type == is_pem_password) {\n 258:         /* We use a UI wrapper for PEM */\n 259:         pem_password_cb *cb = data->_.pem_password.password_cb;\n 260: \n 261:         ui_method = allocated_ui_method =\n 262:             UI_UTIL_wrap_read_pem_callback(cb, verify);\n 263:         ui_data = data->_.pem_password.password_cbarg;\n 264: \n 265:         if (ui_method == NULL) {\n 266:             ERR_raise(ERR_LIB_CRYPTO, ERR_R_UI_LIB);\n 267:             return 0;\n 268:         }\n 269:     } else if (data->type == is_ui_method) {\n 270:         ui_method = data->_.ui_method.ui_method;\n 271:         ui_data = data->_.ui_method.ui_method_data;\n 272:     }\n 273: \n 274:     if (ui_method == NULL) {\n 275:         ERR_raise_data(ERR_LIB_CRYPTO, ERR_R_PASSED_INVALID_ARGUMENT,\n 276:                        \"No password method specified\");\n 277:         return 0;\n 278:     }\n 279: \n 280:     ret = do_ui_passphrase(pass, pass_size, pass_len, prompt_info, verify,\n 281:                            ui_method, ui_data);\n 282: \n 283:     UI_destroy_method(allocated_ui_method);\n 284: \n 285:  do_cache:\n 286:     if (ret && data->flag_cache_passphrase) {\n 287:         if (data->cached_passphrase == NULL\n 288:             || *pass_len > data->cached_passphrase_len) {\n 289:             void *new_cache =\n 290:                 OPENSSL_clear_realloc(data->cached_passphrase,\n 291:                                       data->cached_passphrase_len,\n 292:                                       *pass_len + 1);\n 293: \n 294:             if (new_cache == NULL) {\n 295:                 OPENSSL_cleanse(pass, *pass_len);\n 296:                 return 0;\n 297:             }\n 298:             data->cached_passphrase = new_cache;\n 299:         }\n 300:         memcpy(data->cached_passphrase, pass, *pass_len);\n 301:         data->cached_passphrase[*pass_len] = '\\0';\n 302:         data->cached_passphrase_len = *pass_len;\n 303:     }\n 304: \n 305:     return ret;\n 306: }\n 307: \nStacktrace #1:\nFile: /sourcecode/crypto/passphrase.c\n 308: static int ossl_pw_get_password(char *buf, int size, int rwflag,\n 309:                                 void *userdata, const char *info)\n 310: {\n 311:     size_t password_len = 0;\n 312:     OSSL_PARAM params[] = {\n 313:         OSSL_PARAM_utf8_string(OSSL_PASSPHRASE_PARAM_INFO, NULL, 0),\n 314:         OSSL_PARAM_END\n 315:     };\n 316: \n 317:     params[0].data = (void *)info;\n 318:     if (ossl_pw_get_passphrase(buf, (size_t)size, &password_len, params,\n 319:                                rwflag, userdata))\n 320:         return (int)password_len;\n 321:     return -1;\n 322: }\n 323: \nStacktrace #2:\nFile: /sourcecode/crypto/passphrase.c\n 324: int ossl_pw_pem_password(char *buf, int size, int rwflag, void *userdata)\n 325: {\n 326:     return ossl_pw_get_password(buf, size, rwflag, userdata, \"PEM\");\n 327: }\n 328:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==584==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000010f at pc 0x55affb8a2896 bp 0x7ffdd48d4840 sp 0x7ffdd48d4830\nREAD of size 1 at 0x60200000010f thread T0\n    #0 0x55affb8a2895 in fio_base64_decode /sourcecode/lib/facil/fio.c:9351\n    #1 0x55affb7fc2d7 in fuzzloop /dockerin/fuzz_drivers/tf1729823117230eibb.c:19\n    #2 0x55affb8abeb9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55affb7fb9d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fe8f3d71d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fe8f3d71e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55affb7fbb24 in _start (/dockerin/fuzz_drivers/tf1729823117230eibb.out+0xc5b24)\n\n0x60200000010f is located 1 bytes to the left of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fe8f474a887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55affb8ac0cc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:9351 in fio_base64_decode\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa[fa]00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:25:01\n// Signature: fio_base64_decode(char *target, char *encoded, int base64_len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_base64_decode\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fio.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char *encoded = fuzzString(0);\n    int base64_len = fuzzGetLen(0);\n    char *target = fuzzFixBlob(1, base64_len / 4 * 3 + 3);\n    fio_base64_decode(target, encoded, base64_len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n9264: int fio_base64_decode(char *target, char *encoded, int base64_len) {\n9265:   if (!target)\n9266:     target = encoded;\n9267:   if (base64_len <= 0) {\n9268:     target[0] = 0;\n9269:     return 0;\n9270:   }\n9271:   int written = 0;\n9272:   uint8_t tmp1, tmp2, tmp3, tmp4;\n9273:   // skip unknown data at end\n9274:   while (base64_len &&\n9275:          !base64_decodes[*(uint8_t *)(encoded + (base64_len - 1))]) {\n9276:     base64_len--;\n9277:   }\n9278:   // skip white space\n9279:   while (base64_len && isspace((*(uint8_t *)encoded))) {\n9280:     base64_len--;\n9281:     encoded++;\n9282:   }\n9283:   while (base64_len >= 4) {\n9284:     if (!base64_len) {\n9285:       return written;\n9286:     }\n9287:     tmp1 = *(uint8_t *)(encoded++);\n9288:     tmp2 = *(uint8_t *)(encoded++);\n9289:     tmp3 = *(uint8_t *)(encoded++);\n9290:     tmp4 = *(uint8_t *)(encoded++);\n9291:     if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n9292:         !base64_decodes[tmp3] || !base64_decodes[tmp4]) {\n9293:       errno = ERANGE;\n9294:       goto finish;\n9295:     }\n9296:     *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 4);\n9297:     *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n9298:     *(target++) = (BITVAL(tmp3) << 6) | (BITVAL(tmp4));\n9299:     // make sure we don't loop forever.\n9300:     base64_len -= 4;\n9301:     // count written bytes\n9302:     written += 3;\n9303:     // skip white space\n9304:     while (base64_len && isspace((*encoded))) {\n9305:       base64_len--;\n9306:       encoded++;\n9307:     }\n9308:   }\n9309:   // deal with the \"tail\" of the mis-encoded stream - this shouldn't happen\n9310:   tmp1 = 0;\n9311:   tmp2 = 0;\n9312:   tmp3 = 0;\n9313:   tmp4 = 0;\n9314:   switch (base64_len) {\n9315:   case 1:\n9316:     tmp1 = *(uint8_t *)(encoded++);\n9317:     if (!base64_decodes[tmp1]) {\n9318:       errno = ERANGE;\n9319:       goto finish;\n9320:     }\n9321:     *(target++) = BITVAL(tmp1);\n9322:     written += 1;\n9323:     break;\n9324:   case 2:\n9325:     tmp1 = *(uint8_t *)(encoded++);\n9326:     tmp2 = *(uint8_t *)(encoded++);\n9327:     if (!base64_decodes[tmp1] || !base64_decodes[tmp2]) {\n9328:       errno = ERANGE;\n9329:       goto finish;\n9330:     }\n9331:     *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n9332:     *(target++) = (BITVAL(tmp2) << 4);\n9333:     written += 2;\n9334:     break;\n9335:   case 3:\n9336:     tmp1 = *(uint8_t *)(encoded++);\n9337:     tmp2 = *(uint8_t *)(encoded++);\n9338:     tmp3 = *(uint8_t *)(encoded++);\n9339:     if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n9340:         !base64_decodes[tmp3]) {\n9341:       errno = ERANGE;\n9342:       goto finish;\n9343:     }\n9344:     *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n9345:     *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n9346:     *(target++) = BITVAL(tmp3) << 6;\n9347:     written += 3;\n9348:     break;\n9349:   }\n9350: finish:\n9351:   if (encoded[-1] == '=') {\n9352:     target--;\n9353:     written--;\n9354:     if (encoded[-2] == '=') {\n9355:       target--;\n9356:       written--;\n9357:     }\n9358:     if (written < 0)\n9359:       written = 0;\n9360:   }\n9361:   *target = 0;\n9362:   return written;\n9363: }\n9364:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==840==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000380 at pc 0x560ae8c99945 bp 0x7ffd54201440 sp 0x7ffd54201430\nREAD of size 8 at 0x602000000380 thread T0\n    #0 0x560ae8c99944 in flatcc_parse_file /sourcecode/src/compiler/flatcc.c:330\n    #1 0x560ae8c7c991 in fuzzloop /dockerin/fuzz_drivers/tf1727601035344taxy.c:26\n    #2 0x560ae8df15e9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x560ae8c7c6f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f35b4eaed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f35b4eaee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x560ae8c7c844 in _start (/dockerin/fuzz_drivers/tf1727601035344taxy.out+0x1e3844)\n\n0x602000000380 is located 548 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f35b5887887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x560ae8df17fc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/flatcc.c:330 in flatcc_parse_file\nShadow bytes around the buggy address:\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8070:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_parse_file\n// Sign: flatcc_parse_file(flatcc_context_t ctx, char *filename)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <assert.h> //extract\n#include \"config.h\" //extract\n#include \"parser.h\" //extract\n#include \"semantics.h\" //extract\n#include \"fileio.h\" //extract\n#include \"codegen.h\" //extract\n#include \"flatcc/flatcc.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ctx = (void *)fuzzData(0);\n    char * filename = fuzzString(1);\n    int ret = flatcc_parse_file(ctx, filename);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/flatcc.c\n 318: int flatcc_parse_file(flatcc_context_t ctx, const char *filename)\n 319: {\n 320:     fb_parser_t *P = ctx;\n 321:     size_t inpath_len, filename_len;\n 322:     char *buf, *path, *include_file;\n 323:     const char *inpath;\n 324:     size_t size;\n 325:     fb_name_t *inc;\n 326:     int i, ret, is_root;\n 327: \n 328:     filename_len = strlen(filename);\n 329:     /* Don't parse the same file twice, or any other file with same basename. */\n 330:     if (fb_schema_table_insert_item(&P->schema.root_schema->include_index, &P->schema, ht_keep)) {\n 331:         return 0;\n 332:     }\n 333:     buf = 0;\n 334:     path = 0;\n 335:     include_file = 0;\n 336:     ret = -1;\n 337:     is_root = !P->referer_path;\n 338: \n 339:     /*\n 340:      * For root files, read file relative to working dir first. For\n 341:      * included files (`referer_path` set), first try include paths\n 342:      * in order, then path relative to including file.\n 343:      */\n 344:     if (is_root) {\n 345:         if (!(buf = fb_read_file(filename, P->opts.max_schema_size, &size))) {\n 346:             if (size + P->schema.root_schema->total_source_size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {\n 347:                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");\n 348:                 goto done;\n 349:             }\n 350:         } else {\n 351:             checkmem((path = fb_copy_path(filename)));\n 352:         }\n 353:     }\n 354:     for (i = 0; !buf && i < P->opts.inpath_count; ++i) {\n 355:         inpath = P->opts.inpaths[i];\n 356:         inpath_len = strlen(inpath);\n 357:         checkmem((path = fb_create_join_path_n(inpath, inpath_len, filename, filename_len, \"\", 1)));\n 358:         if (!(buf = fb_read_file(path, P->opts.max_schema_size, &size))) {\n 359:             free(path);\n 360:             path = 0;\n 361:             if (size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {\n 362:                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");\n 363:                 goto done;\n 364:             }\n 365:         }\n 366:     }\n 367:     if (!buf && !is_root) {\n 368:         inpath = P->referer_path;\n 369:         inpath_len = fb_find_basename(inpath, strlen(inpath));\n 370:         checkmem((path = fb_create_join_path_n(inpath, inpath_len, filename, filename_len, \"\", 1)));\n 371:         if (!(buf = fb_read_file(path, P->opts.max_schema_size, &size))) {\n 372:             free(path);\n 373:             path = 0;\n 374:             if (size > P->opts.max_schema_size && P->opts.max_schema_size > 0) {\n 375:                 fb_print_error(P, \"input exceeds maximum allowed size\\n\");\n 376:                 goto done;\n 377:             }\n 378:         }\n 379:     }\n 380:     if (!buf) {\n 381:         fb_print_error(P, \"error reading included schema file: %s\\n\", filename);\n 382:         goto done;\n 383:     }\n 384:     P->schema.root_schema->total_source_size += size;\n 385:     P->path = path;\n 386:     /* Parser owns path. */\n 387:     path = 0;\n 388:     /*\n 389:      * Even if we do not have the recursive option set, we still\n 390:      * need to parse all include files to make sense of the current\n 391:      * file.\n 392:      */\n 393:     if (!fb_parse(P, buf, size, 1)) {\n 394:         /* Parser owns buffer. */\n 395:         buf = 0;\n 396:         inc = P->schema.includes;\n 397:         while (inc) {\n 398:             checkmem((include_file = fb_copy_path_n(inc->name.s.s, (size_t)inc->name.s.len)));\n 399:             if (__parse_include_file(P, include_file)) {\n 400:                 goto done;\n 401:             }\n 402:             free(include_file);\n 403:             include_file = 0;\n 404:             inc = inc->link;\n 405:         }\n 406:         /* Add self to set of visible schema. */\n 407:         ptr_set_insert_item(&P->schema.visible_schema, &P->schema, ht_keep);\n 408:         if (fb_build_schema(P)) {\n 409:             goto done;\n 410:         }\n 411:         /*\n 412:         * We choose to only generate optional .depends files for root level\n 413:         * files. These will contain all nested files regardless of\n 414:         * recursive file generation flags.\n 415:         */\n 416:         if (P->opts.gen_dep && is_root) {\n 417:             if (__flatcc_gen_depends_file(P)) {\n 418:                 goto done;\n 419:             }\n 420:         }\n 421:         ret = 0;\n 422:     }\n 423: \n 424: done:\n 425:     /* Parser owns buffer so don't free it here. */\n 426:     checkfree(path);\n 427:     checkfree(include_file);\n 428:     return ret;\n 429: }\n 430:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==16777==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000118 at pc 0x55ba7d1ea9b7 bp 0x7ffdebf2cce0 sp 0x7ffdebf2ccd0\nREAD of size 8 at 0x602000000118 thread T0\n    #0 0x55ba7d1ea9b6 in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&) (/dockerin/fuzz_drivers/tf1729593105429mgsa.out+0x3209b6)\n    #1 0x55ba7d1e7e1f in std::vector<EndpointAddress*, std::allocator<EndpointAddress*> >::end() (/dockerin/fuzz_drivers/tf1729593105429mgsa.out+0x31de1f)\n    #2 0x55ba7d1d8d8a in WFServiceGovernance::tracing_deleter(void*) /sourcecode/src/nameservice/WFServiceGovernance.cc:173\n    #3 0x55ba7d1d2a54 in fuzzloop /dockerin/fuzz_drivers/tf1729593105429mgsa.cpp:31\n    #4 0x55ba7d36ddf9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55ba7d1d2818 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f920503ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f920503ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55ba7d1d2964 in _start (/dockerin/fuzz_drivers/tf1729593105429mgsa.out+0x308964)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f9205c65887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55ba7d36e00c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/dockerin/fuzz_drivers/tf1729593105429mgsa.out+0x3209b6) in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: WFServiceGovernance::tracing_deleter(void *data)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN19WFServiceGovernance15tracing_deleterEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"URIParser.h\" //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(0);\n    WFServiceGovernance::tracing_deleter(data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/WFServiceGovernance.cc\n 169: void WFServiceGovernance::tracing_deleter(void *data)\n 170: {\n 171: \tstruct TracingData *tracing_data = (struct TracingData *)data;\n 172: \n 173: \tfor (EndpointAddress *addr : tracing_data->history)\n 174: \t{\n 175: \t\tif (--addr->ref == 0)\n 176: \t\t{\n 177: \t\t\tpthread_rwlock_wrlock(&tracing_data->sg->rwlock);\n 178: \t\t\ttracing_data->sg->pre_delete_server(addr);\n 179: \t\t\tpthread_rwlock_unlock(&tracing_data->sg->rwlock);\n 180: \t\t\tdelete addr;\n 181: \t\t}\n 182: \t}\n 183: \n 184: \tdelete tracing_data;\n 185: }\n 186:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==20634==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x563e44a35baa bp 0x7ffdc155e050 sp 0x7ffdc155e040\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x563e44a35ba9 in buf2hexstr_sep crypto/o_str.c:308\n    #1 0x563e44a35dee in ossl_buf2hexstr_sep crypto/o_str.c:341\n    #2 0x563e44a346f3 in fuzzloop /dockerin/fuzz_drivers/tf1730183725653rfli.c:27\n    #3 0x563e44a3ead9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x563e44a34408 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f3f76e6fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f3f76e6fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x563e44a34554 in _start (/dockerin/fuzz_drivers/tf1730183725653rfli.out+0xf554)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f3f776fb887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x563e44a3ecec in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow crypto/o_str.c:308 in buf2hexstr_sep\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa 01 fa\n  0x0c047fff8030: fa fa 01 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:24:53\n// Signature: ossl_buf2hexstr_sep(unsigned char *buf, long buflen, char sep)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_buf2hexstr_sep\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/e_os.h\" //extract\n#include <string.h> //extract\n#include <limits.h> //extract\n#include <openssl/crypto.h> //extract\n#include \"crypto/ctype.h\" //extract\n#include \"internal/cryptlib.h\" //extract\n#include \"internal/thread_once.h\" //extract\n#include \"internal/to_hex.h\" //extract\n\nint fuzzloop() {\n    unsigned char * buf = (unsigned char *)fuzzData(0);\n    long buflen = (long)fuzzInt64(1);\n    char sep = fuzzInt8(2);\n    char * ret = ossl_buf2hexstr_sep(buf, buflen, sep);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/o_str.c\n 286: static int buf2hexstr_sep(char *str, size_t str_n, size_t *strlength,\n 287:                           const unsigned char *buf, size_t buflen,\n 288:                           const char sep)\n 289: {\n 290:     char *q;\n 291:     int has_sep = (sep != CH_ZERO);\n 292:     size_t i, len = has_sep ? buflen * 3 : 1 + buflen * 2;\n 293: \n 294:     if (len == 0)\n 295:         ++len;\n 296:     if (strlength != NULL)\n 297:         *strlength = len;\n 298:     if (str == NULL)\n 299:         return 1;\n 300: \n 301:     if (str_n < len) {\n 302:         ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);\n 303:         return 0;\n 304:     }\n 305: \n 306:     q = str;\n 307:     for (i = 0; i < buflen; i++) {\n 308:         q += ossl_to_hex(q, buf[i]);\n 309:         if (has_sep)\n 310:             *q++ = sep;\n 311:     }\n 312:     if (has_sep && buflen > 0)\n 313:         --q;\n 314:     *q = CH_ZERO;\n 315: \n 316: #ifdef CHARSET_EBCDIC\n 317:     ebcdic2ascii(str, str, q - str);\n 318: #endif\n 319:     return 1;\n 320: }\n 321: \nStacktrace #1:\nFile: /sourcecode/crypto/o_str.c\n 329: char *ossl_buf2hexstr_sep(const unsigned char *buf, long buflen, char sep)\n 330: {\n 331:     char *tmp;\n 332:     size_t tmp_n;\n 333: \n 334:     if (buflen == 0)\n 335:         return OPENSSL_zalloc(1);\n 336: \n 337:     tmp_n = (sep != CH_ZERO) ? buflen * 3 : 1 + buflen * 2;\n 338:     if ((tmp = OPENSSL_malloc(tmp_n)) == NULL)\n 339:         return NULL;\n 340: \n 341:     if (buf2hexstr_sep(tmp, tmp_n, NULL, buf, buflen, sep))\n 342:         return tmp;\n 343:     OPENSSL_free(tmp);\n 344:     return NULL;\n 345: }\n 346:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==365162==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000118 at pc 0x561218d12e29 bp 0x7ffd6e6180c0 sp 0x7ffd6e6180b0\nREAD of size 8 at 0x602000000118 thread T0\n    #0 0x561218d12e28 in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&) /usr/include/c++/11/bits/stl_iterator.h:1028\n    #1 0x561218d0d6a1 in std::vector<EndpointAddress*, std::allocator<EndpointAddress*> >::end() /usr/include/c++/11/bits/stl_vector.h:830\n    #2 0x561218cfd31b in UPSWeightedRandomPolicy::select_history_weight(WFNSTracing*) /sourcecode/src/nameservice/UpstreamPolicies.cc:512\n    #3 0x561218cedba8 in fuzzloop /dockerin/fuzz_drivers/tf1729655987046rynf.cpp:18\n    #4 0x561218eb7269 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x561218ced8b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fa6539efd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fa6539efe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x561218ceda04 in _start (/dockerin/fuzz_drivers/tf1729655987046rynf.out+0x374a04)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fa654616887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x561218eb747c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/11/bits/stl_iterator.h:1028 in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:59:25\n// Signature: UPSWeightedRandomPolicy::select_history_weight(WFNSTracing *tracing)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy21select_history_weightEP11WFNSTracing\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    WFNSTracing tracing;\n    tracing.data = (void*)fuzzData(0);\n    UPSWeightedRandomPolicy::select_history_weight(&tracing);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 503: int UPSWeightedRandomPolicy::select_history_weight(WFNSTracing *tracing)\n 504: {\n 505: \tstruct TracingData *tracing_data = (struct TracingData *)tracing->data;\n 506: \n 507: \tif (!tracing_data)\n 508: \t\treturn 0;\n 509: \n 510: \tint ret = 0;\n 511: \n 512: \tfor (EndpointAddress *server : tracing_data->history)\n 513: \t\tret += ((UPSAddrParams *)server->params)->weight;\n 514: \n 515: \treturn ret;\n 516: }\n 517:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4856==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000380 at pc 0x5595d6a14522 bp 0x7ffe1e8deb90 sp 0x7ffe1e8deb80\nREAD of size 8 at 0x602000000380 thread T0\n    #0 0x5595d6a14521 in export_schema /sourcecode/src/compiler/codegen_schema.c:394\n    #1 0x5595d6a155da in __flatcc_fb_codegen_bfbs_to_buffer /sourcecode/src/compiler/codegen_schema.c:523\n    #2 0x5595d69fc10d in flatcc_generate_binary_schema_to_buffer /sourcecode/src/compiler/flatcc.c:436\n    #3 0x5595d69dd9a3 in fuzzloop /dockerin/fuzz_drivers/tf1727601035359geej.c:28\n    #4 0x5595d6b525f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x5595d69dd6f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f7b5256ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f7b5256ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x5595d69dd844 in _start (/dockerin/fuzz_drivers/tf1727601035359geej.out+0x1e3844)\n\n0x602000000380 is located 488 bytes to the right of 8-byte region [0x602000000190,0x602000000198)\nallocated by thread T0 here:\n    #0 0x7f7b52f43887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5595d6b5280c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/codegen_schema.c:394 in export_schema\nShadow bytes around the buggy address:\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8070:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_generate_binary_schema_to_buffer\n// Sign: flatcc_generate_binary_schema_to_buffer(flatcc_context_t ctx, void *buf, size_t bufsiz)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <assert.h> //extract\n#include \"config.h\" //extract\n#include \"parser.h\" //extract\n#include \"semantics.h\" //extract\n#include \"fileio.h\" //extract\n#include \"codegen.h\" //extract\n#include \"flatcc/flatcc.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ctx = (void *)fuzzData(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * buf = (void *)fuzzData(1);\n    size_t bufsiz = (size_t)fuzzUint64(2);\n    int ret = flatcc_generate_binary_schema_to_buffer(ctx, buf, bufsiz);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/codegen_schema.c\n 389: static int export_schema(flatcc_builder_t *B, fb_options_t *opts, fb_schema_t *S)\n 390: {\n 391:     catalog_t catalog;\n 392:     reflection_Object_ref_t *object_map = 0;\n 393: \n 394:     if (build_catalog(&catalog, S, opts->bgen_qualify_names, &S->root_schema->scope_index)) {\n 395:         return -1;\n 396:     }\n 397: \n 398:     if (catalog.nobjects > 0 && !(object_map = malloc((size_t)catalog.nobjects * sizeof(object_map[0])))) {\n 399:         clear_catalog(&catalog);\n 400:         return -1;\n 401:     }\n 402: \n 403:     /* Build the schema. */\n 404: \n 405:     if (opts->bgen_length_prefix) {\n 406:         reflection_Schema_start_as_root_with_size(B);\n 407:     } else {\n 408:         reflection_Schema_start_as_root(B);\n 409:     }\n 410:     if (S->file_identifier.type == vt_string) {\n 411:         reflection_Schema_file_ident_create(B,\n 412:                 S->file_identifier.s.s, (size_t)S->file_identifier.s.len);\n 413:     }\n 414:     if (S->file_extension.type == vt_string) {\n 415:         reflection_Schema_file_ext_create(B,\n 416:                 S->file_extension.s.s, (size_t)S->file_extension.s.len);\n 417:     }\n 418:     export_objects(B, catalog.objects, catalog.nobjects, object_map);\n 419:     export_enums(B, catalog.enums, catalog.nenums, object_map);\n 420:     export_root_type(B, S->root_type.type, object_map);\n 421:     export_services(B, catalog.services, catalog.nservices, object_map);\n 422: \n 423:     reflection_Schema_end_as_root(B);\n 424: \n 425:     /* Clean up support datastructures. */\n 426: \n 427:     clear_catalog(&catalog);\n 428:     if (object_map) {\n 429:         free(object_map);\n 430:     }\n 431:     return 0;\n 432: }\n 433: \nStacktrace #1:\nFile: /sourcecode/src/compiler/codegen_schema.c\n 517: void *fb_codegen_bfbs_to_buffer(fb_options_t *opts, fb_schema_t *S, void *buffer, size_t *size)\n 518: {\n 519:     flatcc_builder_t builder, *B;\n 520: \n 521:     B = &builder;\n 522:     flatcc_builder_init(B);\n 523:     export_schema(B, opts, S);\n 524:     if (!flatcc_builder_copy_buffer(B, buffer, *size)) {\n 525:         goto done;\n 526:     }\n 527:     sort_objects(buffer);\n 528: done:\n 529:     *size = flatcc_builder_get_buffer_size(B);\n 530:     flatcc_builder_clear(B);\n 531:     return buffer;\n 532: }\n 533: \nStacktrace #2:\nFile: /sourcecode/src/compiler/flatcc.c\n 432: int flatcc_generate_binary_schema_to_buffer(flatcc_context_t ctx, void *buf, size_t bufsiz)\n 433: {\n 434:     fb_parser_t *P = ctx;\n 435: \n 436:     if (fb_codegen_bfbs_to_buffer(&P->opts, &P->schema, buf, &bufsiz)) {\n 437:         return (int)bufsiz;\n 438:     }\n 439:     return -1;\n 440: }\n 441:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==28111==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x560661419e03 bp 0x7ffd5d79c5c0 sp 0x7ffd5d79c5b0\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x560661419e02 in StringUtil::url_decode(char*, unsigned long) /sourcecode/src/util/StringUtil.cc:59\n    #1 0x5606614199f9 in fuzzloop /dockerin/fuzz_drivers/tf1729593105338ande.cpp:23\n    #2 0x56066142a879 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x5606614197a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fe588677d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fe588677e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x5606614198f4 in _start (/dockerin/fuzz_drivers/tf1729593105338ande.out+0x1d8f4)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fe58929e887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56066142aa8c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/util/StringUtil.cc:59 in StringUtil::url_decode(char*, unsigned long)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: StringUtil::url_decode(char *str, size_t len)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN10StringUtil10url_decodeEPcm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/util -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <ctype.h> //extract\n#include <string> //extract\n#include <vector> //extract\n#include <algorithm> //extract\n#include \"StringUtil.h\" //extract\n\nextern \"C\" int fuzzloop() {\n    char * str = fuzzString(0);\n    size_t len = (size_t)fuzzUint64(1);\n    size_t ret = StringUtil::url_decode(str, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/util/StringUtil.cc\n  52: size_t StringUtil::url_decode(char *str, size_t len)\n  53: {\n  54: \tchar *dest = str;\n  55: \tchar *data = str;\n  56: \n  57: \twhile (len--)\n  58: \t{\n  59: \t\tif (*data == '%' && len >= 2\n  60: \t\t\t&& isxdigit(*(data + 1))\n  61: \t\t\t&& isxdigit(*(data + 2)))\n  62: \t\t{\n  63: \t\t\t*dest = __htoi((unsigned char *)data + 1);\n  64: \t\t\tdata += 2;\n  65: \t\t\tlen -= 2;\n  66: \t\t}\n  67: \t\telse if (*data == '+')\n  68: \t\t\t*dest = ' ';\n  69: \t\telse\n  70: \t\t\t*dest = *data;\n  71: \n  72: \t\tdata++;\n  73: \t\tdest++;\n  74: \t}\n  75: \n  76: \t*dest = '\\0';\n  77: \treturn dest - str;\n  78: }\n  79:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1783==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000001dc at pc 0x559ed850767a bp 0x7ffcf14726f0 sp 0x7ffcf14726e0\nREAD of size 1 at 0x6020000001dc thread T0\n    #0 0x559ed8507679 in scope_hash /sourcecode/src/compiler/hash_tables/scope_table.c:163\n    #1 0x559ed850628d in ht_remove /sourcecode/external/hash/hash_table_impl.h:199\n    #2 0x559ed8504c51 in fb_scope_table_remove /sourcecode/src/compiler/hash_tables/scope_table.c:63\n    #3 0x559ed84f88f4 in fuzzloop /dockerin/fuzz_drivers/tf1727601035287nkab.c:35\n    #4 0x559ed850fd79 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x559ed84f8528 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fc11b5ccd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fc11b5cce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x559ed84f8674 in _start (/dockerin/fuzz_drivers/tf1727601035287nkab.out+0x1d674)\n\n0x6020000001dc is located 0 bytes to the right of 12-byte region [0x6020000001d0,0x6020000001dc)\nallocated by thread T0 here:\n    #0 0x7fc11bfa5887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x559ed850ff8c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/hash_tables/scope_table.c:163 in scope_hash\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 fa\n=>0x0c047fff8030: fa fa 00 fa fa fa 00 04 fa fa 00[04]fa fa 00 fa\n  0x0c047fff8040: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler/hash_tables -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: fb_scope_table_remove\n// Sign: fb_scope_table_remove(fb_scope_table_t *ht, void *key, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"../symbols.h\" //extract\n#include \"external/hash/hash_table.h\" //autogen\n#include \"src/compiler/symbols.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //file: external/hash/hash_table.h:63\n    //struct hash_table {\n    //    void *table;\n    //    char *offsets;\n    //    size_t count;\n    //    /* May be stored as a direct count, or log2. */\n    //    size_t buckets;\n    //};\n    struct hash_table *ht = (struct hash_table *)driverAllocMem(sizeof(struct hash_table));\n    ht->table = (void *)fuzzData(0);\n    ht->offsets = fuzzString(1);\n    ht->buckets = (unsigned long)fuzzUint64(2);\n    \n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * key = (void *)fuzzData(3);\n    size_t len = (size_t)fuzzUint64(4);\n    fb_scope_t * ret = fb_scope_table_remove(ht, key, len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/hash_tables/scope_table.c\n 142: static inline size_t scope_hash(const void *key, size_t len)\n 143: {\n 144:     size_t h = 0, i;\n 145:     int count = (int)len;\n 146: \n 147:     if (count <= 0) {\n 148:         const fb_ref_t *name = key;\n 149: \n 150:         while (name) {\n 151:             h ^= ht_strn_hash_function(name->ident->text, (size_t)name->ident->len);\n 152:             h = ht_int_hash_function((void *)h, 0);\n 153:             name = name->link;\n 154:             if (++count == 0) {\n 155:                 break;\n 156:             }\n 157:         }\n 158:         return h;\n 159:     } else {\n 160:         const char *s = key;\n 161:         for (;;) {\n 162:             for (i = 0; i < len; ++i) {\n 163:                 if (s[i] == '.') {\n 164:                     break;\n 165:                 }\n 166:             }\n 167:             h ^= ht_strn_hash_function(s, i);\n 168:             h = ht_int_hash_function((void *)h, 0);\n 169:             if (i == len) {\n 170:                 break;\n 171:             }\n 172:             len -= i + 1;\n 173:             s += i + 1;\n 174:         }\n 175:         return h;\n 176:     }\n 177: }\n 178: \nStacktrace #1:\nFile: /sourcecode/external/hash/hash_table_impl.h\n 189: static ht_item_t ht_remove(hash_table_t *ht, const void *key, size_t len)\n 190: {\n 191:     ht_item_t *T = ht->table;\n 192:     size_t N, i, j, k;\n 193:     ht_item_t item;\n 194: \n 195:     if (T == 0) {\n 196:         return 0;\n 197:     }\n 198:     N = ht->buckets - 1;\n 199:     k = HT_HASH_FUNCTION(key, len);\n 200:     i = 0;\n 201:     j = HT_PROBE(k, i, N);\n 202:     while ((item = T[j])) {\n 203:         if (item != HT_DELETED &&\n 204:                 ht_match(key, len, item)) {\n 205:             T[j] = HT_DELETED;\n 206:             --ht->count;\n 207:             return item;\n 208:         }\n 209:         ++i;\n 210:         j = HT_PROBE(k, i, N);\n 211:     }\n 212:     return 0;\n 213: }\n 214: \nStacktrace #2:\nFile: /sourcecode/src/compiler/hash_tables/scope_table.c\n  63: DEFINE_HASH_TABLE(fb_scope_table)\n  64:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==15370==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000190 at pc 0x55c52a9489db bp 0x7ffc9b704100 sp 0x7ffc9b7040f0\nREAD of size 8 at 0x602000000190 thread T0\n    #0 0x55c52a9489da in Communicator::partial_written(unsigned long, void*) /sourcecode/src/kernel/Communicator.cc:1349\n    #1 0x55c52a92cd89 in fuzzloop /dockerin/fuzz_drivers/tf1729593105305gbrd.cpp:40\n    #2 0x55c52a986229 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55c52a92cb38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f6bff13ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f6bff13ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55c52a92cc84 in _start (/dockerin/fuzz_drivers/tf1729593105305gbrd.out+0x83c84)\n\n0x602000000190 is located 52 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f6bffd61887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55c52a98643c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Communicator.cc:1349 in Communicator::partial_written(unsigned long, void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 fa\n  0x0c047fff8020: fa fa 00 fa fa fa 00 04 fa fa 00 04 fa fa fa fa\n=>0x0c047fff8030: fa fa[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Communicator::partial_written(size_t n, void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator15partial_writtenEmPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    size_t n = (size_t)fuzzUint64(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(1);\n    int ret = Communicator::partial_written(n, context);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1346: int Communicator::partial_written(size_t n, void *context)\n1347: {\n1348: \tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n1349: \tCommSession *session = entry->session;\n1350: \tint timeout;\n1351: \n1352: \ttimeout = Communicator::next_timeout(session);\n1353: \tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n1354: \treturn 0;\n1355: }\n1356:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==29897==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000c0 at pc 0x5588c794214e bp 0x7ffd45732b40 sp 0x7ffd45732b30\nREAD of size 8 at 0x6060000000c0 thread T0\n    #0 0x5588c794214d in UPSGroupPolicy::fuse_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:126\n    #1 0x5588c7939ff0 in fuzzloop /dockerin/fuzz_drivers/tf1729593105347qlmi.cpp:39\n    #2 0x5588c7b077c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x5588c7939978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7ff53c91ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7ff53c91ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x5588c7939ac4 in _start (/dockerin/fuzz_drivers/tf1729593105347qlmi.out+0x380ac4)\n\n0x6060000000c0 is located 8 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7ff53d5471e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x5588c793abfb in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x5588c7939d3d in fuzzloop /dockerin/fuzz_drivers/tf1729593105347qlmi.cpp:37\n    #3 0x5588c7b077c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:126 in UPSGroupPolicy::fuse_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00 fa[fa]fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSGroupPolicy::fuse_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14UPSGroupPolicy15fuse_one_serverEPK15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"URIParser.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    auto upsgrouppolicy = std::make_unique<UPSGroupPolicy>();\n    std::string address = fuzzString(0);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsgrouppolicy->fuse_one_server(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 122: void UPSGroupPolicy::fuse_one_server(const EndpointAddress *addr)\n 123: {\n 124: \tthis->nalives--;\n 125: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 126: \tparams->group->nalives--;\n 127: }\n 128:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==244==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60400000ff88 at pc 0x55f149eeacfa bp 0x7ffcef6b8370 sp 0x7ffcef6b8360\nREAD of size 8 at 0x60400000ff88 thread T0\n    #0 0x55f149eeacf9 in list_del /sourcecode/_include/workflow/list.h:100\n    #1 0x55f149ef6b2e in json_array_remove /sourcecode/src/util/json_parser.c:1275\n    #2 0x55f149eea734 in fuzzloop /sharedockerin/ta1729664329569nrnw/test_file.cpp:37\n    #3 0x55f149f060c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55f149eea468 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7ff211344d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7ff211344e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55f149eea5b4 in _start (/sharedockerin/ta1729664329569nrnw/clouditera+0x285b4)\n\n0x60400000ff88 is located 8 bytes to the left of 40-byte region [0x60400000ff90,0x60400000ffb8)\nallocated by thread T0 here:\n    #0 0x7ff211f6b887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f149ef3460 in json_value_parse /sourcecode/src/util/json_parser.c:888\n    #2 0x55f149eea6a4 in fuzzloop /sharedockerin/ta1729664329569nrnw/test_file.cpp:27\n    #3 0x55f149f060c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/_include/workflow/list.h:100 in list_del\nShadow bytes around the buggy address:\n  0x0c087fff9fa0: fa fa fd fd fd fd fd fa fa fa fd fd fd fd fd fa\n  0x0c087fff9fb0: fa fa 00 00 00 00 00 fa fa fa fd fd fd fd fd fa\n  0x0c087fff9fc0: fa fa fd fd fd fd fd fa fa fa 00 00 00 00 00 fa\n  0x0c087fff9fd0: fa fa fd fd fd fd fd fa fa fa fd fd fd fd fd fa\n  0x0c087fff9fe0: fa fa 00 00 00 00 00 fa fa fa fd fd fd fd fd fa\n=>0x0c087fff9ff0: fa[fa]00 00 00 00 00 fa fa fa 00 00 00 00 00 fa\n  0x0c087fffa000: fa fa 00 00 00 00 00 fa fa fa fd fd fd fd fd fa\n  0x0c087fffa010: fa fa fd fd fd fd fd fa fa fa fd fd fd fd fd fa\n  0x0c087fffa020: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fa\n  0x0c087fffa030: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fd\n  0x0c087fffa040: fa fa fd fd fd fd fd fd fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: json_array_remove(json_value_t *val, json_array_t *arr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: json_array_remove\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/util -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <stdarg.h> //extract\n#include <string.h> //extract\n#include <ctype.h> //extract\n#include <math.h> //extract\n#include \"list.h\" //extract\n#include \"rbtree.h\" //extract\n#include \"json_parser.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    char * cursor = fuzzString(0);\n    json_value_t * val = json_value_parse(cursor);\n    if (val == NULL)\n        return 0;\n    char * cursor1 = fuzzString(1);\n    json_value_t * val1 = json_value_parse(cursor1);\n    if (val1 == NULL)\n        return 0;\n    json_array_t * arr = json_value_array(val1);\n    if (arr == NULL)\n        return 0;\n    json_value_t * ret = json_array_remove(val, arr);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/_include/workflow/list.h\n  98: static inline void list_del(struct list_head *entry)\n  99: {\n 100: \t__list_del(entry->prev, entry->next);\n 101: }\n 102: \nStacktrace #1:\nFile: /sourcecode/src/util/json_parser.c\n1266: json_value_t *json_array_remove(const json_value_t *val,\n1267: \t\t\t\t\t\t\t\tjson_array_t *arr)\n1268: {\n1269: \tjson_element_t *elem = list_entry(val, json_element_t, value);\n1270: \n1271: \tval = (json_value_t *)malloc(sizeof (json_value_t));\n1272: \tif (!val)\n1273: \t\treturn NULL;\n1274: \n1275: \tlist_del(&elem->list);\n1276: \tarr->size--;\n1277: \n1278: \t__move_json_value(&elem->value, (json_value_t *)val);\n1279: \tfree(elem);\n1280: \treturn (json_value_t *)val;\n1281: }\n1282:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==7252==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000134 at pc 0x55e1e3785bb7 bp 0x7fff38715f20 sp 0x7fff38715f10\nREAD of size 4 at 0x602000000134 thread T0\n    #0 0x55e1e3785bb6 in Communicator::create_reply(void*) /sourcecode/src/kernel/Communicator.cc:1322\n    #1 0x55e1e376ad74 in fuzzloop /dockerin/fuzz_drivers/tf1729593105304tufk.cpp:39\n    #2 0x55e1e37c4229 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e1e376ab38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fb0cd41ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fb0cd41ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e1e376ac84 in _start (/dockerin/fuzz_drivers/tf1729593105304tufk.out+0x83c84)\n\n0x602000000134 is located 24 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fb0ce045887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e1e37c443c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Communicator.cc:1322 in Communicator::create_reply(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa[fa]fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Communicator::create_reply(void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator12create_replyEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(0);\n    poller_message_t * ret = Communicator::create_reply(context);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1317: poller_message_t *Communicator::create_reply(void *context)\n1318: {\n1319: \tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n1320: \tCommSession *session;\n1321: \n1322: \tif (entry->state == CONN_STATE_IDLE)\n1323: \t{\n1324: \t\tpthread_mutex_lock(&entry->mutex);\n1325: \t\t/* do nothing */\n1326: \t\tpthread_mutex_unlock(&entry->mutex);\n1327: \t}\n1328: \n1329: \tif (entry->state != CONN_STATE_RECEIVING)\n1330: \t{\n1331: \t\terrno = EBADMSG;\n1332: \t\treturn NULL;\n1333: \t}\n1334: \n1335: \tsession = entry->session;\n1336: \tsession->in = session->message_in();\n1337: \tif (session->in)\n1338: \t{\n1339: \t\tsession->in->poller_message_t::append = Communicator::append_reply;\n1340: \t\tsession->in->entry = entry;\n1341: \t}\n1342: \n1343: \treturn session->in;\n1344: }\n1345:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==369573==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000118 at pc 0x559c2f5ec277 bp 0x7ffe5275a080 sp 0x7ffe5275a070\nREAD of size 8 at 0x602000000118 thread T0\n    #0 0x559c2f5ec276 in rb_last /sourcecode/src/kernel/rbtree.c:318\n    #1 0x559c2f5e6666 in fuzzloop /dockerin/fuzz_drivers/tf1729655884635rjbt.cpp:20\n    #2 0x559c2f5f5ae9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x559c2f5e6348 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f17bf57fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f17bf57fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x559c2f5e6494 in _start (/dockerin/fuzz_drivers/tf1729655884635rjbt.out+0x17494)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f17c01a6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x559c2f5f5cfc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/rbtree.c:318 in rb_last\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:57:46\n// Signature: rb_last(struct rb_root *root)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: rb_last\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/rbtree.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    struct rb_root root = RB_ROOT;\n    struct rb_node *node = (struct rb_node *)fuzzData(0);\n    root.rb_node = node;\n\n    struct rb_node *last_node = rb_last(&root);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/rbtree.c\n 311: struct rb_node *rb_last(struct rb_root *root)\n 312: {\n 313: \tstruct rb_node *n;\n 314: \n 315: \tn = root->rb_node;\n 316: \tif (!n)\n 317: \t\treturn (struct rb_node *)0;\n 318: \twhile (n->rb_right)\n 319: \t\tn = n->rb_right;\n 320: \treturn n;\n 321: }\n 322:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==208==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6180000083af at pc 0x56133dd4c720 bp 0x7ffd5263df90 sp 0x7ffd5263df80\nREAD of size 1 at 0x6180000083af thread T0\n    #0 0x56133dd4c71f in parse_row_packet /sourcecode/src/protocol/mysql_parser.c:332\n    #1 0x56133dd49262 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #2 0x56133dd4777b in fuzzloop /sharedockerin/ta1729664331891fgfr/test_file.cpp:21\n    #3 0x56133dd58bc9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x56133dd47448 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f9c7ac50d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f9c7ac50e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x56133dd47594 in _start (/sharedockerin/ta1729664331891fgfr/clouditera+0x19594)\n\n0x6180000083af is located 0 bytes to the right of 815-byte region [0x618000008080,0x6180000083af)\nallocated by thread T0 here:\n    #0 0x7f9c7b877887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56133dd58ddc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_parser.c:332 in parse_row_packet\nShadow bytes around the buggy address:\n  0x0c307fff9020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c307fff9030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c307fff9040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c307fff9050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c307fff9060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c307fff9070: 00 00 00 00 00[07]fa fa fa fa fa fa fa fa fa fa\n  0x0c307fff9080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c307fff9090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c307fff90a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c307fff90b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c307fff90c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:59:26\n// Signature: mysql_parser_get_net_state(char **net_state_str, size_t *net_state_len, mysql_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: mysql_parser_get_net_state\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/MySQLResult.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    mysql_parser_t parser;\n    mysql_parser_init(&parser);\n\n    char *buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n\n    mysql_parser_parse(buf, len, &parser);\n\n    const char *net_state_str;\n    size_t net_state_len;\n    mysql_parser_get_net_state(&net_state_str, &net_state_len, &parser);\n\n    mysql_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 306: static int parse_row_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 307: {\n 308: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 309: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 310: \n 311: \tunsigned long long cell_len;\n 312: \tconst unsigned char *cell_data;\n 313: \n 314: \tsize_t i;\n 315: \n 316: \tif (*p == MYSQL_PACKET_HEADER_ERROR)\n 317: \t{\n 318: \t\tparser->parse = parse_error_packet;\n 319: \t\treturn 0;\n 320: \t}\n 321: \n 322: \tif (*p == MYSQL_PACKET_HEADER_EOF)\n 323: \t{\n 324: \t\tparser->parse = parse_eof_packet;\n 325: \t\tparser->current_result_set->rows_end_offset = parser->offset;\n 326: \n 327: \t\treturn 0;\n 328: \t}\n 329: \n 330: \tfor (i = 0; i < parser->current_result_set->field_count; i++)\n 331: \t{\n 332: \t\tif (*p == MYSQL_PACKET_HEADER_NULL)\n 333: \t\t{\n 334: \t\t\tp++;\n 335: \t\t} else {\n 336: \t\t\tif (decode_string(&cell_data, &cell_len, &p, buf_end) == 0)\n 337: \t\t\t\tbreak;\n 338: \t\t}\n 339: \t}\n 340: \n 341: \tif (i != parser->current_result_set->field_count)\n 342: \t\treturn -2;\n 343: \n 344: \tparser->current_result_set->row_count++;\n 345: \tparser->offset = p - (const unsigned char *)buf;\n 346: \treturn 0;\n 347: }\n 348: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4107==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000019c at pc 0x7fad78d99397 bp 0x7ffcce335fb0 sp 0x7ffcce335758\nREAD of size 65535 at 0x60200000019c thread T0\n    #0 0x7fad78d99396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x7fad781bd204 in PKCS5_pbe_set0_algor_ex crypto/asn1/p5_pbe.c:57\n    #2 0x7fad781bd54f in PKCS5_pbe_set_ex crypto/asn1/p5_pbe.c:101\n    #3 0x7fad781bd5bb in PKCS5_pbe_set crypto/asn1/p5_pbe.c:111\n    #4 0x55c4cedcb4dc in fuzzloop /dockerin/fuzz_drivers/tf1730183723804jatv.c:32\n    #5 0x55c4cedd3b19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55c4cedcb1e8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7fad77857d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7fad77857e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55c4cedcb334 in _start (/dockerin/fuzz_drivers/tf1730183723804jatv.out+0xe334)\n\n0x60200000019c is located 0 bytes to the right of 12-byte region [0x602000000190,0x60200000019c)\nallocated by thread T0 here:\n    #0 0x7fad78e13887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55c4cedd3d2c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 04 fa\n  0x0c047fff8020: fa fa 04 fa fa fa 04 fa fa fa 04 fa fa fa 00 04\n=>0x0c047fff8030: fa fa 00[04]fa fa 04 fa fa fa 04 fa fa fa 00 00\n  0x0c047fff8040: fa fa 00 00 fa fa 03 fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:22:59\n// Signature: PBMAC1_get1_pbkdf2_param(X509_ALGOR *macalg)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: PBMAC1_get1_pbkdf2_param\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto/asn1 -Icrypto/pkcs12 -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdio.h> //extract\n#include \"internal/cryptlib.h\" //extract\n#include <openssl/asn1t.h> //extract\n#include <openssl/x509.h> //extract\n#include <openssl/rand.h> //extract\n#include \"crypto/evp.h\" //extract\n#include \"internal/deprecated.h\" //extract\n#include <openssl/crypto.h> //extract\n#include <openssl/hmac.h> //extract\n#include <openssl/pkcs12.h> //extract\n#include \"p12_local.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    int alg = fuzzInt32(0);\n    int iter = fuzzInt32(1);\n    unsigned char * salt = (unsigned char *)fuzzData(2);\n    int saltlen = fuzzInt32(3);\n    X509_ALGOR * macalg = PKCS5_pbe_set(alg, iter, salt, saltlen);\n    if (macalg == NULL)\n        return 0;\n    PBKDF2PARAM * ret = PBMAC1_get1_pbkdf2_param(macalg);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/asn1/p5_pbe.c\n  28: int PKCS5_pbe_set0_algor_ex(X509_ALGOR *algor, int alg, int iter,\n  29:                             const unsigned char *salt, int saltlen,\n  30:                             OSSL_LIB_CTX *ctx)\n  31: {\n  32:     PBEPARAM *pbe = NULL;\n  33:     ASN1_STRING *pbe_str = NULL;\n  34:     unsigned char *sstr = NULL;\n  35: \n  36:     pbe = PBEPARAM_new();\n  37:     if (pbe == NULL) {\n  38:         /* ERR_R_ASN1_LIB, because PBEPARAM_new() is defined in crypto/asn1 */\n  39:         ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);\n  40:         goto err;\n  41:     }\n  42:     if (iter <= 0)\n  43:         iter = PKCS5_DEFAULT_ITER;\n  44:     if (!ASN1_INTEGER_set(pbe->iter, iter)) {\n  45:         ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);\n  46:         goto err;\n  47:     }\n  48:     if (!saltlen)\n  49:         saltlen = PKCS5_DEFAULT_PBE1_SALT_LEN;\n  50:     if (saltlen < 0)\n  51:         goto err;\n  52: \n  53:     sstr = OPENSSL_malloc(saltlen);\n  54:     if (sstr == NULL)\n  55:         goto err;\n  56:     if (salt)\n  57:         memcpy(sstr, salt, saltlen);\n  58:     else if (RAND_bytes_ex(ctx, sstr, saltlen, 0) <= 0)\n  59:         goto err;\n  60: \n  61:     ASN1_STRING_set0(pbe->salt, sstr, saltlen);\n  62:     sstr = NULL;\n  63: \n  64:     if (!ASN1_item_pack(pbe, ASN1_ITEM_rptr(PBEPARAM), &pbe_str)) {\n  65:         ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);\n  66:         goto err;\n  67:     }\n  68: \n  69:     PBEPARAM_free(pbe);\n  70:     pbe = NULL;\n  71: \n  72:     if (X509_ALGOR_set0(algor, OBJ_nid2obj(alg), V_ASN1_SEQUENCE, pbe_str))\n  73:         return 1;\n  74: \n  75:  err:\n  76:     OPENSSL_free(sstr);\n  77:     PBEPARAM_free(pbe);\n  78:     ASN1_STRING_free(pbe_str);\n  79:     return 0;\n  80: }\n  81: \nStacktrace #1:\nFile: /sourcecode/crypto/asn1/p5_pbe.c\n  90: X509_ALGOR *PKCS5_pbe_set_ex(int alg, int iter,\n  91:                              const unsigned char *salt, int saltlen,\n  92:                              OSSL_LIB_CTX *ctx)\n  93: {\n  94:     X509_ALGOR *ret;\n  95:     ret = X509_ALGOR_new();\n  96:     if (ret == NULL) {\n  97:         ERR_raise(ERR_LIB_ASN1, ERR_R_X509_LIB);\n  98:         return NULL;\n  99:     }\n 100: \n 101:     if (PKCS5_pbe_set0_algor_ex(ret, alg, iter, salt, saltlen, ctx))\n 102:         return ret;\n 103: \n 104:     X509_ALGOR_free(ret);\n 105:     return NULL;\n 106: }\n 107: \nStacktrace #2:\nFile: /sourcecode/crypto/asn1/p5_pbe.c\n 108: X509_ALGOR *PKCS5_pbe_set(int alg, int iter,\n 109:                           const unsigned char *salt, int saltlen)\n 110: {\n 111:     return PKCS5_pbe_set_ex(alg, iter, salt, saltlen, NULL);\n 112: }\n 113:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3805==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000008 at pc 0x55575a0f3a7f bp 0x7ffdc9488c70 sp 0x7ffdc9488c60\nWRITE of size 2 at 0x602000000008 thread T0\n    #0 0x55575a0f3a7e in block_free /sourcecode/lib/facil/fio.c:7837\n    #1 0x55575a0f454d in block_slice_free /sourcecode/lib/facil/fio.c:7935\n    #2 0x55575a0f4e23 in fio_free /sourcecode/lib/facil/fio.c:8097\n    #3 0x55575a0f4e9c in fio_realloc2 /sourcecode/lib/facil/fio.c:8129\n    #4 0x55575a07d280 in fuzzloop /dockerin/fuzz_drivers/tf1729822403000wskc.c:27\n    #5 0x55575a12ce79 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55575a07c9d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f50f36d2d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f50f36d2e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55575a07cb24 in _start (/dockerin/fuzz_drivers/tf1729822403000wskc.out+0xc5b24)\n\n0x602000000008 is located 8 bytes to the left of 15-byte region [0x602000000010,0x60200000001f)\nallocated by thread T0 here:\n    #0 0x7f50f40ab887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7f50f375158e in strdup (/lib/x86_64-linux-gnu/libc.so.6+0xa858e)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:7837 in block_free\nShadow bytes around the buggy address:\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c047fff8000: fa[fa]00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa fd fd\n  0x0c047fff8020: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8030: fa fa fd fa fa fa 00 04 fa fa 00 fa fa fa 00 fa\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_realloc2(void *ptr, size_t new_size, size_t copy_length)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_realloc2\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib/facil/legacy\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <time.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <fio_mem.h> //extract\n#include \"lib/facil/fio.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ptr = (void *)fuzzData(0);\n    size_t new_size = (size_t)fuzzUint64(1);\n    size_t copy_length = (size_t)fuzzUint64(2);\n    void * ret = fio_realloc2(ptr, new_size, copy_length);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7827:   blk->pos = FIO_MEMORY_BLOCK_START_POS;\n7828:   /* zero out linked list memory (everything else is already zero) */\n7829:   ((block_node_s *)blk)->node.next = NULL;\n7830:   ((block_node_s *)blk)->node.prev = NULL;\n7831:   /* bump parent reference count */\n7832:   fio_atomic_add(&blk->parent->root_ref, 1);\n7833: }\n7834: \n7835: /* intializes the block header for an available block of memory. */\n7836: static inline void block_free(block_s *blk) {\n7837:   if (fio_atomic_sub(&blk->ref, 1))\n7838:     return;\n7839: \n7840:   memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n7841:   fio_lock(&memory.lock);\n7842:   fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n7843: \n7844:   blk = blk->parent;\n7845: \n7846:   if (fio_atomic_sub(&blk->root_ref, 1)) {\n7847:     fio_unlock(&memory.lock);\n7848: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n7925:     block_free(blk);\n7926:     arena_last_used->block = NULL;\n7927:   }\n7928:   return (void *)mem;\n7929: }\n7930: \n7931: /* handle's a bock's reference count - called without a lock */\n7932: static inline void block_slice_free(void *mem) {\n7933:   /* locate block boundary */\n7934:   block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n7935:   block_free(blk);\n7936: }\n7937: \n7938: /* *****************************************************************************\n7939: Non-Block allocations (direct from the system)\n7940: ***************************************************************************** */\n7941: \n7942: /* allocates directly from the system adding size header - no lock required. */\n7943: static inline void *big_alloc(size_t size) {\n7944:   size = sys_round_size(size + 16);\n7945:   size_t *mem = sys_alloc(size, 1);\n7946: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8087: \n8088: void fio_free(void *ptr) {\n8089:   if (!ptr || ptr == (void *)&on_malloc_zero)\n8090:     return;\n8091:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8092:     /* big allocation - direct from the system */\n8093:     big_free(ptr);\n8094:     return;\n8095:   }\n8096:   /* allocated within block */\n8097:   block_slice_free(ptr);\n8098: }\n8099: \n8100: /**\n8101:  * Re-allocates memory. An attept to avoid copying the data is made only for big\n8102:  * memory allocations.\n8103:  *\n8104:  * This variation is slightly faster as it might copy less data\n8105:  */\n8106: void *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n8107:   if (!ptr || ptr == (void *)&on_malloc_zero) {\n8108: \nStacktrace #3:\nFile: /sourcecode/lib/facil/fio.c\n8119:   void *new_mem = fio_malloc(new_size);\n8120:   if (!new_mem)\n8121:     return NULL;\n8122:   new_size = ((new_size >> 4) + (!!(new_size & 15)));\n8123:   copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n8124:   fio_memcpy(new_mem, ptr, copy_length > new_size ? new_size : copy_length);\n8125: \n8126:   block_slice_free(ptr);\n8127:   return new_mem;\n8128: zero_size:\n8129:   fio_free(ptr);\n8130:   return fio_malloc(0);\n8131: }\n8132: \n8133: void *fio_realloc(void *ptr, size_t new_size) {\n8134:   const size_t max_old =\n8135:       FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK);\n8136:   return fio_realloc2(ptr, new_size, max_old);\n8137: }\n8138: \n8139: /**\n8140:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==130==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000026c2 at pc 0x55fe5c86cfbc bp 0x7ffcd7478250 sp 0x7ffcd7478240\nWRITE of size 1 at 0x6020000026c2 thread T0\n    #0 0x55fe5c86cfbb in fio_ltoa /sourcecode/lib/facil/fio.c:4905\n    #1 0x55fe5c86e169 in fio_ftoa /sourcecode/lib/facil/fio.c:4994\n    #2 0x55fe5c82a288 in fuzzloop /sharedockerin/ta1729829438589flem/test_file.c:39\n    #3 0x55fe5c8d9e69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55fe5c8299d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fd669870d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fd669870e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55fe5c829b24 in _start (/sharedockerin/ta1729829438589flem/clouditera+0xc5b24)\n\n0x6020000026c2 is located 6 bytes to the right of 12-byte region [0x6020000026b0,0x6020000026bc)\nallocated by thread T0 here:\n    #0 0x7fd66a249887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55fe5c8da07c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:4905 in fio_ltoa\nShadow bytes around the buggy address:\n  0x0c047fff8480: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 05\n  0x0c047fff8490: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff84a0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff84b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff84c0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\n=>0x0c047fff84d0: fa fa fd fa fa fa 00 04[fa]fa 00 fa fa fa 01 fa\n  0x0c047fff84e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff84f0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8500: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8510: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8520: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: fio_ftoa(char *dest, double num, uint8_t base)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_ftoa\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    double num = fuzzDouble(1);\n    uint8_t base = fuzzUint8(2);\n    size_t ret = fio_ftoa(dest, num, base);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4821: size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n4822:   const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n4823:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n4824: \n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n4831:   switch (base) {\n4832:   case 1: /* fallthrough */\n4833:   case 2:\n4834:     /* Base 2 */\n4835:     {\n4836:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4837:       uint8_t i = 0;    /* counting bits */\n4838:       dest[len++] = '0';\n4839:       dest[len++] = 'b';\n4840: \n4841:       while ((i < 64) && (n & 0x8000000000000000) == 0) {\n4842:         n = n << 1;\n4843:         i++;\n4844:       }\n4845:       /* make sure the Binary representation doesn't appear signed. */\n4846:       if (i) {\n4847:         dest[len++] = '0';\n4848:       }\n4849:       /* write to dest. */\n4850:       while (i < 64) {\n...skip...\n4875:       }\n4876:       dest[len] = 0;\n4877:       return len;\n4878:     }\n4879: \n4880:   case 16:\n4881:     /* Base 16 */\n4882:     {\n4883:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4884:       uint8_t i = 0;    /* counting bits */\n4885:       dest[len++] = '0';\n4886:       dest[len++] = 'x';\n4887:       while (i < 8 && (n & 0xFF00000000000000) == 0) {\n4888:         n = n << 8;\n4889:         i++;\n4890:       }\n4891:       /* make sure the Hex representation doesn't appear misleadingly signed. */\n4892:       if (i && (n & 0x8000000000000000)) {\n4893:         dest[len++] = '0';\n4894:         dest[len++] = '0';\n4895:       }\n4896:       /* write the damn thing, high to low */\n4897:       while (i < 8) {\n4898:         uint8_t tmp = (n & 0xF000000000000000) >> 60;\n4899:         dest[len++] = notation[tmp];\n4900:         tmp = (n & 0x0F00000000000000) >> 56;\n4901:         dest[len++] = notation[tmp];\n4902:         i++;\n4903:         n = n << 8;\n4904:       }\n4905:       dest[len] = 0;\n4906:       return len;\n4907:     }\n4908:   case 3: /* fallthrough */\n4909:   case 4: /* fallthrough */\n4910:   case 5: /* fallthrough */\n4911:   case 6: /* fallthrough */\n4912:   case 7: /* fallthrough */\n4913:   case 9: /* fallthrough */\n4914:     /* rare bases */\n4915:     if (num < 0) {\n4916:       dest[len++] = '-';\n4917:       num = 0 - num;\n4918:     }\n4919:     uint64_t l = 0;\n4920:     while (num) {\n4921:       uint64_t t = num / base;\n4922:       buf[l++] = '0' + (num - (t * base));\n4923:       num = t;\n4924:     }\n4925:     while (l) {\n4926:       --l;\n4927:       dest[len++] = buf[l];\n4928:     }\n4929:     dest[len] = 0;\n4930:     return len;\n4931: \n4932:   default:\n4933:     break;\n4934:   }\n...skip...\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960:     break;\n4961:   case 8:\n4962:     dest[len++] = '0';\n4963:     break;\n4964:   case 16:\n4965:     dest[len++] = '0';\n4966:     dest[len++] = 'x';\n4967:     dest[len++] = '0';\n4968:     break;\n4969:   }\n4970:   dest[len++] = '0';\n4971:   dest[len] = 0;\n4972:   return len;\n4973: }\n4974: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n4988: size_t fio_ftoa(char *dest, double num, uint8_t base) {\n4989:   if (base == 2 || base == 16) {\n4990:     /* handle the binary / Hex representation the same as if it were an\n4991:      * int64_t\n4992:      */\n4993:     int64_t *i = (void *)&num;\n4994:     return fio_ltoa(dest, *i, base);\n4995:   }\n4996: \n4997:   size_t written = sprintf(dest, \"%g\", num);\n4998:   uint8_t need_zero = 1;\n4999:   char *start = dest;\n5000:   while (*start) {\n5001:     if (*start == ',') // locale issues?\n5002:       *start = '.';\n5003:     if (*start == '.' || *start == 'e') {\n5004:       need_zero = 0;\n5005:       break;\n5006:     }\n5007:     start++;\n5008:   }\n5009:   if (need_zero) {\n5010:     dest[written++] = '.';\n5011:     dest[written++] = '0';\n5012:   }\n5013:   return written;\n5014: }\n5015:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==37917==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000148 at pc 0x56228941e8fd bp 0x7ffdfd457f20 sp 0x7ffdfd457f10\nREAD of size 8 at 0x602000000148 thread T0\n    #0 0x56228941e8fc in ossl_quic_sstream_adjust_iov ssl/quic/quic_sstream.c:410\n    #1 0x56228941b69a in fuzzloop /dockerin/fuzz_drivers/tf1730183726446ixgq.c:33\n    #2 0x562289428be9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56228941b3c8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f0969132d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f0969132e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56228941b514 in _start (/dockerin/fuzz_drivers/tf1730183726446ixgq.out+0xf514)\n\n0x602000000148 is located 8 bytes to the left of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f09699be887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562289428dfc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ssl/quic/quic_sstream.c:410 in ossl_quic_sstream_adjust_iov\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 fa\n=>0x0c047fff8020: fa fa 00 fa fa fa 00 00 fa[fa]00 04 fa fa 00 04\n  0x0c047fff8030: fa fa 00 fa fa fa 00 fa fa fa 00 fa fa fa 00 fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:25:40\n// Signature: ossl_quic_sstream_adjust_iov(size_t len, OSSL_QTX_IOVEC *iov, size_t num_iov)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_quic_sstream_adjust_iov\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Issl/quic -DAES_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/quic_stream.h\" //extract\n#include \"internal/uint_set.h\" //extract\n#include \"internal/common.h\" //extract\n#include \"internal/ring_buf.h\" //extract\n#include \"include/internal/quic_record_tx.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    size_t len = (size_t)fuzzUint64(0);\n    //file: include/internal/quic_record_tx.h:26\n    //typedef struct ossl_qtx_iovec_st {\n    //    const unsigned char    *buf;\n    //    size_t                  buf_len;\n    //} OSSL_QTX_IOVEC;\n    struct ossl_qtx_iovec_st *iov = (struct ossl_qtx_iovec_st *)driverAllocMem(sizeof(struct ossl_qtx_iovec_st));\n    iov->buf = (unsigned char *)fuzzData(1);\n    iov->buf_len = (unsigned long)fuzzUint64(2);\n    \n    size_t num_iov = (size_t)fuzzUint64(3);\n    ossl_quic_sstream_adjust_iov(len, iov, num_iov);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/ssl/quic/quic_sstream.c\n 403: void ossl_quic_sstream_adjust_iov(size_t len,\n 404:                                   OSSL_QTX_IOVEC *iov,\n 405:                                   size_t num_iov)\n 406: {\n 407:     size_t running = 0, i, iovlen;\n 408: \n 409:     for (i = 0, running = 0; i < num_iov; ++i) {\n 410:         iovlen = iov[i].buf_len;\n 411: \n 412:         if (running >= len)\n 413:             iov[i].buf_len = 0;\n 414:         else if (running + iovlen > len)\n 415:             iov[i].buf_len = len - running;\n 416: \n 417:         running += iovlen;\n 418:     }\n 419: }\n 420:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2328==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000001e0 at pc 0x560900bc33db bp 0x7ffec8111610 sp 0x7ffec8111600\nREAD of size 4 at 0x6020000001e0 thread T0\n    #0 0x560900bc33da in flatcc_generate_files /sourcecode/src/compiler/flatcc.c:457\n    #1 0x560900ba497c in fuzzloop /dockerin/fuzz_drivers/tf1727601035341kwev.c:25\n    #2 0x560900d195c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x560900ba46f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f90b98b3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f90b98b3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x560900ba4844 in _start (/dockerin/fuzz_drivers/tf1727601035341kwev.out+0x1e3844)\n\n0x6020000001e0 is located 196 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f90ba28c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x560900d197dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/flatcc.c:457 in flatcc_generate_files\nShadow bytes around the buggy address:\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa[fa]fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_generate_files\n// Sign: flatcc_generate_files(flatcc_context_t ctx)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <assert.h> //extract\n#include \"config.h\" //extract\n#include \"parser.h\" //extract\n#include \"semantics.h\" //extract\n#include \"fileio.h\" //extract\n#include \"codegen.h\" //extract\n#include \"flatcc/flatcc.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ctx = (void *)fuzzData(0);\n    int ret = flatcc_generate_files(ctx);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/flatcc.c\n 450: int flatcc_generate_files(flatcc_context_t ctx)\n 451: {\n 452:     fb_parser_t *P = ctx, *P_leaf;\n 453:     fb_output_t *out, output;\n 454:     int ret = 0;\n 455:     out = &output;\n 456: \n 457:     if (!P || P->failed) {\n 458:         return -1;\n 459:     }\n 460:     P_leaf = 0;\n 461:     while (P) {\n 462:         P->inverse_dependencies = P_leaf;\n 463:         P_leaf = P;\n 464:         P = P->dependencies;\n 465:     }\n 466:     P = ctx;\n 467: #if FLATCC_REFLECTION\n 468:     if (P->opts.bgen_bfbs) {\n 469:         if (fb_codegen_bfbs_to_file(&P->opts, &P->schema)) {\n 470:             return -1;\n 471:         }\n 472:     }\n 473: #endif\n 474: #ifdef PR216\n 475:     /* Note: P->opts.cgen now represents the below expression, and bfbs_gen is mutually exclusive with cgen */\n 476:     if (!(P->opts.cgen_reader | P->opts.cgen_builder | P->opts.cgen_verifier\n 477:         | P->opts.cgen_common_reader | P->opts.cgen_common_builder\n 478:         | P->opts.cgen_json_parser | P->opts.cgen_json_printer)) {\n 479:         return 0;\n 480:     }\n 481: #else\n 482:     /* Experimental alternative to PR216 */\n 483:     if (P->opts.bgen_bfbs) {\n 484:         return 0;\n 485:     }\n 486: #endif\n 487:     if (fb_init_output_c(out, &P->opts)) {\n 488:         return -1;\n 489:     }\n 490:     /* This does not require a parse first. */\n 491:     if (!P->opts.gen_append && (ret = fb_codegen_common_c(out))) {\n 492:         goto done;\n 493:     }\n 494:     /* If no file parsed - just common files if at all. */\n 495:     if (!P->has_schema) {\n 496:         goto done;\n 497:     }\n 498:     if (!P->opts.cgen_recursive) {\n 499:         ret = fb_codegen_c(out, &P->schema);\n 500:         goto done;\n 501:     }\n 502:     /* Make sure stdout and outfile output is generated in the right order. */\n 503:     P = P_leaf;\n 504:     while (!ret && P) {\n 505:         ret = P->failed || fb_codegen_c(out, &P->schema);\n 506:         P = P->inverse_dependencies;\n 507:     }\n 508: done:\n 509:     fb_end_output_c(out);\n 510:     return ret;\n 511: }\n 512:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==227==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000004912 at pc 0x55b9b0b38d00 bp 0x7ffd4ca582c0 sp 0x7ffd4ca582b0\nREAD of size 2 at 0x602000004912 thread T0\n    #0 0x55b9b0b38cff in uint2korr /sourcecode/src/protocol/mysql_byteorder.h:44\n    #1 0x55b9b0b3949d in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:45\n    #2 0x55b9b0b39909 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x55b9b0b3720b in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:410\n    #4 0x55b9b0b3296a in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x55b9b0b31703 in fuzzloop /sharedockerin/ta1729664331306rwdc/test_file.cpp:21\n    #6 0x55b9b0b422c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55b9b0b313e8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7fc1c2daad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7fc1c2daae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55b9b0b31534 in _start (/sharedockerin/ta1729664331306rwdc/clouditera+0x18534)\n\n0x602000004913 is located 0 bytes to the right of 3-byte region [0x602000004910,0x602000004913)\nallocated by thread T0 here:\n    #0 0x7fc1c39d1887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55b9b0b424dc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_byteorder.h:44 in uint2korr\nShadow bytes around the buggy address:\n  0x0c047fff88d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fd fa\n  0x0c047fff88e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 07\n  0x0c047fff88f0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fd\n  0x0c047fff8900: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fa\n  0x0c047fff8910: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff8920: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8930: fa fa fa fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8940: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8950: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8960: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fa fa\n  0x0c047fff8970: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 11:01:23\n// Signature: mysql_parser_parse(void *buf, size_t len, mysql_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: mysql_parser_parse\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/mysql_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    mysql_parser_t parser;\n    mysql_parser_init(&parser);\n\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n\n    mysql_parser_parse(buf, len, &parser);\n\n    mysql_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  42: static inline uint16_t uint2korr(const unsigned char *A)\n  43: {\n  44: \tuint16_t ret;\n  45: \tmemcpy(&ret, A, sizeof(ret));\n  46: \treturn ret;\n  47: }\n  48: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #4:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==26091==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000b8 at pc 0x55ae4892acd0 bp 0x7ffe46121c50 sp 0x7ffe46121c40\nREAD of size 4 at 0x6060000000b8 thread T0\n    #0 0x55ae4892accf in UPSGroupPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:292\n    #1 0x55ae48930e3d in UPSWeightedRandomPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:480\n    #2 0x55ae4891e04c in fuzzloop /dockerin/fuzz_drivers/tf1729593105361sjjz.cpp:41\n    #3 0x55ae48aebee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55ae4891d978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fc2e8d39d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fc2e8d39e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55ae4891dac4 in _start (/dockerin/fuzz_drivers/tf1729593105361sjjz.out+0x381ac4)\n\n0x6060000000b8 is located 0 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7fc2e99621e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55ae4891f2db in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x55ae4891dd99 in fuzzloop /dockerin/fuzz_drivers/tf1729593105361sjjz.cpp:39\n    #3 0x55ae48aebee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:292 in UPSGroupPolicy::add_server_locked(EndpointAddress*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSWeightedRandomPolicy::add_server_locked(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy17add_server_lockedEP15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/UpstreamPolicies.h\" //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"URIParser.h\" //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    bool try_another = fuzzBool(0);\n    auto upsweightedrandompolicy = std::make_unique<UPSWeightedRandomPolicy>(try_another);\n    std::string address = fuzzString(1);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsweightedrandompolicy->add_server_locked(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 289: void UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n 290: {\n 291: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 292: \tint group_id = params->group_id;\n 293: \trb_node **p = &this->group_map.rb_node;\n 294: \trb_node *parent = NULL;\n 295: \tEndpointGroup *group;\n 296: \n 297: \tthis->server_map[addr->address].push_back(addr);\n 298: \n 299: \tif (params->server_type == 0)\n 300: \t\tthis->servers.push_back(addr);\n 301: \n 302: \twhile (*p)\n 303: \t{\n 304: \t\tparent = *p;\n 305: \t\tgroup = rb_entry(*p, EndpointGroup, rb);\n 306: \n 307: \t\tif (group_id < group->id)\n 308: \t\t\tp = &(*p)->rb_left;\n 309: \t\telse if (group_id > group->id)\n 310: \t\t\tp = &(*p)->rb_right;\n 311: \t\telse\n 312: \t\t\tbreak;\n 313: \t}\n 314: \n 315: \tif (*p == NULL)\n 316: \t{\n 317: \t\tgroup = new EndpointGroup(group_id, this);\n 318: \t\trb_link_node(&group->rb, parent, p);\n 319: \t\trb_insert_color(&group->rb, &this->group_map);\n 320: \t}\n 321: \n 322: \tpthread_mutex_lock(&group->mutex);\n 323: \tparams->group = group;\n 324: \tthis->recover_one_server(addr);\n 325: \tif (params->server_type == 0)\n 326: \t{\n 327: \t\tgroup->mains.push_back(addr);\n 328: \t\tgroup->weight += params->weight;\n 329: \t}\n 330: \telse\n 331: \t\tgroup->backups.push_back(addr);\n 332: \tpthread_mutex_unlock(&group->mutex);\n 333: }\n 334: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 476: void UPSWeightedRandomPolicy::add_server_locked(EndpointAddress *addr)\n 477: {\n 478: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 479: \n 480: \tUPSGroupPolicy::add_server_locked(addr);\n 481: \tif (params->server_type == 0)\n 482: \t\tthis->total_weight += params->weight;\n 483: }\n 484:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==634252==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x5584971468d4 bp 0x7fff479759f0 sp 0x7fff479759e0\nREAD of size 4 at 0x602000000120 thread T0\n    #0 0x5584971468d3 in IOService::request(IOSession*) /sourcecode/src/kernel/IOService_linux.cc:326\n    #1 0x5584971427de in IORequest::dispatch() _include/workflow/IORequest.h:37\n    #2 0x55849714184c in fuzzloop /dockerin/fuzz_drivers/tf1729655877560calw.cpp:36\n    #3 0x558497151219 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x558497141488 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fc832529d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fc832529e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x5584971415d4 in _start (/dockerin/fuzz_drivers/tf1729655877560calw.out+0x1a5d4)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fc833150887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55849715142c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/IOService_linux.cc:326 in IOService::request(IOSession*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:56:51\n// Signature: IORequest::IORequest(IOService *service)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN9IORequestC1EP9IOService\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/IORequest.h\"\n#include \"_include/workflow/SubTask.h\"\n#include \"_include/workflow/IOService_linux.h\"\n\n// Concrete subclass of IORequest to implement pure virtual functions\nclass ConcreteIORequest : public IORequest {\npublic:\n    ConcreteIORequest(IOService *service) : IORequest(service) {}\n\n    // Implement the pure virtual functions\n    virtual int prepare() override {\n        // Implement the prepare function\n        return 0; // Placeholder implementation\n    }\n\n    virtual SubTask* done() override {\n        // Implement the done function\n        return nullptr; // Placeholder implementation\n    }\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    IOService *service = (IOService *)fuzzData(0);\n    ConcreteIORequest request(service);\n    request.dispatch();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/IOService_linux.cc\n 316: \t\tthis->handle_unbound();\n 317: \t}\n 318: }\n 319: \n 320: int IOService::request(IOSession *session)\n 321: {\n 322: \tstruct iocb *iocb = (struct iocb *)session->iocb_buf;\n 323: \tint ret = -1;\n 324: \n 325: \tpthread_mutex_lock(&this->mutex);\n 326: \tif (this->event_fd < 0)\n 327: \t\terrno = ENOENT;\n 328: \telse if (session->prepare() >= 0)\n 329: \t{\n 330: \t\tio_set_eventfd(iocb, this->event_fd);\n 331: \t\tiocb->data = session;\n 332: \t\tif (io_submit(this->io_ctx, 1, &iocb) > 0)\n 333: \t\t{\n 334: \t\t\tlist_add_tail(&session->list, &this->session_list);\n 335: \t\t\tret = 0;\n 336: \t\t}\n 337: \nStacktrace #1:\nFile: /sourcecode/_include/workflow/IORequest.h\n  35: \tvirtual void dispatch()\n  36: \t{\n  37: \t\tif (this->service->request(this) < 0)\n  38: \t\t\tthis->handle(IOS_STATE_ERROR, errno);\n  39: \t}\n  40:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "高危", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==16725==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000c0 at pc 0x55aa822cc99a bp 0x7fff88619d70 sp 0x7fff88619d60\nREAD of size 8 at 0x6060000000c0 thread T0\n    #0 0x55aa822cc999 in UPSGroupPolicy::recover_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:119\n    #1 0x55aa822c4ff0 in fuzzloop /dockerin/fuzz_drivers/tf1729593105348wwks.cpp:39\n    #2 0x55aa824927c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55aa822c4978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fc53c399d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fc53c399e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55aa822c4ac4 in _start (/dockerin/fuzz_drivers/tf1729593105348wwks.out+0x380ac4)\n\n0x6060000000c0 is located 8 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7fc53cfc21e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55aa822c5bfb in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x55aa822c4d3d in fuzzloop /dockerin/fuzz_drivers/tf1729593105348wwks.cpp:37\n    #3 0x55aa824927c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:119 in UPSGroupPolicy::recover_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00 fa[fa]fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSGroupPolicy::recover_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14UPSGroupPolicy18recover_one_serverEPK15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"URIParser.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    auto upsgrouppolicy = std::make_unique<UPSGroupPolicy>();\n    std::string address = fuzzString(0);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsgrouppolicy->recover_one_server(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 115: void UPSGroupPolicy::recover_one_server(const EndpointAddress *addr)\n 116: {\n 117: \tthis->nalives++;\n 118: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 119: \tparams->group->nalives++;\n 120: }\n 121:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000022751 at pc 0x556c194f6965 bp 0x7ffec82fcbb0 sp 0x7ffec82fcba0\nREAD of size 2 at 0x602000022751 thread T0\n    #0 0x556c194f6964 in uint2korr /sourcecode/src/protocol/mysql_byteorder.h:44\n    #1 0x556c194f7102 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:45\n    #2 0x556c194f672e in fuzzloop /sharedockerin/ta1729664329765ysdw/test_file.cpp:24\n    #3 0x556c194fff29 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x556c194f63a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f240b07cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f240b07ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x556c194f64f4 in _start (/sharedockerin/ta1729664329765ysdw/clouditera+0xf4f4)\n\n0x602000022752 is located 0 bytes to the right of 2-byte region [0x602000022750,0x602000022752)\nallocated by thread T0 here:\n    #0 0x7f240bca3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556c1950013c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/protocol/mysql_byteorder.h:44 in uint2korr\nShadow bytes around the buggy address:\n  0x0c047fffc490: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffc4a0: fa fa fd fa fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffc4b0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffc4c0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fffc4d0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fa\n=>0x0c047fffc4e0: fa fa fd fd fa fa fd fa fa fa[02]fa fa fa fa fa\n  0x0c047fffc4f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc500: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc510: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc520: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc530: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:40:09\n// Signature: decode_length_safe(unsigned long long *res, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_length_safe\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    unsigned long long res;\n    const unsigned char *pos;\n    const unsigned char *end;\n\n    char *data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    pos = reinterpret_cast<const unsigned char*>(data);\n    end = reinterpret_cast<const unsigned char*>(data + len);\n\n    decode_length_safe(&res, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  42: static inline uint16_t uint2korr(const unsigned char *A)\n  43: {\n  44: \tuint16_t ret;\n  45: \tmemcpy(&ret, A, sizeof(ret));\n  46: \treturn ret;\n  47: }\n  48: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==12748==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x56537c9942a2 bp 0x7fff49c68d80 sp 0x7fff49c68d70\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x56537c9942a1 in SHA1_Final include/crypto/md32_common.h:248\n    #1 0x56537c9947f2 in fuzzloop /dockerin/fuzz_drivers/tf1730183724123qutv.c:36\n    #2 0x56537c9a1689 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56537c993288 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f61b63e9d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f61b63e9e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56537c9933d4 in _start (/dockerin/fuzz_drivers/tf1730183724123qutv.out+0xe3d4)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f61b6c75887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56537c9a189c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow include/crypto/md32_common.h:248 in SHA1_Final\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:23:37\n// Signature: SHA1_Final(unsigned char *md, SHA_CTX *c)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: SHA1_Final\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Iinclude/crypto -Icrypto/sha -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"internal/deprecated.h\" //extract\n#include <openssl/crypto.h> //extract\n#include <openssl/opensslconf.h> //extract\n#include <openssl/opensslv.h> //extract\n#include <openssl/evp.h> //extract\n#include <openssl/sha.h> //extract\n#include \"sha_local.h\" //extract\n#include \"crypto/sha.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned char * md = (unsigned char *)fuzzData(0);\n    //file: include/openssl/sha.h:42\n    //typedef struct SHAstate_st {\n    //    SHA_LONG h0, h1, h2, h3, h4;\n    //    SHA_LONG Nl, Nh;\n    //    SHA_LONG data[SHA_LBLOCK];\n    //    unsigned int num;\n    //} SHA_CTX;\n    struct SHAstate_st *c = (struct SHAstate_st *)driverAllocMem(sizeof(struct SHAstate_st));\n    char *temp = fuzzFixBlob(1, sizeof(struct SHAstate_st));\n    memcpy(c, temp, sizeof(c));\n    int ret = SHA1_Final(md, c);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/crypto/md32_common.h\n 217: int HASH_FINAL(unsigned char *md, HASH_CTX *c)\n 218: {\n 219:     unsigned char *p = (unsigned char *)c->data;\n 220:     size_t n = c->num;\n 221: \n 222:     p[n] = 0x80;                /* there is always room for one */\n 223:     n++;\n 224: \n 225:     if (n > (HASH_CBLOCK - 8)) {\n 226:         memset(p + n, 0, HASH_CBLOCK - n);\n 227:         n = 0;\n 228:         HASH_BLOCK_DATA_ORDER(c, p, 1);\n 229:     }\n 230:     memset(p + n, 0, HASH_CBLOCK - 8 - n);\n 231: \n 232:     p += HASH_CBLOCK - 8;\n 233: # if   defined(DATA_ORDER_IS_BIG_ENDIAN)\n 234:     (void)HOST_l2c(c->Nh, p);\n 235:     (void)HOST_l2c(c->Nl, p);\n 236: # elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)\n 237:     (void)HOST_l2c(c->Nl, p);\n 238:     (void)HOST_l2c(c->Nh, p);\n 239: # endif\n 240:     p -= HASH_CBLOCK;\n 241:     HASH_BLOCK_DATA_ORDER(c, p, 1);\n 242:     c->num = 0;\n 243:     OPENSSL_cleanse(p, HASH_CBLOCK);\n 244: \n 245: # ifndef HASH_MAKE_STRING\n 246: #  error \"HASH_MAKE_STRING must be defined!\"\n 247: # else\n 248:     HASH_MAKE_STRING(c, md);\n 249: # endif\n 250: \n 251:     return 1;\n 252: }\n 253:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "高危", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==28431==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x61b000000078 at pc 0x55ca4bc5cc91 bp 0x7ffdcf7e2490 sp 0x7ffdcf7e2480\nWRITE of size 8 at 0x61b000000078 thread T0\n    #0 0x55ca4bc5cc90 in WFResourcePool::push(void*) /sourcecode/src/factory/WFResourcePool.h:56\n    #1 0x55ca4bce18b7 in WFResourcePool::post(void*) /sourcecode/src/factory/WFResourcePool.cc:110\n    #2 0x55ca4bbd8bf8 in WFResolverTask::dns_partial_callback(void*) /sourcecode/src/nameservice/WFDnsResolver.cc:659\n    #3 0x55ca4bbd0a34 in fuzzloop /dockerin/fuzz_drivers/tf1729593105429ksgs.cpp:40\n    #4 0x55ca4bd4bee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55ca4bbd07f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f8766af4d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f8766af4e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55ca4bbd0944 in _start (/dockerin/fuzz_drivers/tf1729593105429ksgs.out+0x2c2944)\n\n0x61b000000078 is located 8 bytes to the left of 1600-byte region [0x61b000000080,0x61b0000006c0)\nallocated by thread T0 here:\n    #0 0x7f876771d357 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:102\n    #1 0x55ca4bce06ef in WFResourcePool::create(unsigned long) /sourcecode/src/factory/WFResourcePool.cc:77\n    #2 0x55ca4bce1226 in WFResourcePool::WFResourcePool(unsigned long) /sourcecode/src/factory/WFResourcePool.cc:92\n    #3 0x55ca4bc65d4c in __DnsClientManager::__DnsClientManager() /sourcecode/src/manager/WFGlobal.cc:636\n    #4 0x55ca4bc6599b in __DnsClientManager::get_instance() /sourcecode/src/manager/WFGlobal.cc:627\n    #5 0x55ca4bc5a78c in WFGlobal::get_dns_respool() /sourcecode/src/manager/WFGlobal.cc:734\n    #6 0x55ca4bbd8afc in WFResolverTask::dns_partial_callback(void*) /sourcecode/src/nameservice/WFDnsResolver.cc:659\n    #7 0x55ca4bbd0a34 in fuzzloop /dockerin/fuzz_drivers/tf1729593105429ksgs.cpp:40\n    #8 0x55ca4bd4bee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/factory/WFResourcePool.h:56 in WFResourcePool::push(void*)\nShadow bytes around the buggy address:\n  0x0c367fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c367fff8000: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fa]\n  0x0c367fff8010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff8020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff8030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff8040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c367fff8050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: WFResolverTask::dns_partial_callback(void *net_dns_task)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14WFResolverTask20dns_partial_callbackEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/un.h> //extract\n#include <arpa/inet.h> //extract\n#include <errno.h> //extract\n#include <netdb.h> //extract\n#include <stdlib.h> //extract\n#include <stdio.h> //extract\n#include <stdint.h> //extract\n#include <ctype.h> //extract\n#include <utility> //extract\n#include <string> //extract\n#include \"EndpointParams.h\" //extract\n#include \"RouteManager.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFTaskFactory.h\" //extract\n#include \"WFResourcePool.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"DnsCache.h\" //extract\n#include \"DnsUtil.h\" //extract\n#include \"WFDnsClient.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * net_dns_task = (void *)fuzzData(0);\n    WFResolverTask::dns_partial_callback(net_dns_task);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/factory/WFResourcePool.h\n  46: \t};\n  47: \n  48: protected:\n  49: \tvirtual void *pop()\n  50: \t{\n  51: \t\treturn this->data.res[this->data.index++];\n  52: \t}\n  53: \n  54: \tvirtual void push(void *res)\n  55: \t{\n  56: \t\tthis->data.res[--this->data.index] = res;\n  57: \t}\n  58: \n  59: protected:\n  60: \tstruct Data data;\n  61: \n  62: private:\n  63: \tvoid create(size_t n);\n  64: \n  65: public:\n  66: \tWFResourcePool(void *const *res, size_t n);\n  67: \nStacktrace #1:\nFile: /sourcecode/src/factory/WFResourcePool.cc\n  96: void WFResourcePool::post(void *res)\n  97: {\n  98: \tstruct WFResourcePool::Data *data = &this->data;\n  99: \tWFConditional *cond;\n 100: \n 101: \tdata->mutex.lock();\n 102: \tif (++data->value <= 0)\n 103: \t{\n 104: \t\tcond = list_entry(data->wait_list.next, __RPConditional, list);\n 105: \t\tlist_del(data->wait_list.next);\n 106: \t}\n 107: \telse\n 108: \t{\n 109: \t\tcond = NULL;\n 110: \t\tthis->push(res);\n 111: \t}\n 112: \n 113: \tdata->mutex.unlock();\n 114: \tif (cond)\n 115: \t\tcond->WFConditional::signal(res);\n 116: }\n 117: \nStacktrace #2:\nFile: /sourcecode/src/nameservice/WFDnsResolver.cc\n 656: void WFResolverTask::dns_partial_callback(void *net_dns_task)\n 657: {\n 658: \tWFDnsTask *dns_task = (WFDnsTask *)net_dns_task;\n 659: \tWFGlobal::get_dns_respool()->post(NULL);\n 660: \n 661: \tstruct DnsContext *ctx = (struct DnsContext *)dns_task->user_data;\n 662: \tctx->ai = NULL;\n 663: \tctx->state = dns_task->get_state();\n 664: \tctx->error = dns_task->get_error();\n 665: \tif (ctx->state == WFT_STATE_SUCCESS)\n 666: \t{\n 667: \t\tprotocol::DnsResponse *resp = dns_task->get_resp();\n 668: \t\tctx->eai_error = protocol::DnsUtil::getaddrinfo(resp, ctx->port,\n 669: \t\t\t\t\t\t\t\t\t\t\t\t\t\t&ctx->ai);\n 670: \t}\n 671: \telse\n 672: \t\tctx->eai_error = EAI_NONAME;\n 673: }\n 674:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==6217==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55866a7d7c75 bp 0x7ffee431d740 sp 0x7ffee431d730\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x55866a7d7c74 in fio_siphash_xy /sourcecode/lib/facil/fio.c:8339\n    #1 0x55866a7d91ce in fio_siphash13 /sourcecode/lib/facil/fio.c:8403\n    #2 0x55866a85d023 in http_mimetype_find /sourcecode/lib/facil/http/http.c:2520\n    #3 0x55866a74580a in fuzzloop /dockerin/fuzz_drivers/tf1729822403178sxmq.c:29\n    #4 0x55866a8c4249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55866a744ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7feda2321d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7feda2321e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55866a744c04 in _start (/dockerin/fuzz_drivers/tf1729822403178sxmq.out+0x1dbc04)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7feda2cfa887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55866a8c445c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:8339 in fio_siphash_xy\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: http_mimetype_find(char *file_ext, size_t file_ext_len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_mimetype_find\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * file_ext = fuzzString(0);\n    size_t file_ext_len = (size_t)fuzzUint64(1);\n    FIOBJ ret = http_mimetype_find(file_ext, file_ext_len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n8329:     v1 = fio_lrot64(v1, 13) ^ v0;                                              \\\n8330:     v0 = fio_lrot64(v0, 32);                                                   \\\n8331:     v2 += v1;                                                                  \\\n8332:     v0 += v3;                                                                  \\\n8333:     v1 = fio_lrot64(v1, 17) ^ v2;                                              \\\n8334:     v3 = fio_lrot64(v3, 21) ^ v0;                                              \\\n8335:     v2 = fio_lrot64(v2, 32);                                                   \\\n8336:   } while (0);\n8337: \n8338:   while (len >= 8) {\n8339:     word.i = sip_local64(fio_str2u64(w8));\n8340:     v3 ^= word.i;\n8341:     /* Sip Rounds */\n8342:     for (size_t i = 0; i < x; ++i) {\n8343:       hash_map_SipRound;\n8344:     }\n8345:     v0 ^= word.i;\n8346:     w8 += 8;\n8347:     len -= 8;\n8348:   }\n8349:   word.i = 0;\n8350: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n8393:   return v0;\n8394: }\n8395: \n8396: uint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n8397:                        uint64_t key2) {\n8398:   return fio_siphash_xy(data, len, 2, 4, key1, key2);\n8399: }\n8400: \n8401: uint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n8402:                        uint64_t key2) {\n8403:   return fio_siphash_xy(data, len, 1, 3, key1, key2);\n8404: }\n8405: \n8406: /* *****************************************************************************\n8407: SHA-1\n8408: ***************************************************************************** */\n8409: \n8410: static const uint8_t sha1_padding[64] = {0x80, 0};\n8411: \n8412: /**\n8413: Process the buffer once full.\n8414: \nStacktrace #2:\nFile: /sourcecode/lib/facil/http/http.c\n2519: FIOBJ http_mimetype_find(char *file_ext, size_t file_ext_len) {\n2520:   uintptr_t hash = FIO_HASH_FN(file_ext, file_ext_len, 0, 0);\n2521:   return fiobj_dup(\n2522:       fio_mime_set_find(&fio_http_mime_types, hash, FIOBJ_INVALID));\n2523: }\n2524:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==32041==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000160 at pc 0x55e1101f7b79 bp 0x7ffc6081ec90 sp 0x7ffc6081ec80\nREAD of size 8 at 0x602000000160 thread T0\n    #0 0x55e1101f7b78 in Communicator::create_request(void*) /sourcecode/src/kernel/Communicator.cc:1264\n    #1 0x55e1101ded74 in fuzzloop /dockerin/fuzz_drivers/tf1729593105309npcb.cpp:39\n    #2 0x55e110238229 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e1101deb38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f221dbcad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f221dbcae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e1101dec84 in _start (/dockerin/fuzz_drivers/tf1729593105309npcb.out+0x83c84)\n\n0x602000000160 is located 68 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f221e7f1887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e11023843c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Communicator.cc:1264 in Communicator::create_request(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa fa fa fa fa fa fa[fa]fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Communicator::create_request(void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator14create_requestEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(0);\n    poller_message_t * ret = Communicator::create_request(context);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1261: poller_message_t *Communicator::create_request(void *context)\n1262: {\n1263: \tstruct CommConnEntry *entry = (struct CommConnEntry *)context;\n1264: \tCommService *service = entry->service;\n1265: \tCommTarget *target = entry->target;\n1266: \tCommSession *session;\n1267: \tint timeout;\n1268: \n1269: \tif (entry->state == CONN_STATE_IDLE)\n1270: \t{\n1271: \t\tpthread_mutex_lock(&target->mutex);\n1272: \t\t/* do nothing */\n1273: \t\tpthread_mutex_unlock(&target->mutex);\n1274: \t}\n1275: \n1276: \tpthread_mutex_lock(&service->mutex);\n1277: \tif (entry->state == CONN_STATE_KEEPALIVE)\n1278: \t\tlist_del(&entry->list);\n1279: \telse if (entry->state != CONN_STATE_CONNECTED)\n1280: \t\tentry = NULL;\n1281: \n1282: \tpthread_mutex_unlock(&service->mutex);\n1283: \tif (!entry)\n1284: \t{\n1285: \t\terrno = EBADMSG;\n1286: \t\treturn NULL;\n1287: \t}\n1288: \n1289: \tsession = service->new_session(entry->seq, entry->conn);\n1290: \tif (!session)\n1291: \t\treturn NULL;\n1292: \n1293: \tsession->passive = 1;\n1294: \tentry->session = session;\n1295: \tsession->target = target;\n1296: \tsession->conn = entry->conn;\n1297: \tsession->seq = entry->seq++;\n1298: \tsession->out = NULL;\n1299: \tsession->in = NULL;\n1300: \n1301: \ttimeout = Communicator::first_timeout_recv(session);\n1302: \tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n1303: \tentry->state = CONN_STATE_RECEIVING;\n1304: \n1305: \t((CommServiceTarget *)target)->incref();\n1306: \n1307: \tsession->in = session->message_in();\n1308: \tif (session->in)\n1309: \t{\n1310: \t\tsession->in->poller_message_t::append = Communicator::append_request;\n1311: \t\tsession->in->entry = entry;\n1312: \t}\n1313: \n1314: \treturn session->in;\n1315: }\n1316:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==971==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55e92dbfd9a9 bp 0x7ffd280b4960 sp 0x7ffd280b4950\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x55e92dbfd9a8 in fio_ltoa /sourcecode/lib/facil/fio.c:4949\n    #1 0x55e92dcbd1b8 in http_date2rfc2109 /sourcecode/lib/facil/http/http.c:2313\n    #2 0x55e92dbac9a8 in fuzzloop /dockerin/fuzz_drivers/tf1729828200420qcna.c:55\n    #3 0x55e92dd2b3e9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55e92dbabab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f765895ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f765895ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55e92dbabc04 in _start (/dockerin/fuzz_drivers/tf1729828200420qcna.out+0x1dbc04)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f7659337887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55e92dd2b5fc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:4949 in fio_ltoa\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 04 fa fa fa 04 fa fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa 00 04 fa fa 00 04 fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 03:49:50\n// Signature: http_date2rfc2109(char *target, struct tm *tmbuf)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_date2rfc2109\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h\" //autogen\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * target = fuzzString(0);\n    //file: /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h:7\n    //struct tm\n    //{\n    //  int tm_sec;\t\t\t/* Seconds.\t[0-60] (1 leap second) */\n    //  int tm_min;\t\t\t/* Minutes.\t[0-59] */\n    //  int tm_hour;\t\t\t/* Hours.\t[0-23] */\n    //  int tm_mday;\t\t\t/* Day.\t\t[1-31] */\n    //  int tm_mon;\t\t\t/* Month.\t[0-11] */\n    //  int tm_year;\t\t\t/* Year\t- 1900.  */\n    //  int tm_wday;\t\t\t/* Day of week.\t[0-6] */\n    //  int tm_yday;\t\t\t/* Days in year.[0-365]\t*/\n    //  int tm_isdst;\t\t\t/* DST.\t\t[-1/0/1]*/\n    //\n    //# ifdef\t__USE_MISC\n    //  long int tm_gmtoff;\t\t/* Seconds east of UTC.  */\n    //  const char *tm_zone;\t\t/* Timezone abbreviation.  */\n    //# else\n    //  long int __tm_gmtoff;\t\t/* Seconds east of UTC.  */\n    //  const char *__tm_zone;\t/* Timezone abbreviation.  */\n    //# endif\n    //};\n    struct tm *tmbuf = (struct tm *)driverAllocMem(sizeof(struct tm));\n    tmbuf->tm_isdst = fuzzInt32(1);\n    tmbuf->tm_gmtoff = (long)fuzzInt64(2);\n    tmbuf->tm_zone = fuzzString(3);\n    \n    size_t ret = http_date2rfc2109(target, tmbuf);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4821: size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n4822:   const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n4823:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n4824: \n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n...skip...\n4865:       }\n4866:       dest[len++] = '0';\n4867: \n4868:       while (num) {\n4869:         buf[l++] = '0' + (num & 7);\n4870:         num = num >> 3;\n4871:       }\n4872:       while (l) {\n4873:         --l;\n4874:         dest[len++] = buf[l];\n4875:       }\n4876:       dest[len] = 0;\n4877:       return len;\n4878:     }\n4879: \n4880:   case 16:\n4881:     /* Base 16 */\n4882:     {\n4883:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4884:       uint8_t i = 0;    /* counting bits */\n4885:       dest[len++] = '0';\n4886:       dest[len++] = 'x';\n4887:       while (i < 8 && (n & 0xFF00000000000000) == 0) {\n4888:         n = n << 8;\n4889:         i++;\n4890:       }\n4891:       /* make sure the Hex representation doesn't appear misleadingly signed. */\n4892:       if (i && (n & 0x8000000000000000)) {\n4893:         dest[len++] = '0';\n4894:         dest[len++] = '0';\n4895:       }\n4896:       /* write the damn thing, high to low */\n4897:       while (i < 8) {\n4898:         uint8_t tmp = (n & 0xF000000000000000) >> 60;\n4899:         dest[len++] = notation[tmp];\n4900:         tmp = (n & 0x0F00000000000000) >> 56;\n4901:         dest[len++] = notation[tmp];\n4902:         i++;\n4903:         n = n << 8;\n4904:       }\n4905:       dest[len] = 0;\n4906:       return len;\n4907:     }\n4908:   case 3: /* fallthrough */\n4909:   case 4: /* fallthrough */\n4910:   case 5: /* fallthrough */\n4911:   case 6: /* fallthrough */\n4912:   case 7: /* fallthrough */\n4913:   case 9: /* fallthrough */\n4914:     /* rare bases */\n4915:     if (num < 0) {\n4916:       dest[len++] = '-';\n4917:       num = 0 - num;\n4918:     }\n4919:     uint64_t l = 0;\n4920:     while (num) {\n4921:       uint64_t t = num / base;\n4922:       buf[l++] = '0' + (num - (t * base));\n4923:       num = t;\n4924:     }\n4925:     while (l) {\n4926:       --l;\n4927:       dest[len++] = buf[l];\n4928:     }\n4929:     dest[len] = 0;\n4930:     return len;\n4931: \n4932:   default:\n4933:     break;\n4934:   }\n4935:   /* Base 10, the default base */\n4936: \n4937:   if (num < 0) {\n4938:     dest[len++] = '-';\n4939:     num = 0 - num;\n4940:   }\n4941:   uint64_t l = 0;\n4942:   while (num) {\n4943:     uint64_t t = num / 10;\n4944:     buf[l++] = '0' + (num - (t * 10));\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960:     break;\n4961:   case 8:\n4962:     dest[len++] = '0';\n4963:     break;\n4964:   case 16:\n4965:     dest[len++] = '0';\n4966:     dest[len++] = 'x';\n4967:     dest[len++] = '0';\n4968:     break;\n4969:   }\n4970:   dest[len++] = '0';\n4971:   dest[len] = 0;\n4972:   return len;\n4973: }\n4974: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2292: size_t http_date2rfc2109(char *target, struct tm *tmbuf) {\n2293:   /* note: day of month is always 2 digits */\n2294:   char *pos = target;\n2295:   uint16_t tmp;\n2296:   pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n2297:   pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n2298:   pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n2299:   pos[3] = ',';\n2300:   pos[4] = ' ';\n2301:   pos += 5;\n2302:   tmp = tmbuf->tm_mday / 10;\n2303:   pos[0] = '0' + tmp;\n2304:   pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n2305:   pos += 2;\n2306:   *(pos++) = ' ';\n2307:   pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n2308:   pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n2309:   pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n2310:   pos[3] = ' ';\n2311:   pos += 4;\n2312:   // write year.\n2313:   pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n2314:   *(pos++) = ' ';\n2315:   tmp = tmbuf->tm_hour / 10;\n2316:   pos[0] = '0' + tmp;\n2317:   pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n2318:   pos[2] = ':';\n2319:   tmp = tmbuf->tm_min / 10;\n2320:   pos[3] = '0' + tmp;\n2321:   pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n2322:   pos[5] = ':';\n2323:   tmp = tmbuf->tm_sec / 10;\n2324:   pos[6] = '0' + tmp;\n2325:   pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n2326:   pos += 8;\n2327:   *pos++ = ' ';\n2328:   *pos++ = '-';\n2329:   *pos++ = '0';\n2330:   *pos++ = '0';\n2331:   *pos++ = '0';\n2332:   *pos++ = '0';\n2333:   *pos = 0;\n2334:   return pos - target;\n2335: }\n2336:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==5640==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000015c at pc 0x555f980671ff bp 0x7fff637cbbe0 sp 0x7fff637cbbd0\nREAD of size 1 at 0x60200000015c thread T0\n    #0 0x555f980671fe in http_decode_path /sourcecode/lib/facil/http/http.c:2441\n    #1 0x555f97f5481c in fuzzloop /dockerin/fuzz_drivers/tf1729822403173atwz.c:30\n    #2 0x555f980d3259 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x555f97f53ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f4ffa51fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f4ffa51fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x555f97f53c04 in _start (/dockerin/fuzz_drivers/tf1729822403173atwz.out+0x1dbc04)\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f4ffaef8887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x555f980d346c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:2441 in http_decode_path\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00[04]fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: http_decode_path(char *dest, char *url_data, size_t length)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_path\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    size_t length = (size_t)fuzzUint64(2);\n    ssize_t ret = http_decode_path(dest, url_data, length);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2437: ssize_t http_decode_path(char *dest, const char *url_data, size_t length) {\n2438:   char *pos = dest;\n2439:   const char *end = url_data + length;\n2440:   while (url_data < end) {\n2441:     if (*url_data == '%') {\n2442:       // decode hex value\n2443:       // this is a percent encoded value.\n2444:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2445:         return -1;\n2446:       pos++;\n2447:       url_data += 3;\n2448:     } else\n2449:       *(pos++) = *(url_data++);\n2450:   }\n2451:   *pos = 0;\n2452:   return pos - dest;\n2453: }\n2454:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2066==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000210 at pc 0x56129dd02f4f bp 0x7fff95f7ece0 sp 0x7fff95f7ecd0\nWRITE of size 4 at 0x602000000210 thread T0\n    #0 0x56129dd02f4e in flatcc_parse_buffer /sourcecode/src/compiler/flatcc.c:106\n    #1 0x56129dce79a3 in fuzzloop /dockerin/fuzz_drivers/tf1727601035344xrts.c:27\n    #2 0x56129de5c5f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56129dce76f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fceeebd5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fceeebd5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56129dce7844 in _start (/dockerin/fuzz_drivers/tf1727601035344xrts.out+0x1e3844)\n\n0x602000000210 is located 120 bytes to the right of 8-byte region [0x602000000190,0x602000000198)\nallocated by thread T0 here:\n    #0 0x7fceef5ae887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56129de5c80c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/compiler/flatcc.c:106 in flatcc_parse_buffer\nShadow bytes around the buggy address:\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff8040: fa fa[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iexternal -Iinclude -Iconfig -Isrc/compiler -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_parse_buffer\n// Sign: flatcc_parse_buffer(flatcc_context_t ctx, char *buf, size_t buflen)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <assert.h> //extract\n#include \"config.h\" //extract\n#include \"parser.h\" //extract\n#include \"semantics.h\" //extract\n#include \"fileio.h\" //extract\n#include \"codegen.h\" //extract\n#include \"flatcc/flatcc.h\" //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ctx = (void *)fuzzData(0);\n    char * buf = fuzzString(1);\n    size_t buflen = (size_t)fuzzUint64(2);\n    int ret = flatcc_parse_buffer(ctx, buf, buflen);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/compiler/flatcc.c\n 101: int flatcc_parse_buffer(flatcc_context_t ctx, const char *buf, size_t buflen)\n 102: {\n 103:     fb_parser_t *P = ctx;\n 104: \n 105:     /* Currently includes cannot be handled by buffers, so they should done. */\n 106:     P->opts.disable_includes = 1;\n 107:     if ((size_t)buflen > P->opts.max_schema_size && P->opts.max_schema_size > 0) {\n 108:         fb_print_error(P, \"input exceeds maximum allowed size\\n\");\n 109:         return -1;\n 110:     }\n 111:     /* Add self to set of visible schema. */\n 112:     ptr_set_insert_item(&P->schema.visible_schema, &P->schema, ht_keep);\n 113:     return fb_parse(P, buf, buflen, 0) || fb_build_schema(P) ? -1 : 0;\n 114: }\n 115:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1409==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000fdd6 at pc 0x56160410bb0e bp 0x7ffd1c0580a0 sp 0x7ffd1c058090\nREAD of size 2 at 0x60200000fdd6 thread T0\n    #0 0x56160410bb0d in __flatbuffers_voffset_read /sourcecode/include/flatcc/flatcc_endian.h:91\n    #1 0x56160410bb64 in __flatbuffers_voffset_read_from_pe /sourcecode/include/flatcc/flatcc_endian.h:91\n    #2 0x56160410c3f7 in read_voffset /sourcecode/src/runtime/verifier.c:123\n    #3 0x56160410c6bd in read_vt_entry /sourcecode/src/runtime/verifier.c:159\n    #4 0x56160410cb09 in get_offset_field /sourcecode/src/runtime/verifier.c:219\n    #5 0x56160410e547 in flatcc_verify_vector_field /sourcecode/src/runtime/verifier.c:397\n    #6 0x56160410b95e in fuzzloop /dockerin/fuzz_drivers/tf1727601035431mnsf.c:50\n    #7 0x56160411a5a9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #8 0x56160410b388 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #9 0x7f72ee081d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #10 0x7f72ee081e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #11 0x56160410b4d4 in _start (/dockerin/fuzz_drivers/tf1727601035431mnsf.out+0x134d4)\n\nAddress 0x60200000fdd6 is a wild pointer.\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/include/flatcc/flatcc_endian.h:91 in __flatbuffers_voffset_read\nShadow bytes around the buggy address:\n  0x0c047fff9f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9f80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9f90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9fa0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x0c047fff9fb0: fa fa fa fa fa fa fa fa fa fa[fa]fa fa fa fa fa\n  0x0c047fff9fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9fe0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9ff0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffa000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/test/json_test/generated -Iinclude -Isrc/runtime -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1 -DFLATCC_JSON_PARSE_WIDE_SPACE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_verify_vector_field\n// Sign: flatcc_verify_vector_field(flatcc_table_verifier_descriptor_t *td, flatbuffers_voffset_t id, int required, size_t elem_size, uint16_t align, size_t max_count)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <string.h> //extract\n#include \"flatcc/flatcc_rtconfig.h\" //extract\n#include \"flatcc/flatcc_flatbuffers.h\" //extract\n#include \"flatcc/flatcc_verifier.h\" //extract\n#include \"flatcc/flatcc_identifier.h\" //extract\n\nint fuzzloop() {\n    //file: include/flatcc/flatcc_verifier.h:121\n    //struct flatcc_table_verifier_descriptor {\n    //    /* Pointer to buffer. Not assumed to be aligned beyond uoffset_t. */\n    //    const void *buf;\n    //    /* Buffer size. */\n    //    flatbuffers_uoffset_t end;\n    //    /* Time to live: number nesting levels left before failure. */\n    //    int ttl;\n    //    /* Vtable of current table. */\n    //    const void *vtable;\n    //    /* Table offset relative to buffer start */\n    //    flatbuffers_uoffset_t table;\n    //    /* Table end relative to buffer start as per vtable[1] field. */\n    //    flatbuffers_voffset_t tsize;\n    //    /* Size of vtable in bytes. */\n    //    flatbuffers_voffset_t vsize;\n    //};\n    struct flatcc_table_verifier_descriptor *td = (struct flatcc_table_verifier_descriptor *)driverAllocMem(sizeof(struct flatcc_table_verifier_descriptor));\n    td->buf = (void *)fuzzData(0);\n    td->end = fuzzUint32(1);\n    td->ttl = fuzzInt32(2);\n    td->vtable = (void *)fuzzData(3);\n    td->table = fuzzUint32(4);\n    td->vsize = fuzzUint16(5);\n    \n    unsigned short id = fuzzUint16(6);\n    int required = fuzzInt32(7);\n    size_t elem_size = (size_t)fuzzUint64(8);\n    uint16_t align = fuzzUint16(9);\n    size_t max_count = (size_t)fuzzUint64(10);\n    int ret = flatcc_verify_vector_field(td, id, required, elem_size, align, max_count);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/flatcc/flatcc_endian.h\n  91:  __flatcc_define_integer_accessors(__flatbuffers_voffset, flatbuffers_voffset_t,\n  92:          FLATBUFFERS_VOFFSET_WIDTH, flatbuffers_endian)\n  93: \nStacktrace #1:\nFile: /sourcecode/include/flatcc/flatcc_endian.h\n  91:  __flatcc_define_integer_accessors(__flatbuffers_voffset, flatbuffers_voffset_t,\n  92:          FLATBUFFERS_VOFFSET_WIDTH, flatbuffers_endian)\n  93: \nStacktrace #2:\nFile: /sourcecode/src/runtime/verifier.c\n 121: static inline voffset_t read_voffset(const void *p, uoffset_t base)\n 122: {\n 123:     return __flatbuffers_voffset_read_from_pe((uint8_t *)p + base);\n 124: }\n 125: \nStacktrace #3:\nFile: /sourcecode/src/runtime/verifier.c\n 151: static inline voffset_t read_vt_entry(flatcc_table_verifier_descriptor_t *td, voffset_t id)\n 152: {\n 153:     voffset_t vo = (id + 2u) * sizeof(voffset_t);\n 154: \n 155:     /* Assumes tsize has been verified for alignment. */\n 156:     if (vo >= td->vsize) {\n 157:         return 0;\n 158:     }\n 159:     return read_voffset(td->vtable, vo);\n 160: }\n 161: \nStacktrace #4:\nFile: /sourcecode/src/runtime/verifier.c\n 214: static int get_offset_field(flatcc_table_verifier_descriptor_t *td, voffset_t id, int required, uoffset_t *out)\n 215: {\n 216:     uoffset_t k, k2;\n 217:     voffset_t vte;\n 218: \n 219:     vte = read_vt_entry(td, id);\n 220:     if (!vte) {\n 221:         *out = 0;\n 222:         if (required) {\n 223:             return flatcc_verify_error_required_field_missing;\n 224:         }\n 225:         /* Missing, but not invalid. */\n 226:         return flatcc_verify_ok;\n 227:     }\n 228:     /*\n 229:      * Note that we don't add td.table to k and we test against table\n 230:      * size not table end or buffer end. Otherwise it would not be safe\n 231:      * to optimized out the k <= k2 check for normal uoffset and voffset\n 232:      * configurations.\n 233:      */\n 234:     k = vte;\n 235:     k2 = k + offset_size;\n 236:     verify(k2 <= td->tsize, flatcc_verify_error_table_field_out_of_range);\n 237:     /* This normally optimizes to nop. */\n 238:     verify(uoffset_size > voffset_size || k <= k2, flatcc_verify_error_table_field_size_overflow);\n 239:     k += td->table;\n 240:     verify(!(k & (offset_size - 1u)), flatcc_verify_error_table_field_not_aligned);\n 241:     /* We assume the table size has already been verified. */\n 242:     *out = k;\n 243:     return flatcc_verify_ok;\n 244: }\n 245: \nStacktrace #5:\nFile: /sourcecode/src/runtime/verifier.c\n 392: int flatcc_verify_vector_field(flatcc_table_verifier_descriptor_t *td,\n 393:         voffset_t id, int required, size_t elem_size, uint16_t align, size_t max_count)\n 394: {\n 395:     uoffset_t base;\n 396: \n 397:     check_field(td, id, required, base);\n 398:     return verify_vector(td->buf, td->end, base, read_uoffset(td->buf, base),\n 399:         (uoffset_t)elem_size, align, (uoffset_t)max_count);\n 400: }\n 401:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==344477==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000c0 at pc 0x5648749f58cc bp 0x7ffe8a58a630 sp 0x7ffe8a58a620\nREAD of size 8 at 0x6020000000c0 thread T0\n    #0 0x5648749f58cb in json_object_prev_name /sourcecode/src/util/json_parser.c:1044\n    #1 0x5648749eb6ce in fuzzloop /dockerin/fuzz_drivers/tf1729594312558nkns.cpp:20\n    #2 0x564874a07049 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x5648749eb468 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fc3cd0f3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fc3cd0f3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x5648749eb5b4 in _start (/dockerin/fuzz_drivers/tf1729594312558nkns.out+0x285b4)\n\n0x6020000000c0 is located 10 bytes to the right of 6-byte region [0x6020000000b0,0x6020000000b6)\nallocated by thread T0 here:\n    #0 0x7fc3cdd1a887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x564874a6238b in BetaString2Dict /home/clouditera/workdir-engine_c/betafuzz/structure/addDict.c:21\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/util/json_parser.c:1044 in json_object_prev_name\nShadow bytes around the buggy address:\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n=>0x0c047fff8010: fa fa 06 fa fa fa 06 fa[fa]fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:49:54\n// Signature: json_object_prev_name(char *name, json_object_t *obj)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: json_object_prev_name\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/json_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    const char *name = fuzzString(0);\n    json_value_t *val = json_value_create(JSON_VALUE_OBJECT);\n    json_object_t *obj = json_value_object(val);\n\n    const char *prev_name = json_object_prev_name(name, obj);\n\n    json_value_destroy(val);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/util/json_parser.c\n1034: const char *json_object_prev_name(const char *name,\n1035: \t\t\t\t\t\t\t\t  const json_object_t *obj)\n1036: {\n1037: \tconst struct list_head *pos;\n1038: \n1039: \tif (name)\n1040: \t\tpos = &list_entry(name, json_member_t, name)->list;\n1041: \telse\n1042: \t\tpos = &obj->head;\n1043: \n1044: \tif (pos->prev == &obj->head)\n1045: \t\treturn NULL;\n1046: \n1047: \treturn list_entry(pos->prev, json_member_t, list)->name;\n1048: }\n1049:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3221==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55799d571da2 bp 0x7ffe045eaf90 sp 0x7ffe045eaf80\nWRITE of size 1 at 0x60200000011c thread T0\n    #0 0x55799d571da1 in fio_ltoa /sourcecode/lib/facil/fio.c:4949\n    #1 0x55799d622f48 in http_date2rfc7231 /sourcecode/lib/facil/http/http.c:2217\n    #2 0x55799d5169a8 in fuzzloop /dockerin/fuzz_drivers/tf1729822403171ckoy.c:55\n    #3 0x55799d6953e9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55799d515ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f64ad9c7d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f64ad9c7e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55799d515c04 in _start (/dockerin/fuzz_drivers/tf1729822403171ckoy.out+0x1dbc04)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f64ae3a0887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55799d6955fc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:4949 in fio_ltoa\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 04 fa fa fa 04 fa fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa 00 04 fa fa 00 04 fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: http_date2rfc7231(char *target, struct tm *tmbuf)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_date2rfc7231\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h\" //autogen\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * target = fuzzString(0);\n    //file: /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h:7\n    //struct tm\n    //{\n    //  int tm_sec;\t\t\t/* Seconds.\t[0-60] (1 leap second) */\n    //  int tm_min;\t\t\t/* Minutes.\t[0-59] */\n    //  int tm_hour;\t\t\t/* Hours.\t[0-23] */\n    //  int tm_mday;\t\t\t/* Day.\t\t[1-31] */\n    //  int tm_mon;\t\t\t/* Month.\t[0-11] */\n    //  int tm_year;\t\t\t/* Year\t- 1900.  */\n    //  int tm_wday;\t\t\t/* Day of week.\t[0-6] */\n    //  int tm_yday;\t\t\t/* Days in year.[0-365]\t*/\n    //  int tm_isdst;\t\t\t/* DST.\t\t[-1/0/1]*/\n    //\n    //# ifdef\t__USE_MISC\n    //  long int tm_gmtoff;\t\t/* Seconds east of UTC.  */\n    //  const char *tm_zone;\t\t/* Timezone abbreviation.  */\n    //# else\n    //  long int __tm_gmtoff;\t\t/* Seconds east of UTC.  */\n    //  const char *__tm_zone;\t/* Timezone abbreviation.  */\n    //# endif\n    //};\n    struct tm *tmbuf = (struct tm *)driverAllocMem(sizeof(struct tm));\n    tmbuf->tm_isdst = fuzzInt32(1);\n    tmbuf->tm_gmtoff = (long)fuzzInt64(2);\n    tmbuf->tm_zone = fuzzString(3);\n    \n    size_t ret = http_date2rfc7231(target, tmbuf);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4939:     num = 0 - num;\n4940:   }\n4941:   uint64_t l = 0;\n4942:   while (num) {\n4943:     uint64_t t = num / 10;\n4944:     buf[l++] = '0' + (num - (t * 10));\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2196: size_t http_date2rfc7231(char *target, struct tm *tmbuf) {\n2197:   /* note: day of month is always 2 digits */\n2198:   char *pos = target;\n2199:   uint16_t tmp;\n2200:   pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n2201:   pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n2202:   pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n2203:   pos[3] = ',';\n2204:   pos[4] = ' ';\n2205:   pos += 5;\n2206:   tmp = tmbuf->tm_mday / 10;\n2207:   pos[0] = '0' + tmp;\n2208:   pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n2209:   pos += 2;\n2210:   *(pos++) = ' ';\n2211:   pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n2212:   pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n2213:   pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n2214:   pos[3] = ' ';\n2215:   pos += 4;\n2216:   // write year.\n2217:   pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n2218:   *(pos++) = ' ';\n2219:   tmp = tmbuf->tm_hour / 10;\n2220:   pos[0] = '0' + tmp;\n2221:   pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n2222:   pos[2] = ':';\n2223:   tmp = tmbuf->tm_min / 10;\n2224:   pos[3] = '0' + tmp;\n2225:   pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n2226:   pos[5] = ':';\n2227:   tmp = tmbuf->tm_sec / 10;\n2228:   pos[6] = '0' + tmp;\n2229:   pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n2230:   pos += 8;\n2231:   pos[0] = ' ';\n2232:   pos[1] = GMT_STR[0];\n2233:   pos[2] = GMT_STR[1];\n2234:   pos[3] = GMT_STR[2];\n2235:   pos[4] = 0;\n2236:   pos += 4;\n2237:   return pos - target;\n2238: }\n2239:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4087==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000008 at pc 0x562cc2498a3c bp 0x7ffe650589b0 sp 0x7ffe650589a0\nWRITE of size 2 at 0x602000000008 thread T0\n    #0 0x562cc2498a3b in block_free /sourcecode/lib/facil/fio.c:7837\n    #1 0x562cc249950a in block_slice_free /sourcecode/lib/facil/fio.c:7935\n    #2 0x562cc2499de0 in fio_free /sourcecode/lib/facil/fio.c:8097\n    #3 0x562cc2422259 in fuzzloop /dockerin/fuzz_drivers/tf1729828200233yvld.c:38\n    #4 0x562cc24d1e39 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x562cc24219d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7efd82ef5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7efd82ef5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x562cc2421b24 in _start (/dockerin/fuzz_drivers/tf1729828200233yvld.out+0xc5b24)\n\n0x602000000008 is located 8 bytes to the left of 15-byte region [0x602000000010,0x60200000001f)\nallocated by thread T0 here:\n    #0 0x7efd838ce887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7efd82f7458e in strdup (/lib/x86_64-linux-gnu/libc.so.6+0xa858e)\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:7837 in block_free\nShadow bytes around the buggy address:\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c047fff8000: fa[fa]00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 03:49:50\n// Signature: fio_free(void *ptr)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_free\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ptr = (void *)fuzzData(0);\n    fio_free(ptr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7836: static inline void block_free(block_s *blk) {\n7837:   if (fio_atomic_sub(&blk->ref, 1))\n7838:     return;\n7839: \n7840:   memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n7841:   fio_lock(&memory.lock);\n7842:   fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n7843: \n7844:   blk = blk->parent;\n7845: \n7846:   if (fio_atomic_sub(&blk->root_ref, 1)) {\n7847:     fio_unlock(&memory.lock);\n7848:     return;\n7849:   }\n7850:   // fio_unlock(&memory.lock);\n7851:   // return;\n7852: \n7853:   /* remove all of the root block's children (slices) from the memory pool */\n7854:   for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n7855:     block_node_s *pos =\n7856:         (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));\n7857:     fio_ls_embd_remove(&pos->node);\n7858:   }\n7859: \n7860:   fio_unlock(&memory.lock);\n7861:   sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n7862:   FIO_LOG_DEBUG(\"memory allocator returned %p to the system\", (void *)blk);\n7863:   FIO_MEMORY_ON_BLOCK_FREE();\n7864: }\n7865: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n7932: static inline void block_slice_free(void *mem) {\n7933:   /* locate block boundary */\n7934:   block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n7935:   block_free(blk);\n7936: }\n7937: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8088: void fio_free(void *ptr) {\n8089:   if (!ptr || ptr == (void *)&on_malloc_zero)\n8090:     return;\n8091:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8092:     /* big allocation - direct from the system */\n8093:     big_free(ptr);\n8094:     return;\n8095:   }\n8096:   /* allocated within block */\n8097:   block_slice_free(ptr);\n8098: }\n8099:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==196==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000e996 at pc 0x55fe3dab8077 bp 0x7fff5ba2d7a0 sp 0x7fff5ba2d790\nWRITE of size 1 at 0x60200000e996 thread T0\n    #0 0x55fe3dab8076 in hex2byte /sourcecode/lib/facil/http/http.c:2377\n    #1 0x55fe3dab9504 in http_decode_path_unsafe /sourcecode/lib/facil/http/http.c:2461\n    #2 0x55fe3d9a680a in fuzzloop /sharedockerin/ta1729829438589mmde/test_file.c:29\n    #3 0x55fe3db25249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55fe3d9a5ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f2855d05d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f2855d05e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55fe3d9a5c04 in _start (/sharedockerin/ta1729829438589mmde/clouditera+0x1dbc04)\n\n0x60200000e996 is located 2 bytes to the right of 4-byte region [0x60200000e990,0x60200000e994)\nallocated by thread T0 here:\n    #0 0x7f28566de887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55fe3db2545c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/http/http.c:2377 in hex2byte\nShadow bytes around the buggy address:\n  0x0c047fff9ce0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff9cf0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff9d00: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff9d10: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff9d20: fa fa fd fd fa fa 00 04 fa fa 00 04 fa fa fd fd\n=>0x0c047fff9d30: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9d40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9d50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9d60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9d70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9d80: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: http_decode_path_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_path_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_path_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2375: static inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n2376:   if (source[0] >= '0' && source[0] <= '9')\n2377:     *dest = (source[0] - '0');\n2378:   else if ((source[0] >= 'a' && source[0] <= 'f') ||\n2379:            (source[0] >= 'A' && source[0] <= 'F'))\n2380:     *dest = (source[0] | 32) - 87;\n2381:   else\n2382:     return -1;\n2383:   *dest <<= 4;\n2384:   if (source[1] >= '0' && source[1] <= '9')\n2385:     *dest |= (source[1] - '0');\n2386:   else if ((source[1] >= 'a' && source[1] <= 'f') ||\n2387:            (source[1] >= 'A' && source[1] <= 'F'))\n2388:     *dest |= (source[1] | 32) - 87;\n2389:   else\n2390:     return -1;\n2391:   return 0;\n2392: }\n2393: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2455: ssize_t http_decode_path_unsafe(char *dest, const char *url_data) {\n2456:   char *pos = dest;\n2457:   while (*url_data) {\n2458:     if (*url_data == '%') {\n2459:       // decode hex value\n2460:       // this is a percent encoded value.\n2461:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2462:         return -1;\n2463:       pos++;\n2464:       url_data += 3;\n2465:     } else\n2466:       *(pos++) = *(url_data++);\n2467:   }\n2468:   *pos = 0;\n2469:   return pos - dest;\n2470: }\n2471:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==1705==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000128 at pc 0x55f9946015a3 bp 0x7ffc030f30a0 sp 0x7ffc030f3090\nREAD of size 1 at 0x602000000128 thread T0\n    #0 0x55f9946015a2 in rb_insert_color /sourcecode/src/kernel/rbtree.c:69\n    #1 0x55f9945ff739 in fuzzloop /dockerin/fuzz_drivers/tf1729593996258dnqv.cpp:24\n    #2 0x55f99460ebe9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55f9945ff348 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f784dceed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f784dceee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55f9945ff494 in _start (/dockerin/fuzz_drivers/tf1729593996258dnqv.out+0x17494)\n\n0x602000000128 is located 8 bytes to the left of 12-byte region [0x602000000130,0x60200000013c)\nallocated by thread T0 here:\n    #0 0x7f784e915887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f99460edfc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/rbtree.c:69 in rb_insert_color\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa[fa]00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa 01 fa fa fa 01 fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:41:20\n// Signature: rb_insert_color(struct rb_node *node, struct rb_root *root)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: rb_insert_color\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/rbtree.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    struct rb_node node;\n    struct rb_root root = RB_ROOT;\n\n    node.rb_parent = (struct rb_node*)fuzzData(0);\n    node.rb_right = (struct rb_node*)fuzzData(1);\n    node.rb_left = (struct rb_node*)fuzzData(2);\n    node.rb_color = fuzzUint8(3);\n\n    rb_insert_color(&node, &root);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/rbtree.c\n  65: void rb_insert_color(struct rb_node *node, struct rb_root *root)\n  66: {\n  67: \tstruct rb_node *parent, *gparent;\n  68: \n  69: \twhile ((parent = node->rb_parent) && parent->rb_color == RB_RED)\n  70: \t{\n  71: \t\tgparent = parent->rb_parent;\n  72: \n  73: \t\tif (parent == gparent->rb_left)\n  74: \t\t{\n  75: \t\t\t{\n  76: \t\t\t\tregister struct rb_node *uncle = gparent->rb_right;\n  77: \t\t\t\tif (uncle && uncle->rb_color == RB_RED)\n  78: \t\t\t\t{\n  79: \t\t\t\t\tuncle->rb_color = RB_BLACK;\n  80: \t\t\t\t\tparent->rb_color = RB_BLACK;\n  81: \t\t\t\t\tgparent->rb_color = RB_RED;\n  82: \t\t\t\t\tnode = gparent;\n  83: \t\t\t\t\tcontinue;\n  84: \t\t\t\t}\n  85: \t\t\t}\n  86: \n  87: \t\t\tif (parent->rb_right == node)\n  88: \t\t\t{\n  89: \t\t\t\tregister struct rb_node *tmp;\n  90: \t\t\t\t__rb_rotate_left(parent, root);\n  91: \t\t\t\ttmp = parent;\n  92: \t\t\t\tparent = node;\n  93: \t\t\t\tnode = tmp;\n  94: \t\t\t}\n  95: \n  96: \t\t\tparent->rb_color = RB_BLACK;\n  97: \t\t\tgparent->rb_color = RB_RED;\n  98: \t\t\t__rb_rotate_right(gparent, root);\n  99: \t\t} else {\n 100: \t\t\t{\n 101: \t\t\t\tregister struct rb_node *uncle = gparent->rb_left;\n 102: \t\t\t\tif (uncle && uncle->rb_color == RB_RED)\n 103: \t\t\t\t{\n 104: \t\t\t\t\tuncle->rb_color = RB_BLACK;\n 105: \t\t\t\t\tparent->rb_color = RB_BLACK;\n 106: \t\t\t\t\tgparent->rb_color = RB_RED;\n 107: \t\t\t\t\tnode = gparent;\n 108: \t\t\t\t\tcontinue;\n 109: \t\t\t\t}\n 110: \t\t\t}\n 111: \n 112: \t\t\tif (parent->rb_left == node)\n 113: \t\t\t{\n 114: \t\t\t\tregister struct rb_node *tmp;\n 115: \t\t\t\t__rb_rotate_right(parent, root);\n 116: \t\t\t\ttmp = parent;\n 117: \t\t\t\tparent = node;\n 118: \t\t\t\tnode = tmp;\n 119: \t\t\t}\n 120: \n 121: \t\t\tparent->rb_color = RB_BLACK;\n 122: \t\t\tgparent->rb_color = RB_RED;\n 123: \t\t\t__rb_rotate_left(gparent, root);\n 124: \t\t}\n 125: \t}\n 126: \n 127: \troot->rb_node->rb_color = RB_BLACK;\n 128: }\n 129:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3815==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000118 at pc 0x563af0a7b31f bp 0x7ffe382e4010 sp 0x7ffe382e4000\nREAD of size 8 at 0x602000000118 thread T0\n    #0 0x563af0a7b31e in IOService::aio_finish(void*) /sourcecode/src/kernel/IOService_linux.cc:352\n    #1 0x563af0a77644 in fuzzloop /dockerin/fuzz_drivers/tf1729593105334clfp.cpp:28\n    #2 0x563af0a83d59 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x563af0a77408 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f3428145d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f3428145e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x563af0a77554 in _start (/dockerin/fuzz_drivers/tf1729593105334clfp.out+0x14554)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f3428d6c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x563af0a83f6c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/IOService_linux.cc:352 in IOService::aio_finish(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: IOService::aio_finish(void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN9IOService10aio_finishEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/syscall.h> //extract\n#include <sys/types.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <unistd.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include \"list.h\" //extract\n#include \"IOService_linux.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(0);\n    void * ret = IOService::aio_finish(context);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/IOService_linux.cc\n 346: void *IOService::aio_finish(void *context)\n 347: {\n 348: \tIOService *service = (IOService *)context;\n 349: \tIOSession *session;\n 350: \tstruct io_event event;\n 351: \n 352: \tif (io_getevents(service->io_ctx, 1, 1, &event, NULL) > 0)\n 353: \t{\n 354: \t\tservice->incref();\n 355: \t\tsession = (IOSession *)event.data;\n 356: \t\tsession->res = event.res;\n 357: \t\treturn session;\n 358: \t}\n 359: \n 360: \treturn NULL;\n 361: }\n 362:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==29033==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6060000000c0 at pc 0x55ecadf76d50 bp 0x7ffed537a280 sp 0x7ffed537a270\nREAD of size 8 at 0x6060000000c0 thread T0\n    #0 0x55ecadf76d4f in UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:596\n    #1 0x55ecadf5f04c in fuzzloop /dockerin/fuzz_drivers/tf1729593105367zxxo.cpp:41\n    #2 0x55ecae12cee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55ecadf5e978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f8d9ffcad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f8d9ffcae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55ecadf5eac4 in _start (/dockerin/fuzz_drivers/tf1729593105367zxxo.out+0x381ac4)\n\n0x6060000000c0 is located 8 bytes to the right of 56-byte region [0x606000000080,0x6060000000b8)\nallocated by thread T0 here:\n    #0 0x7f8da0bf31e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55ecadf602db in std::_MakeUniq<PolicyAddrParams>::__single_object std::make_unique<PolicyAddrParams>() /usr/include/c++/11/bits/unique_ptr.h:962\n    #2 0x55ecadf5ed99 in fuzzloop /dockerin/fuzz_drivers/tf1729593105367zxxo.cpp:39\n    #3 0x55ecae12cee9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:596 in UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x0c0c7fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c0c7fff8000: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n=>0x0c0c7fff8010: 00 00 00 00 00 00 00 fa[fa]fa fa fa fa fa fa fa\n  0x0c0c7fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c0c7fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy15fuse_one_serverEPK15EndpointAddress\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/nameservice -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"_include/workflow/UpstreamPolicies.h\" //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <stdint.h> //extract\n#include <vector> //extract\n#include <chrono> //extract\n#include \"URIParser.h\" //extract\n#include \"WFTaskError.h\" //extract\n#include \"StringUtil.h\" //extract\n#include \"WFGlobal.h\" //extract\n#include \"WFNameService.h\" //extract\n#include \"WFDnsResolver.h\" //extract\n#include \"WFServiceGovernance.h\" //extract\n#include <pthread.h> //extract\n#include <algorithm> //extract\n#include <random> //extract\n#include \"rbtree.h\" //extract\n#include \"UpstreamPolicies.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    bool try_another = fuzzBool(0);\n    auto upsweightedrandompolicy = std::make_unique<UPSWeightedRandomPolicy>(try_another);\n    std::string address = fuzzString(1);\n    auto address_params = std::make_unique<PolicyAddrParams>();\n    auto addr = std::make_unique<EndpointAddress>(address, address_params.get());\n    upsweightedrandompolicy->fuse_one_server(addr.get());\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 591: void UPSWeightedRandomPolicy::fuse_one_server(const EndpointAddress *addr)\n 592: {\n 593: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 594: \n 595: \tthis->nalives--;\n 596: \tif (--params->group->nalives == 0 && params->group->id > 0)\n 597: \t\tthis->available_weight -= params->group->weight;\n 598: \n 599: \tif (params->group_id < 0 && params->server_type == 0)\n 600: \t\tthis->available_weight -= params->weight;\n 601: }\n 602:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==351077==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002d8 at pc 0x556f7deb0a97 bp 0x7ffd9f7f15a0 sp 0x7ffd9f7f1590\nREAD of size 8 at 0x6020000002d8 thread T0\n    #0 0x556f7deb0a96 in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&) /usr/include/c++/11/bits/stl_iterator.h:1028\n    #1 0x556f7deab30f in std::vector<EndpointAddress*, std::allocator<EndpointAddress*> >::end() /usr/include/c++/11/bits/stl_vector.h:830\n    #2 0x556f7de9b181 in UPSWeightedRandomPolicy::select_history_weight(WFNSTracing*) /sourcecode/src/nameservice/UpstreamPolicies.cc:512\n    #3 0x556f7de9b80f in UPSWeightedRandomPolicy::first_strategy(ParsedURI const&, WFNSTracing*) /sourcecode/src/nameservice/UpstreamPolicies.cc:526\n    #4 0x556f7de895d7 in fuzzloop /dockerin/fuzz_drivers/tf1729655721845dnzz.cpp:32\n    #5 0x556f7e0536e9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x556f7de888d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f4550902d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f4550902e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x556f7de88a24 in _start (/dockerin/fuzz_drivers/tf1729655721845dnzz.out+0x378a24)\n\n0x6020000002dc is located 0 bytes to the right of 12-byte region [0x6020000002d0,0x6020000002dc)\nallocated by thread T0 here:\n    #0 0x7f4551529887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556f7e0538fc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/11/bits/stl_iterator.h:1028 in __gnu_cxx::__normal_iterator<EndpointAddress**, std::vector<EndpointAddress*, std::allocator<EndpointAddress*> > >::__normal_iterator(EndpointAddress** const&)\nShadow bytes around the buggy address:\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n  0x0c047fff8020: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04\n  0x0c047fff8040: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04\n=>0x0c047fff8050: fa fa 00 04 fa fa 00 04 fa fa 00[04]fa fa 01 fa\n  0x0c047fff8060: fa fa 01 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:53:48\n// Signature: UPSWeightedRandomPolicy::first_strategy(ParsedURI &uri, WFNSTracing *tracing)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy14first_strategyERK9ParsedURIP11WFNSTracing\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFNameService.h\" // Add this line to include the WFNSTracing definition\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    ParsedURI uri;\n    WFNSTracing tracing;\n\n    uri.scheme = fuzzString(0);\n    uri.userinfo = fuzzString(1);\n    uri.host = fuzzString(2);\n    uri.port = fuzzString(3);\n    uri.path = fuzzString(4);\n    uri.query = fuzzString(5);\n    uri.fragment = fuzzString(6);\n\n    tracing.data = fuzzData(7);\n    // tracing.len = fuzzGetLen(7); // Remove this line as WFNSTracing does not have a 'len' member\n\n    UPSWeightedRandomPolicy policy(fuzzBool(8));\n    policy.first_strategy(uri, &tracing);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 503: int UPSWeightedRandomPolicy::select_history_weight(WFNSTracing *tracing)\n 504: {\n 505: \tstruct TracingData *tracing_data = (struct TracingData *)tracing->data;\n 506: \n 507: \tif (!tracing_data)\n 508: \t\treturn 0;\n 509: \n 510: \tint ret = 0;\n 511: \n 512: \tfor (EndpointAddress *server : tracing_data->history)\n 513: \t\tret += ((UPSAddrParams *)server->params)->weight;\n 514: \n 515: \treturn ret;\n 516: }\n 517: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 518: EndpointAddress *UPSWeightedRandomPolicy::first_strategy(const ParsedURI& uri,\n 519: \t\t\t\t\t\t\t\t\t\t\t\t\t\t WFNSTracing *tracing)\n 520: {\n 521: \tint x = 0;\n 522: \tint s = 0;\n 523: \tsize_t idx;\n 524: \tUPSAddrParams *params;\n 525: \tint temp_weight = this->total_weight;\n 526: \ttemp_weight -= UPSWeightedRandomPolicy::select_history_weight(tracing);\n 527: \n 528: \tif (temp_weight > 0)\n 529: \t\tx = rand() % temp_weight;\n 530: \n 531: \tfor (idx = 0; idx < this->servers.size(); idx++)\n 532: \t{\n 533: \t\tif (WFServiceGovernance::in_select_history(tracing, this->servers[idx]))\n 534: \t\t\tcontinue;\n 535: \n 536: \t\tparams = static_cast<UPSAddrParams *>(this->servers[idx]->params);\n 537: \t\ts += params->weight;\n 538: \t\tif (s > x)\n 539: \t\t\tbreak;\n 540: \t}\n 541: \tif (idx == this->servers.size())\n 542: \t\tidx--;\n 543: \n 544: \treturn this->servers[idx];\n 545: }\n 546:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==6707==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000140 at pc 0x56544d220fa1 bp 0x7fff08f77ff0 sp 0x7fff08f77fe0\nREAD of size 8 at 0x602000000140 thread T0\n    #0 0x56544d220fa0 in flatcc_emitter /sourcecode/src/runtime/emitter.c:204\n    #1 0x56544d21c68e in fuzzloop /dockerin/fuzz_drivers/tf1727601035346vvpl.c:34\n    #2 0x56544d22a969 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56544d21c328 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f479db2fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f479db2fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56544d21c474 in _start (/dockerin/fuzz_drivers/tf1727601035346vvpl.out+0x19474)\n\n0x602000000140 is located 0 bytes to the right of 16-byte region [0x602000000130,0x602000000140)\nallocated by thread T0 here:\n    #0 0x7f479e508887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56544d222e18 in driverAllocMem /home/clouditera/workdir-engine_c/betafuzz/structure/fuzzagentapi.c:140\n    #2 0x56544d22a969 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/runtime/emitter.c:204 in flatcc_emitter\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04 fa fa 00 00[fa]fa 00 04 fa fa 00 04\n  0x0c047fff8030: fa fa 00 fa fa fa 00 fa fa fa 04 fa fa fa 04 fa\n  0x0c047fff8040: fa fa 04 fa fa fa 04 fa fa fa 00 fa fa fa 00 fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/test/json_test/generated -Iinclude -Isrc/runtime -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1 -DFLATCC_JSON_PARSE_WIDE_SPACE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_emitter\n// Sign: flatcc_emitter(void *emit_context, flatcc_iovec_t *iov, int iov_count, flatbuffers_soffset_t offset, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include \"flatcc/flatcc_rtconfig.h\" //extract\n#include \"flatcc/flatcc_emitter.h\" //extract\n#include \"include/flatcc/flatcc_iov.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * emit_context = (void *)fuzzData(0);\n    //file: include/flatcc/flatcc_iov.h:16\n    //struct flatcc_iovec {\n    //    void *iov_base;\n    //    size_t iov_len;\n    //};\n    struct flatcc_iovec *iov = (struct flatcc_iovec *)driverAllocMem(sizeof(struct flatcc_iovec));\n    iov->iov_base = (void *)fuzzData(1);\n    iov->iov_len = (unsigned long)fuzzUint64(2);\n    \n    int iov_count = fuzzInt32(3);\n    int offset = fuzzInt32(4);\n    size_t len = (size_t)fuzzUint64(5);\n    int ret = flatcc_emitter(emit_context, iov, iov_count, offset, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/runtime/emitter.c\n 197: int flatcc_emitter(void *emit_context,\n 198:         const flatcc_iovec_t *iov, int iov_count,\n 199:         flatbuffers_soffset_t offset, size_t len)\n 200: {\n 201:     flatcc_emitter_t *E = emit_context;\n 202:     uint8_t *p;\n 203: \n 204:     E->used += len;\n 205:     if (offset < 0) {\n 206:         if (len <= E->front_left) {\n 207:             E->front_cursor -= len;\n 208:             E->front_left -= len;\n 209:             p = E->front_cursor;\n 210:             goto copy;\n 211:         }\n 212:         iov += iov_count;\n 213:         while (iov_count--) {\n 214:             --iov;\n 215:             if (copy_front(E, iov->iov_base, iov->iov_len)) {\n 216:                 return -1;\n 217:             }\n 218:         }\n 219:     } else {\n 220:         if (len <= E->back_left) {\n 221:             p = E->back_cursor;\n 222:             E->back_cursor += len;\n 223:             E->back_left -= len;\n 224:             goto copy;\n 225:         }\n 226:         while (iov_count--) {\n 227:             if (copy_back(E, iov->iov_base, iov->iov_len)) {\n 228:                 return -1;\n 229:             }\n 230:             ++iov;\n 231:         }\n 232:     }\n 233:     return 0;\n 234: copy:\n 235:     while (iov_count--) {\n 236:         memcpy(p, iov->iov_base, iov->iov_len);\n 237:         p += iov->iov_len;\n 238:         ++iov;\n 239:     }\n 240:     return 0;\n 241: }\n 242:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==25377==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000120 at pc 0x564064137d2a bp 0x7fff84bec5f0 sp 0x7fff84bec5e0\nREAD of size 8 at 0x602000000120 thread T0\n    #0 0x564064137d29 in Communicator::handler_thread_routine(void*) /sourcecode/src/kernel/Communicator.cc:1165\n    #1 0x564064120d74 in fuzzloop /dockerin/fuzz_drivers/tf1729593105309pcik.cpp:39\n    #2 0x56406417a219 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x564064120b38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fde8714bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fde8714be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x564064120c84 in _start (/dockerin/fuzz_drivers/tf1729593105309pcik.out+0x83c84)\n\n0x602000000120 is located 4 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fde87d72887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56406417a42c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/src/kernel/Communicator.cc:1165 in Communicator::handler_thread_routine(void*)\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00 04[fa]fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: Communicator::handler_thread_routine(void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator22handler_thread_routineEPv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -I_include/workflow -Isrc/kernel -DNDEBUG -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * context = (void *)fuzzData(0);\n    Communicator::handler_thread_routine(context);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1158: void Communicator::handler_thread_routine(void *context)\n1159: {\n1160: \tCommunicator *comm = (Communicator *)context;\n1161: \tstruct poller_result *res;\n1162: \n1163: \twhile (1)\n1164: \t{\n1165: \t\tres = (struct poller_result *)msgqueue_get(comm->msgqueue);\n1166: \t\tif (!res)\n1167: \t\t\tbreak;\n1168: \n1169: \t\tswitch (res->data.operation)\n1170: \t\t{\n1171: \t\tcase PD_OP_TIMER:\n1172: \t\t\tcomm->handle_sleep_result(res);\n1173: \t\t\tbreak;\n1174: \t\tcase PD_OP_READ:\n1175: \t\t\tcomm->handle_read_result(res);\n1176: \t\t\tbreak;\n1177: \t\tcase PD_OP_WRITE:\n1178: \t\t\tcomm->handle_write_result(res);\n1179: \t\t\tbreak;\n1180: \t\tcase PD_OP_CONNECT:\n1181: \t\tcase PD_OP_SSL_CONNECT:\n1182: \t\t\tcomm->handle_connect_result(res);\n1183: \t\t\tbreak;\n1184: \t\tcase PD_OP_LISTEN:\n1185: \t\t\tcomm->handle_listen_result(res);\n1186: \t\t\tbreak;\n1187: \t\tcase PD_OP_SSL_ACCEPT:\n1188: \t\t\tcomm->handle_ssl_accept_result(res);\n1189: \t\t\tbreak;\n1190: \t\tcase PD_OP_EVENT:\n1191: \t\tcase PD_OP_NOTIFY:\n1192: \t\t\tcomm->handle_aio_result(res);\n1193: \t\t\tbreak;\n1194: \t\t}\n1195: \n1196: \t\tfree(res);\n1197: \t}\n1198: }\n1199:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==299==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000c113 at pc 0x7f0f068e2397 bp 0x7ffe5cc8c130 sp 0x7ffe5cc8b8d8\nREAD of size 3 at 0x60200000c113 thread T0\n    #0 0x7f0f068e2396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x55cab905b419 in uint3korr /sourcecode/src/protocol/mysql_byteorder.h:179\n    #2 0x55cab905b97b in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:53\n    #3 0x55cab9058936 in parse_field_count /sourcecode/src/protocol/mysql_parser.c:357\n    #4 0x55cab9054cf5 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x55cab906b087 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #6 0x55cab8ffd6ae in fuzzloop /sharedockerin/ta1729664328007pfbx/test_file.cpp:19\n    #7 0x55cab90a1929 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #8 0x55cab8ffd2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #9 0x7f0f05d35d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #10 0x7f0f05d35e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #11 0x55cab8ffd404 in _start (/sharedockerin/ta1729664328007pfbx/clouditera+0x109404)\n\n0x60200000c113 is located 0 bytes to the right of 3-byte region [0x60200000c110,0x60200000c113)\nallocated by thread T0 here:\n    #0 0x7f0f0695c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55cab90a1b3c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff97d0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff97e0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff97f0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff9800: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff9810: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff9820: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9830: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9840: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9850: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9860: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff9870: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:02\n// Signature: protocol::MySQLResponse::decode_packet(unsigned char *buf, size_t buflen)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponse13decode_packetEPKhm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n    protocol::MySQLResponse response;\n    response.decode_packet((const unsigned char*)buf, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n 176: static inline uint32_t uint3korr(const unsigned char *A)\n 177: {\n 178: \tuint32_t ret = 0;\n 179: \tmemcpy(&ret, A, 3);\n 180: \treturn ret;\n 181: }\n 182: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 349: static int parse_field_count(const void *buf, size_t len, mysql_parser_t *parser)\n 350: {\n 351: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 352: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 353: \n 354: \tunsigned long long field_count;\n 355: \tstruct __mysql_result_set *result_set;\n 356: \n 357: \tif (decode_length_safe(&field_count, &p, buf_end) <= 0)\n 358: \t\treturn -2;\n 359: \n 360: \tfield_count = (field_count == ~0ULL) ? 0 : field_count;\n 361: \n 362: \tif (field_count)\n 363: \t{\n 364: \t\tresult_set = (struct __mysql_result_set *)malloc(sizeof (struct __mysql_result_set));\n 365: \t\tif (result_set == NULL)\n 366: \t\t\treturn -1;\n 367: \n 368: \t\tresult_set->fields = (mysql_field_t **)calloc(field_count, sizeof (mysql_field_t *));\n 369: \t\tif (result_set->fields == NULL)\n 370: \t\t{\n 371: \t\t\tfree(result_set);\n 372: \t\t\treturn -1;\n 373: \t\t}\n 374: \n 375: \t\tresult_set->field_count = field_count;\n 376: \t\tresult_set->row_count = 0;\n 377: \t\tresult_set->type = MYSQL_PACKET_GET_RESULT;\n 378: \n 379: \t\tlist_add_tail(&result_set->list, &parser->result_set_list);\n 380: \t\tparser->current_result_set = result_set;\n 381: \t\tparser->current_field_count = 0;\n 382: \t\tparser->result_set_count++;\n 383: \t\tparser->packet_type = MYSQL_PACKET_GET_RESULT;\n 384: \n 385: \t\tparser->parse = parse_column_def_packet;\n 386: \t\tparser->offset = p - (const unsigned char *)buf;\n 387: \t} else {\n 388: \t\tparser->parse = parse_ok_packet;\n 389: \t}\n 390: \treturn 0;\n 391: }\n 392: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #4:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==172==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000002a55 at pc 0x55f80efa4d15 bp 0x7ffe2fb91180 sp 0x7ffe2fb91170\nREAD of size 1 at 0x602000002a55 thread T0\n    #0 0x55f80efa4d14 in fio_json_parse /sourcecode/lib/facil/fiobj/fio_json_parser.h:456\n    #1 0x55f80efb334c in fiobj_json2obj /sourcecode/lib/facil/fiobj/fiobj_json.c:379\n    #2 0x55f80ef9e3be in fuzzloop /sharedockerin/ta1730101611730qass/test_file.c:19\n    #3 0x55f80f0a3cb9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55f80ef9da98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f9eec816d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f9eec816e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55f80ef9dbe4 in _start (/sharedockerin/ta1730101611730qass/clouditera+0x134be4)\n\n0x602000002a55 is located 0 bytes to the right of 5-byte region [0x602000002a50,0x602000002a55)\nallocated by thread T0 here:\n    #0 0x7f9eed1ef887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55f80f0a3ecc in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fiobj/fio_json_parser.h:456 in fio_json_parse\nShadow bytes around the buggy address:\n  0x0c047fff84f0: fa fa fd fa fa fa 00 00 fa fa fd fd fa fa fd fa\n  0x0c047fff8500: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8510: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n  0x0c047fff8520: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8530: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff8540: fa fa fd fa fa fa fd fa fa fa[05]fa fa fa fd fa\n  0x0c047fff8550: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8560: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8570: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8580: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\n  0x0c047fff8590: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:04:53\n// Signature: fiobj_json2obj(FIOBJ *pobj, void *data, size_t len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_json2obj\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fiobj/fiobj_json.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FIOBJ obj;\n    char *data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    fiobj_json2obj(&obj, data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fio_json_parser.h\n 310: static size_t __attribute__((unused))\n 311: fio_json_parse(json_parser_s *parser, const char *buffer, size_t length) {\n 312:   if (!length || !buffer)\n 313:     return 0;\n 314:   uint8_t *pos = (uint8_t *)buffer;\n 315:   const uint8_t *limit = pos + length;\n 316:   do {\n 317:     while (pos < limit && JSON_SEPERATOR[*pos])\n 318:       ++pos;\n 319:     if (pos == limit)\n 320:       goto stop;\n 321:     switch (*pos) {\n 322:     case '\"': {\n 323:       uint8_t *tmp = pos + 1;\n 324:       if (seek2eos(&tmp, limit) == 0)\n 325:         goto stop;\n 326:       if (parser->key) {\n 327:         uint8_t *key = tmp + 1;\n 328:         while (key < limit && JSON_SEPERATOR[*key])\n 329:           ++key;\n 330:         if (key >= limit)\n 331:           goto stop;\n 332:         if (*key != ':')\n 333:           goto error;\n 334:         ++pos;\n 335:         fio_json_on_string(parser, pos, (uintptr_t)(tmp - pos));\n 336:         pos = key + 1;\n 337:         parser->key = 0;\n 338:         continue; /* skip tests */\n 339:       } else {\n...skip...\n 426:         goto stop;\n 427:       if (pos + 4 < limit && pos[1] == 'a' && pos[2] == 'l' && pos[3] == 's' &&\n 428:           pos[4] == 'e')\n 429:         fio_json_on_false(parser);\n 430:       else\n 431:         goto error;\n 432:       pos += 5;\n 433:       break;\n 434:     case '-': /* overflow */\n 435:     case '0': /* overflow */\n 436:     case '1': /* overflow */\n 437:     case '2': /* overflow */\n 438:     case '3': /* overflow */\n 439:     case '4': /* overflow */\n 440:     case '5': /* overflow */\n 441:     case '6': /* overflow */\n 442:     case '7': /* overflow */\n 443:     case '8': /* overflow */\n 444:     case '9': /* overflow */\n 445:     case '.': /* overflow */\n 446:     case 'e': /* overflow */\n 447:     case 'E': /* overflow */\n 448:     case 'x': /* overflow */\n 449:     case 'i': /* overflow */\n 450:     case 'I': /* overflow */\n 451:     numeral : {\n 452:       uint8_t *tmp = pos;\n 453:       long long i = fio_atol((char **)&tmp);\n 454:       if (tmp > limit)\n 455:         goto stop;\n 456:       if (!tmp || JSON_NUMERAL[*tmp]) {\n 457:         tmp = pos;\n 458:         double f = fio_atof((char **)&tmp);\n 459:         if (tmp > limit)\n 460:           goto stop;\n 461:         if (!tmp || JSON_NUMERAL[*tmp])\n 462:           goto error;\n 463:         fio_json_on_float(parser, f);\n 464:         pos = tmp;\n 465:       } else {\n 466:         fio_json_on_number(parser, i);\n 467:         pos = tmp;\n 468:       }\n 469:       break;\n 470:     }\n 471:     case '#': /* Ruby style comment */\n 472:     {\n 473:       uint8_t *tmp = memchr(pos, '\\n', (uintptr_t)(limit - pos));\n 474:       if (!tmp)\n 475:         goto stop;\n 476:       pos = tmp + 1;\n 477:       continue; /* skip tests */\n 478:       ;\n 479:     }\n 480:     case '/': /* C style / Javascript style comment */\n 481:       if (pos[1] == '*') {\n 482:         if (pos + 4 > limit)\n 483:           goto stop;\n 484:         uint8_t *tmp = pos + 3; /* avoid this: /*/\n 485:         do {\n...skip...\n 486:           tmp = memchr(tmp, '/', (uintptr_t)(limit - tmp));\n 487:         } while (tmp && tmp[-1] != '*');\n 488:         if (!tmp)\n 489:           goto stop;\n 490:         pos = tmp + 1;\n 491:       } else if (pos[1] == '/') {\n 492:         uint8_t *tmp = memchr(pos, '\\n', (uintptr_t)(limit - pos));\n 493:         if (!tmp)\n 494:           goto stop;\n 495:         pos = tmp + 1;\n 496:       } else\n 497:         goto error;\n 498:       continue; /* skip tests */\n 499:       ;\n 500:     default:\n 501:       goto error;\n 502:     }\n 503:     if (parser->depth == 0) {\n 504:       fio_json_on_json(parser);\n 505:       goto stop;\n 506:     }\n 507:     parser->key = (parser->dict & 1);\n 508:   } while (pos < limit);\n 509: stop:\n 510:   return (size_t)((uintptr_t)pos - (uintptr_t)buffer);\n 511: error:\n 512:   fio_json_on_error(parser);\n 513:   return 0;\n 514: }\n 515: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fiobj/fiobj_json.c\n 377: size_t fiobj_json2obj(FIOBJ *pobj, const void *data, size_t len) {\n 378:   fiobj_json_parser_s p = {.top = FIOBJ_INVALID};\n 379:   size_t consumed = fio_json_parse(&p.p, data, len);\n 380:   if (!consumed || p.p.depth) {\n 381:     fiobj_free(fio_json_stack_get(&p.stack, 0));\n 382:     p.top = FIOBJ_INVALID;\n 383:   }\n 384:   fio_json_stack_free(&p.stack);\n 385:   fiobj_free(p.key);\n 386:   *pobj = p.top;\n 387:   return consumed;\n 388: }\n 389:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3149==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000011c at pc 0x55bbd7b512b5 bp 0x7ffedd6ca4c0 sp 0x7ffedd6ca4b0\nREAD of size 1 at 0x60200000011c thread T0\n    #0 0x55bbd7b512b4 in fio_siphash_xy /sourcecode/lib/facil/fio.c:8339\n    #1 0x55bbd7b527b3 in fio_siphash24 /sourcecode/lib/facil/fio.c:8398\n    #2 0x55bbd7ad6c4a in fuzzloop /dockerin/fuzz_drivers/tf1729822403005mkbx.c:23\n    #3 0x55bbd7b867f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55bbd7ad69d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fe016317d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fe016317e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55bbd7ad6b24 in _start (/dockerin/fuzz_drivers/tf1729822403005mkbx.out+0xc4b24)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fe016cf0887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55bbd7b86a0c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:8339 in fio_siphash_xy\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa 00[04]fa fa 00 fa fa fa 00 fa fa fa 00 fa\n  0x0c047fff8030: fa fa 00 fa fa fa 00 fa fa fa 00 fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_siphash24(void *data, size_t len, uint64_t key1, uint64_t key2)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_siphash24\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio_siphash.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * data = (void *)fuzzData(0);\n    size_t len = (size_t)fuzzUint64(1);\n    uint64_t key1 = fuzzUint64(2);\n    uint64_t key2 = fuzzUint64(3);\n    uint64_t ret = fio_siphash24(data, len, key1, key2);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n8329:     v1 = fio_lrot64(v1, 13) ^ v0;                                              \\\n8330:     v0 = fio_lrot64(v0, 32);                                                   \\\n8331:     v2 += v1;                                                                  \\\n8332:     v0 += v3;                                                                  \\\n8333:     v1 = fio_lrot64(v1, 17) ^ v2;                                              \\\n8334:     v3 = fio_lrot64(v3, 21) ^ v0;                                              \\\n8335:     v2 = fio_lrot64(v2, 32);                                                   \\\n8336:   } while (0);\n8337: \n8338:   while (len >= 8) {\n8339:     word.i = sip_local64(fio_str2u64(w8));\n8340:     v3 ^= word.i;\n8341:     /* Sip Rounds */\n8342:     for (size_t i = 0; i < x; ++i) {\n8343:       hash_map_SipRound;\n8344:     }\n8345:     v0 ^= word.i;\n8346:     w8 += 8;\n8347:     len -= 8;\n8348:   }\n8349:   word.i = 0;\n8350: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n8388:   hash_map_SipRound;\n8389:   hash_map_SipRound;\n8390:   /* XOR it all together */\n8391:   v0 ^= v1 ^ v2 ^ v3;\n8392: #undef hash_map_SipRound\n8393:   return v0;\n8394: }\n8395: \n8396: uint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n8397:                        uint64_t key2) {\n8398:   return fio_siphash_xy(data, len, 2, 4, key1, key2);\n8399: }\n8400: \n8401: uint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n8402:                        uint64_t key2) {\n8403:   return fio_siphash_xy(data, len, 1, 3, key1, key2);\n8404: }\n8405: \n8406: /* *****************************************************************************\n8407: SHA-1\n8408: ***************************************************************************** */\n8409:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4784==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000000 at pc 0x564c7bdc3702 bp 0x7ffe0a6da4e0 sp 0x7ffe0a6da4d0\nREAD of size 8 at 0x604000000000 thread T0\n    #0 0x564c7bdc3701 in big_realloc /sourcecode/lib/facil/fio.c:7964\n    #1 0x564c7bdc3ec8 in fio_realloc2 /sourcecode/lib/facil/fio.c:8115\n    #2 0x564c7bdc3fca in fio_realloc /sourcecode/lib/facil/fio.c:8136\n    #3 0x564c7bd4c26e in fuzzloop /dockerin/fuzz_drivers/tf1729822402999wmkc.c:26\n    #4 0x564c7bdfbe69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x564c7bd4b9d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f26994ead8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f26994eae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x564c7bd4bb24 in _start (/dockerin/fuzz_drivers/tf1729822402999wmkc.out+0xc5b24)\n\n0x604000000000 is located 16 bytes to the left of 39-byte region [0x604000000010,0x604000000037)\nallocated by thread T0 here:\n    #0 0x7f2699ec3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x564c7bdfc07c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /sourcecode/lib/facil/fio.c:7964 in big_realloc\nShadow bytes around the buggy address:\n  0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c087fff8000:[fa]fa 00 00 00 00 07 fa fa fa fa fa fa fa fa fa\n  0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fio_realloc(void *ptr, size_t new_size)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_realloc\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib/facil/legacy\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <time.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <fio_mem.h> //extract\n#include \"lib/facil/fio.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * ptr = (void *)fuzzData(0);\n    size_t new_size = (size_t)fuzzUint64(1);\n    void * ret = fio_realloc(ptr, new_size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7954: /* reads size header and frees memory back to the system */\n7955: static inline void big_free(void *ptr) {\n7956:   size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n7957:   sys_free(mem, *mem);\n7958: }\n7959: \n7960: /* reallocates memory using the system, resetting the size header */\n7961: static inline void *big_realloc(void *ptr, size_t new_size) {\n7962:   size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n7963:   new_size = sys_round_size(new_size + 16);\n7964:   mem = sys_realloc(mem, *mem, new_size);\n7965:   if (!mem)\n7966:     goto error;\n7967:   *mem = new_size;\n7968:   return (void *)(((uintptr_t)mem) + 16);\n7969: error:\n7970:   return NULL;\n7971: }\n7972: \n7973: /* *****************************************************************************\n7974: Allocator Initialization (initialize arenas and allocate a block for each CPU)\n7975: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n8105:  */\n8106: void *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n8107:   if (!ptr || ptr == (void *)&on_malloc_zero) {\n8108:     return fio_malloc(new_size);\n8109:   }\n8110:   if (!new_size) {\n8111:     goto zero_size;\n8112:   }\n8113:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8114:     /* big reallocation - direct from the system */\n8115:     return big_realloc(ptr, new_size);\n8116:   }\n8117:   /* allocated within block - don't even try to expand the allocation */\n8118:   /* ceiling for 16 byte alignement, translated to 16 byte units */\n8119:   void *new_mem = fio_malloc(new_size);\n8120:   if (!new_mem)\n8121:     return NULL;\n8122:   new_size = ((new_size >> 4) + (!!(new_size & 15)));\n8123:   copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n8124:   fio_memcpy(new_mem, ptr, copy_length > new_size ? new_size : copy_length);\n8125: \n8126: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8126:   block_slice_free(ptr);\n8127:   return new_mem;\n8128: zero_size:\n8129:   fio_free(ptr);\n8130:   return fio_malloc(0);\n8131: }\n8132: \n8133: void *fio_realloc(void *ptr, size_t new_size) {\n8134:   const size_t max_old =\n8135:       FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK);\n8136:   return fio_realloc2(ptr, new_size, max_old);\n8137: }\n8138: \n8139: /**\n8140:  * Allocates memory directly using `mmap`, this is prefered for larger objects\n8141:  * that have a long lifetime.\n8142:  *\n8143:  * `fio_free` can be used for deallocating the memory.\n8144:  */\n8145: void *fio_mmap(size_t size) {\n8146:   if (!size) {\n8147:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==39701==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000025c at pc 0x7fb86ab5c397 bp 0x7ffc01da9f50 sp 0x7ffc01da96f8\nREAD of size 65535 at 0x60200000025c thread T0\n    #0 0x7fb86ab5c396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x557e76b995e7 in ASN1_STRING_set crypto/asn1/asn1_lib.c:323\n    #2 0x557e76b7d1f8 in ossl_cmp_sk_ASN1_UTF8STRING_push_str crypto/cmp/cmp_util.c:231\n    #3 0x557e76b7a9f3 in fuzzloop /dockerin/fuzz_drivers/tf1730183725709kljw.c:43\n    #4 0x557e76ba3939 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x557e76b7a698 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7fb86961ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7fb86961ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x557e76b7a7e4 in _start (/dockerin/fuzz_drivers/tf1730183725709kljw.out+0x2b7e4)\n\n0x60200000025c is located 0 bytes to the right of 12-byte region [0x602000000250,0x60200000025c)\nallocated by thread T0 here:\n    #0 0x7fb86abd6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x557e76ba3b4c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 04 fa\n  0x0c047fff8020: fa fa 04 fa fa fa 04 fa fa fa 04 fa fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa 03 fa fa fa 00 04 fa fa fd fa\n=>0x0c047fff8040: fa fa 02 fa fa fa 00 04 fa fa 00[04]fa fa 04 fa\n  0x0c047fff8050: fa fa 04 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-29 06:24:58\n// Signature: ossl_cmp_sk_ASN1_UTF8STRING_push_str(struct stack_st_ASN1_UTF8STRING *sk, char *text, int len)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: ossl_cmp_sk_ASN1_UTF8STRING_push_str\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Iproviders/common/include -Iproviders/implementations/include -Icrypto/cmp -DAES_ASM -DBSAES_ASM -DCMLL_ASM -DECP_NISTZ256_ASM -DGHASH_ASM -DKECCAK1600_ASM -DMD5_ASM -DOPENSSL_BN_ASM_GF2m -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DPOLY1305_ASM -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DVPAES_ASM -DWHIRLPOOL_ASM -DX25519_ASM -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSLDIR=\"/usr/local/ssl\" -DENGINESDIR=\"/usr/local/lib64/engines-3\" -DMODULESDIR=\"/usr/local/lib64/ossl-modules\" -DOPENSSL_BUILDING_OPENSSL -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <string.h> //extract\n#include \"cmp_local.h\" //extract\n#include <time.h> //extract\n#include <openssl/cmp.h> //extract\n#include <openssl/crmf.h> //extract\n#include <openssl/err.h> /* needed in case config no-deprecated */ //extract\n#include <openssl/engine.h> //extract\n#include <openssl/evp.h> //extract\n#include <openssl/objects.h> //extract\n#include <openssl/x509.h> //extract\n#include <openssl/asn1err.h> /* for ASN1_R_TOO_SMALL and ASN1_R_TOO_LARGE */ //extract\n#include <openssl/cmp_util.h> //extract\n#include \"cmp_local.h\" /* just for decls of internal functions defined here */ //extract\n#include <openssl/cmperr.h> //extract\n#include <openssl/err.h> /* should be implied by cmperr.h */ //extract\n#include <openssl/x509v3.h> //extract\n\nint fuzzloop() {\n    int status = fuzzInt32(0);\n    int fail_info = fuzzInt32(1);\n    char * text = fuzzString(2);\n    OSSL_CMP_PKISI * si = OSSL_CMP_STATUSINFO_new(status, fail_info, text);\n    if (si == NULL)\n        return 0;\n    OSSL_CMP_PKIFREETEXT * sk = ossl_cmp_pkisi_get0_statusString(si);\n    if (sk == NULL)\n        return 0;\n    char * text1 = fuzzString(3);\n    int len = fuzzInt32(4);\n    int ret = ossl_cmp_sk_ASN1_UTF8STRING_push_str(sk, text1, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/asn1/asn1_lib.c\n 286: int ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len_in)\n 287: {\n 288:     unsigned char *c;\n 289:     const char *data = _data;\n 290:     size_t len;\n 291: \n 292:     if (len_in < 0) {\n 293:         if (data == NULL)\n 294:             return 0;\n 295:         len = strlen(data);\n 296:     } else {\n 297:         len = (size_t)len_in;\n 298:     }\n 299:     /*\n 300:      * Verify that the length fits within an integer for assignment to\n 301:      * str->length below.  The additional 1 is subtracted to allow for the\n 302:      * '\\0' terminator even though this isn't strictly necessary.\n 303:      */\n 304:     if (len > INT_MAX - 1) {\n 305:         ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);\n 306:         return 0;\n 307:     }\n 308:     if ((size_t)str->length <= len || str->data == NULL) {\n 309:         c = str->data;\n 310: #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n 311:         /* No NUL terminator in fuzzing builds */\n 312:         str->data = OPENSSL_realloc(c, len != 0 ? len : 1);\n 313: #else\n 314:         str->data = OPENSSL_realloc(c, len + 1);\n 315: #endif\n 316:         if (str->data == NULL) {\n 317:             str->data = c;\n 318:             return 0;\n 319:         }\n 320:     }\n 321:     str->length = len;\n 322:     if (data != NULL) {\n 323:         memcpy(str->data, data, len);\n 324: #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n 325:         /* Set the unused byte to something non NUL and printable. */\n 326:         if (len == 0)\n 327:             str->data[len] = '~';\n 328: #else\n 329:         /*\n 330:          * Add a NUL terminator. This should not be necessary - but we add it as\n 331:          * a safety precaution\n 332:          */\n 333:         str->data[len] = '\\0';\n 334: #endif\n 335:     }\n 336:     return 1;\n 337: }\n 338: \nStacktrace #1:\nFile: /sourcecode/crypto/cmp/cmp_util.c\n 222: int ossl_cmp_sk_ASN1_UTF8STRING_push_str(STACK_OF(ASN1_UTF8STRING) *sk,\n 223:                                          const char *text, int len)\n 224: {\n 225:     ASN1_UTF8STRING *utf8string;\n 226: \n 227:     if (!ossl_assert(sk != NULL && text != NULL))\n 228:         return 0;\n 229:     if ((utf8string = ASN1_UTF8STRING_new()) == NULL)\n 230:         return 0;\n 231:     if (!ASN1_STRING_set(utf8string, text, len))\n 232:         goto err;\n 233:     if (!sk_ASN1_UTF8STRING_push(sk, utf8string))\n 234:         goto err;\n 235:     return 1;\n 236: \n 237:  err:\n 238:     ASN1_UTF8STRING_free(utf8string);\n 239:     return 0;\n 240: }\n 241:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==355==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000521 at pc 0x55a62f493308 bp 0x7ffd60e97ab0 sp 0x7ffd60e97aa0\nREAD of size 4 at 0x603000000521 thread T0\n    #0 0x55a62f493307 in uint4korr /sourcecode/src/protocol/mysql_byteorder.h:51\n    #1 0x55a62f49953c in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:446\n    #2 0x55a62f494153 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #3 0x55a62f4aa4e5 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #4 0x55a62f43c6ae in fuzzloop /sharedockerin/ta1729664330130qvkp/test_file.cpp:25\n    #5 0x55a62f4e0d89 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #6 0x55a62f43c2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #7 0x7f67c24acd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #8 0x7f67c24ace3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #9 0x55a62f43c404 in _start (/sharedockerin/ta1729664330130qvkp/clouditera+0x10a404)\n\n0x603000000521 is located 1 bytes inside of 24-byte region [0x603000000520,0x603000000538)\nfreed by thread T0 here:\n    #0 0x7f67c30d3537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x55a62f4e0fcc in BetaWfree /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:97\n\npreviously allocated by thread T0 here:\n    #0 0x7f67c30d3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55a62f4e0f9c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/src/protocol/mysql_byteorder.h:51 in uint4korr\nShadow bytes around the buggy address:\n  0x0c067fff8050: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff8060: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff8070: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff8080: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff8090: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n=>0x0c067fff80a0: fd fa fa fa[fd]fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80b0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fd\n  0x0c067fff80c0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff80d0: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80e0: fd fd fd fa fa fa fd fd fd fd fa fa fd fd fd fa\n  0x0c067fff80f0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:50:22\n// Signature: protocol::MySQLResponse::MySQLResponse()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponseC1Ev\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// Derived class to expose protected method\nclass FuzzMySQLResponse : public protocol::MySQLResponse {\npublic:\n    using protocol::MySQLResponse::decode_packet;\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FuzzMySQLResponse response;\n    char* data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    response.decode_packet((const unsigned char*)data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  49: static inline uint32_t uint4korr(const unsigned char *A)\n  50: {\n  51: \tuint32_t ret;\n  52: \tmemcpy(&ret, A, sizeof(ret));\n  53: \treturn ret;\n  54: }\n  55: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #3:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==206==ERROR: AddressSanitizer: heap-use-after-free on address 0x60600000178d at pc 0x5591467e97c9 bp 0x7fff157c4410 sp 0x7fff157c4400\nREAD of size 1 at 0x60600000178d thread T0\n    #0 0x5591467e97c8 in hex2byte /sourcecode/lib/facil/http/http.c:2388\n    #1 0x5591467ea504 in http_decode_path_unsafe /sourcecode/lib/facil/http/http.c:2461\n    #2 0x5591466d780a in fuzzloop /sharedockerin/ta1730101611417egzi/test_file.c:29\n    #3 0x559146856249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x5591466d6ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f7693313d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f7693313e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x5591466d6c04 in _start (/sharedockerin/ta1730101611417egzi/clouditera+0x1dbc04)\n\n0x60600000178d is located 45 bytes inside of 63-byte region [0x606000001760,0x60600000179f)\nfreed by thread T0 here:\n    #0 0x7f7693cec537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x5591468b6759 in extract_stack_trace /home/clouditera/workdir-engine_c/betafuzz/structure/customReport.c:119\n\npreviously allocated by thread T0 here:\n    #0 0x7f7693ceca57 in __interceptor_calloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154\n    #1 0x5591468b6697 in extract_stack_trace /home/clouditera/workdir-engine_c/betafuzz/structure/customReport.c:94\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/lib/facil/http/http.c:2388 in hex2byte\nShadow bytes around the buggy address:\n  0x0c0c7fff82a0: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n  0x0c0c7fff82b0: fd fd fd fd fd fd fd fa fa fa fa fa fd fd fd fd\n  0x0c0c7fff82c0: fd fd fd fa fa fa fa fa fd fd fd fd fd fd fd fa\n  0x0c0c7fff82d0: fa fa fa fa fd fd fd fd fd fd fd fa fa fa fa fa\n  0x0c0c7fff82e0: 00 00 00 00 00 00 03 fa fa fa fa fa fd fd fd fd\n=>0x0c0c7fff82f0: fd[fd]fd fd fa fa fa fa fd fd fd fd fd fd fd fd\n  0x0c0c7fff8300: fa fa fa fa fd fd fd fd fd fd fd fd fa fa fa fa\n  0x0c0c7fff8310: fd fd fd fd fd fd fd fd fa fa fa fa fd fd fd fd\n  0x0c0c7fff8320: fd fd fd fd fa fa fa fa fd fd fd fd fd fd fd fd\n  0x0c0c7fff8330: fa fa fa fa fd fd fd fd fd fd fd fd fa fa fa fa\n  0x0c0c7fff8340: fd fd fd fd fd fd fd fd fa fa fa fa fd fd fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: http_decode_path_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_path_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_path_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2375: static inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n2376:   if (source[0] >= '0' && source[0] <= '9')\n2377:     *dest = (source[0] - '0');\n2378:   else if ((source[0] >= 'a' && source[0] <= 'f') ||\n2379:            (source[0] >= 'A' && source[0] <= 'F'))\n2380:     *dest = (source[0] | 32) - 87;\n2381:   else\n2382:     return -1;\n2383:   *dest <<= 4;\n2384:   if (source[1] >= '0' && source[1] <= '9')\n2385:     *dest |= (source[1] - '0');\n2386:   else if ((source[1] >= 'a' && source[1] <= 'f') ||\n2387:            (source[1] >= 'A' && source[1] <= 'F'))\n2388:     *dest |= (source[1] | 32) - 87;\n2389:   else\n2390:     return -1;\n2391:   return 0;\n2392: }\n2393: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2455: ssize_t http_decode_path_unsafe(char *dest, const char *url_data) {\n2456:   char *pos = dest;\n2457:   while (*url_data) {\n2458:     if (*url_data == '%') {\n2459:       // decode hex value\n2460:       // this is a percent encoded value.\n2461:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2462:         return -1;\n2463:       pos++;\n2464:       url_data += 3;\n2465:     } else\n2466:       *(pos++) = *(url_data++);\n2467:   }\n2468:   *pos = 0;\n2469:   return pos - dest;\n2470: }\n2471:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==132==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000021981 at pc 0x5565198322ca bp 0x7fffe8f64cf0 sp 0x7fffe8f64ce0\nWRITE of size 1 at 0x603000021981 thread T0\n    #0 0x5565198322c9 in fio_ltoa /sourcecode/lib/facil/fio.c:4855\n    #1 0x556519834169 in fio_ftoa /sourcecode/lib/facil/fio.c:4994\n    #2 0x5565197f0288 in fuzzloop /sharedockerin/ta1730101611642vjjm/test_file.c:39\n    #3 0x55651989fe69 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x5565197ef9d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f1097ef3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f1097ef3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x5565197efb24 in _start (/sharedockerin/ta1730101611642vjjm/clouditera+0xc5b24)\n\n0x603000021981 is located 48 bytes to the right of 17-byte region [0x603000021940,0x603000021951)\nallocated by thread T0 here:\n    #0 0x7f10988cc887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5565198a007c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/lib/facil/fio.c:4855 in fio_ltoa\nShadow bytes around the buggy address:\n  0x0c067fffc2e0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fffc2f0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fffc300: fd fa fa fa 00 00 01 fa fa fa fd fd fd fa fa fa\n  0x0c067fffc310: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fffc320: fa fa fd fd fd fa fa fa 00 00 01 fa fa fa fd fd\n=>0x0c067fffc330:[fd]fd fa fa fd fd fd fd fa fa fd fd fd fd fa fa\n  0x0c067fffc340: fd fd fd fd fa fa fd fd fd fd fa fa fd fd fd fd\n  0x0c067fffc350: fa fa fd fd fd fa fa fa fd fd fd fd fa fa fd fd\n  0x0c067fffc360: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fffc370: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fffc380: fa fa fd fd fd fd fa fa fd fd fd fd fa fa fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: fio_ftoa(char *dest, double num, uint8_t base)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_ftoa\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <ctype.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <pthread.h> //extract\n#include <sys/mman.h> //extract\n#include <unistd.h> //extract\n#include <netdb.h> //extract\n#include <netinet/in.h> //extract\n#include <netinet/tcp.h> //extract\n#include <poll.h> //extract\n#include <sys/ioctl.h> //extract\n#include <sys/resource.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <sys/un.h> //extract\n#include <sys/wait.h> //extract\n#include <arpa/inet.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    double num = fuzzDouble(1);\n    uint8_t base = fuzzUint8(2);\n    size_t ret = fio_ftoa(dest, num, base);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4821: size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n4822:   const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n4823:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n4824: \n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n4831:   switch (base) {\n4832:   case 1: /* fallthrough */\n4833:   case 2:\n4834:     /* Base 2 */\n4835:     {\n4836:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4837:       uint8_t i = 0;    /* counting bits */\n4838:       dest[len++] = '0';\n4839:       dest[len++] = 'b';\n4840: \n4841:       while ((i < 64) && (n & 0x8000000000000000) == 0) {\n4842:         n = n << 1;\n4843:         i++;\n4844:       }\n4845:       /* make sure the Binary representation doesn't appear signed. */\n4846:       if (i) {\n4847:         dest[len++] = '0';\n4848:       }\n4849:       /* write to dest. */\n4850:       while (i < 64) {\n...skip...\n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n4831:   switch (base) {\n4832:   case 1: /* fallthrough */\n4833:   case 2:\n4834:     /* Base 2 */\n4835:     {\n4836:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4837:       uint8_t i = 0;    /* counting bits */\n4838:       dest[len++] = '0';\n4839:       dest[len++] = 'b';\n4840: \n4841:       while ((i < 64) && (n & 0x8000000000000000) == 0) {\n4842:         n = n << 1;\n4843:         i++;\n4844:       }\n4845:       /* make sure the Binary representation doesn't appear signed. */\n4846:       if (i) {\n4847:         dest[len++] = '0';\n4848:       }\n4849:       /* write to dest. */\n4850:       while (i < 64) {\n4851:         dest[len++] = ((n & 0x8000000000000000) ? '1' : '0');\n4852:         n = n << 1;\n4853:         i++;\n4854:       }\n4855:       dest[len] = 0;\n4856:       return len;\n4857:     }\n4858:   case 8:\n4859:     /* Base 8 */\n4860:     {\n4861:       uint64_t l = 0;\n4862:       if (num < 0) {\n4863:         dest[len++] = '-';\n4864:         num = 0 - num;\n4865:       }\n4866:       dest[len++] = '0';\n4867: \n4868:       while (num) {\n4869:         buf[l++] = '0' + (num & 7);\n4870:         num = num >> 3;\n4871:       }\n4872:       while (l) {\n4873:         --l;\n4874:         dest[len++] = buf[l];\n4875:       }\n4876:       dest[len] = 0;\n4877:       return len;\n4878:     }\n4879: \n4880:   case 16:\n4881:     /* Base 16 */\n4882:     {\n4883:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4884:       uint8_t i = 0;    /* counting bits */\n...skip...\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960:     break;\n4961:   case 8:\n4962:     dest[len++] = '0';\n4963:     break;\n4964:   case 16:\n4965:     dest[len++] = '0';\n4966:     dest[len++] = 'x';\n4967:     dest[len++] = '0';\n4968:     break;\n4969:   }\n4970:   dest[len++] = '0';\n4971:   dest[len] = 0;\n4972:   return len;\n4973: }\n4974: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n4988: size_t fio_ftoa(char *dest, double num, uint8_t base) {\n4989:   if (base == 2 || base == 16) {\n4990:     /* handle the binary / Hex representation the same as if it were an\n4991:      * int64_t\n4992:      */\n4993:     int64_t *i = (void *)&num;\n4994:     return fio_ltoa(dest, *i, base);\n4995:   }\n4996: \n4997:   size_t written = sprintf(dest, \"%g\", num);\n4998:   uint8_t need_zero = 1;\n4999:   char *start = dest;\n5000:   while (*start) {\n5001:     if (*start == ',') // locale issues?\n5002:       *start = '.';\n5003:     if (*start == '.' || *start == 'e') {\n5004:       need_zero = 0;\n5005:       break;\n5006:     }\n5007:     start++;\n5008:   }\n5009:   if (need_zero) {\n5010:     dest[written++] = '.';\n5011:     dest[written++] = '0';\n5012:   }\n5013:   return written;\n5014: }\n5015:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==214==ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000006d6 at pc 0x55fe3dab972f bp 0x7fff5ba2d7d0 sp 0x7fff5ba2d7c0\nWRITE of size 1 at 0x6020000006d6 thread T0\n    #0 0x55fe3dab972e in http_decode_path_unsafe /sourcecode/lib/facil/http/http.c:2468\n    #1 0x55fe3d9a680a in fuzzloop /sharedockerin/ta1729829438589mmde/test_file.c:29\n    #2 0x55fe3db25249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55fe3d9a5ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f2855d05d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f2855d05e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55fe3d9a5c04 in _start (/sharedockerin/ta1729829438589mmde/clouditera+0x1dbc04)\n\n0x6020000006d6 is located 449 bytes to the right of 5-byte region [0x602000000510,0x602000000515)\nallocated by thread T0 here:\n    #0 0x7f28566de887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55fe3db2545c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/lib/facil/http/http.c:2468 in http_decode_path_unsafe\nShadow bytes around the buggy address:\n  0x0c047fff8080: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8090: fa fa fd fd fa fa fd fd fa fa 05 fa fa fa fd fa\n  0x0c047fff80a0: fa fa 05 fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff80c0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80d0: fa fa fd fa fa fa fd fa fa fa[fd]fa fa fa fd fa\n  0x0c047fff80e0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff80f0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8100: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8110: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8120: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: http_decode_path_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_path_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_path_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2455: ssize_t http_decode_path_unsafe(char *dest, const char *url_data) {\n2456:   char *pos = dest;\n2457:   while (*url_data) {\n2458:     if (*url_data == '%') {\n2459:       // decode hex value\n2460:       // this is a percent encoded value.\n2461:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2462:         return -1;\n2463:       pos++;\n2464:       url_data += 3;\n2465:     } else\n2466:       *(pos++) = *(url_data++);\n2467:   }\n2468:   *pos = 0;\n2469:   return pos - dest;\n2470: }\n2471:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==355==ERROR: AddressSanitizer: heap-use-after-free on address 0x6030000004f7 at pc 0x55a62f49a9fc bp 0x7ffd60e97a40 sp 0x7ffd60e97a30\nREAD of size 1 at 0x6030000004f7 thread T0\n    #0 0x55a62f49a9fb in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:29\n    #1 0x55a62f49b0f2 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #2 0x55a62f498d42 in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:420\n    #3 0x55a62f494153 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #4 0x55a62f4aa4e5 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #5 0x55a62f43c6ae in fuzzloop /sharedockerin/ta1729664330130qvkp/test_file.cpp:25\n    #6 0x55a62f4e0d89 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x55a62f43c2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7f67c24acd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7f67c24ace3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x55a62f43c404 in _start (/sharedockerin/ta1729664330130qvkp/clouditera+0x10a404)\n\n0x6030000004f7 is located 7 bytes inside of 20-byte region [0x6030000004f0,0x603000000504)\nfreed by thread T0 here:\n    #0 0x7f67c30d3537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x55a62f4e0fcc in BetaWfree /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:97\n\npreviously allocated by thread T0 here:\n    #0 0x7f67c30d3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55a62f4e0f9c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/src/protocol/mysql_byteorder.c:29 in decode_length_safe\nShadow bytes around the buggy address:\n  0x0c067fff8040: fd fd fa fa fd fd fd fd fa fa fd fd fd fa fa fa\n  0x0c067fff8050: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff8060: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff8070: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff8080: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n=>0x0c067fff8090: fa fa fd fd fd fa fa fa fd fd fd fa fa fa[fd]fd\n  0x0c067fff80a0: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80b0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fd\n  0x0c067fff80c0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff80d0: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80e0: fd fd fd fa fa fa fd fd fd fd fa fa fd fd fd fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:50:22\n// Signature: protocol::MySQLResponse::MySQLResponse()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponseC1Ev\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// Derived class to expose protected method\nclass FuzzMySQLResponse : public protocol::MySQLResponse {\npublic:\n    using protocol::MySQLResponse::decode_packet;\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FuzzMySQLResponse response;\n    char* data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    response.decode_packet((const unsigned char*)data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #4:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==355==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000525 at pc 0x55a62f499670 bp 0x7ffd60e97b60 sp 0x7ffd60e97b50\nREAD of size 1 at 0x603000000525 thread T0\n    #0 0x55a62f49966f in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:447\n    #1 0x55a62f494153 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #2 0x55a62f4aa4e5 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #3 0x55a62f43c6ae in fuzzloop /sharedockerin/ta1729664330130qvkp/test_file.cpp:25\n    #4 0x55a62f4e0d89 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55a62f43c2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f67c24acd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f67c24ace3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55a62f43c404 in _start (/sharedockerin/ta1729664330130qvkp/clouditera+0x10a404)\n\n0x603000000525 is located 5 bytes inside of 24-byte region [0x603000000520,0x603000000538)\nfreed by thread T0 here:\n    #0 0x7f67c30d3537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x55a62f4e0fcc in BetaWfree /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:97\n\npreviously allocated by thread T0 here:\n    #0 0x7f67c30d3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55a62f4e0f9c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/src/protocol/mysql_parser.c:447 in parse_column_def_packet\nShadow bytes around the buggy address:\n  0x0c067fff8050: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff8060: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff8070: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff8080: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff8090: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n=>0x0c067fff80a0: fd fa fa fa[fd]fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80b0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fd\n  0x0c067fff80c0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff80d0: fd fa fa fa fd fd fd fa fa fa fd fd fd fa fa fa\n  0x0c067fff80e0: fd fd fd fa fa fa fd fd fd fd fa fa fd fd fd fa\n  0x0c067fff80f0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:50:22\n// Signature: protocol::MySQLResponse::MySQLResponse()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponseC1Ev\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// Derived class to expose protected method\nclass FuzzMySQLResponse : public protocol::MySQLResponse {\npublic:\n    using protocol::MySQLResponse::decode_packet;\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FuzzMySQLResponse response;\n    char* data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    response.decode_packet((const unsigned char*)data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #2:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==196==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000400 at pc 0x55895b0da0fb bp 0x7ffd80fcb8b0 sp 0x7ffd80fcb8a0\nWRITE of size 1 at 0x603000000400 thread T0\n    #0 0x55895b0da0fa in http_decode_url_unsafe /sourcecode/lib/facil/http/http.c:2433\n    #1 0x55895afc780a in fuzzloop /sharedockerin/ta1730101611048ltan/test_file.c:29\n    #2 0x55895b146249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55895afc6ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f00f5f46d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f00f5f46e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55895afc6c04 in _start (/sharedockerin/ta1730101611048ltan/clouditera+0x1dbc04)\n\n0x603000000400 is located 76 bytes to the right of 20-byte region [0x6030000003a0,0x6030000003b4)\nallocated by thread T0 here:\n    #0 0x7f00f691f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55895b14645c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/lib/facil/http/http.c:2433 in http_decode_url_unsafe\nShadow bytes around the buggy address:\n  0x0c067fff8030: fa fa fd fd fd fd fa fa fd fd fd fd fa fa fd fd\n  0x0c067fff8040: fd fd fa fa 00 00 00 00 fa fa fd fd fd fa fa fa\n  0x0c067fff8050: 00 00 00 fa fa fa 00 00 00 00 fa fa 00 00 01 fa\n  0x0c067fff8060: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff8070: fd fa fa fa 00 00 04 fa fa fa fd fd fd fd fa fa\n=>0x0c067fff8080:[fd]fd fd fd fa fa fd fd fd fd fa fa fd fd fd fd\n  0x0c067fff8090: fa fa fd fd fd fd fa fa fd fd fd fd fa fa fd fd\n  0x0c067fff80a0: fd fa fa fa fd fd fd fd fa fa fd fd fd fa fa fa\n  0x0c067fff80b0: fd fd fd fa fa fa fd fd fd fa fa fa fd fd fd fa\n  0x0c067fff80c0: fa fa fd fd fd fa fa fa fd fd fd fa fa fa fd fd\n  0x0c067fff80d0: fd fd fa fa fd fd fd fd fa fa fd fd fd fd fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: http_decode_url_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_url_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_url_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2416: ssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n2417:   char *pos = dest;\n2418:   while (*url_data) {\n2419:     if (*url_data == '+') {\n2420:       // decode space\n2421:       *(pos++) = ' ';\n2422:       ++url_data;\n2423:     } else if (*url_data == '%') {\n2424:       // decode hex value\n2425:       // this is a percent encoded value.\n2426:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2427:         return -1;\n2428:       pos++;\n2429:       url_data += 3;\n2430:     } else\n2431:       *(pos++) = *(url_data++);\n2432:   }\n2433:   *pos = 0;\n2434:   return pos - dest;\n2435: }\n2436:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4967==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000110 at pc 0x7f0358d2b397 bp 0x7ffdf00888d0 sp 0x7ffdf0088078\nREAD of size 12 at 0x602000000110 thread T0\n    #0 0x7f0358d2b396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x558e6ab24f3b in redis_parser_append_message /sourcecode/src/protocol/redis_parser.c:447\n    #2 0x558e6ab1e837 in fuzzloop /dockerin/fuzz_drivers/tf1729593377980znne.cpp:24\n    #3 0x558e6ab2e8f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x558e6ab1e468 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f035817ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f035817ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x558e6ab1e5b4 in _start (/dockerin/fuzz_drivers/tf1729593377980znne.out+0x1a5b4)\n\n0x602000000110 is located 0 bytes inside of 12-byte region [0x602000000110,0x60200000011c)\nfreed by thread T0 here:\n    #0 0x7f0358da5c38 in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164\n    #1 0x558e6ab24c52 in redis_parser_append_message /sourcecode/src/protocol/redis_parser.c:439\n    #2 0x558e6ab1e837 in fuzzloop /dockerin/fuzz_drivers/tf1729593377980znne.cpp:24\n    #3 0x558e6ab2e8f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\npreviously allocated by thread T0 here:\n    #0 0x7f0358da5887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x558e6ab2eb0c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa 00 07 fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa 00 04\n=>0x0c047fff8020: fa fa[fd]fd fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8070: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:34:56\n// Signature: redis_parser_init(redis_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: redis_parser_init\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/redis_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    redis_parser_t parser;\n    redis_parser_init(&parser);\n\n    char* fuzz_data = fuzzData(0);\n    size_t fuzz_len = fuzzGetLen(0); // Change type to size_t\n\n    parser.msgbuf = fuzz_data;\n    parser.msgsize = fuzz_len;\n\n    int ret = redis_parser_append_message(fuzz_data, &fuzz_len, &parser);\n\n    redis_parser_deinit(&parser);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/redis_parser.c\n 420: int redis_parser_append_message(const void *buf, size_t *size,\n 421: \t\t\t\t\t\t\t\tredis_parser_t *parser)\n 422: {\n 423: \tsize_t msgsize_bak = parser->msgsize;\n 424: \n 425: \tif (parser->status == REDIS_PARSE_END)\n 426: \t{\n 427: \t\t*size = 0;\n 428: \t\treturn 1;\n 429: \t}\n 430: \n 431: \tif (parser->msgsize + *size > parser->bufsize)\n 432: \t{\n 433: \t\tsize_t new_size = MAX(REDIS_MSGBUF_INIT_SIZE, 2 * parser->bufsize);\n 434: \t\tvoid *new_base;\n 435: \n 436: \t\twhile (new_size < parser->msgsize + *size)\n 437: \t\t\tnew_size *= 2;\n 438: \n 439: \t\tnew_base = realloc(parser->msgbuf, new_size);\n 440: \t\tif (!new_base)\n 441: \t\t\treturn -1;\n 442: \n 443: \t\tparser->msgbuf = (char *)new_base;\n 444: \t\tparser->bufsize = new_size;\n 445: \t}\n 446: \n 447: \tmemcpy(parser->msgbuf + parser->msgsize, buf, *size);\n 448: \tparser->msgsize += *size;\n 449: \tif (parser->msgsize > 0 && (isalpha(*parser->msgbuf) ||\n 450: \t\t\t\t\t\t\t\tisspace(*parser->msgbuf)))\n 451: \t{\n 452: \t\twhile (parser->msgidx < parser->msgsize &&\n 453: \t\t\t*(parser->msgbuf + parser->msgidx) != '\\n')\n 454: \t\t{\n 455: \t\t\tparser->msgidx++;\n 456: \t\t}\n 457: \n 458: \t\tif (parser->msgidx == parser->msgsize)\n 459: \t\t\treturn 0;\n 460: \n 461: \t\tparser->msgidx++;\n 462: \t\tparser->msgsize = parser->msgidx;\n 463: \t\t*size = parser->msgsize - msgsize_bak;\n 464: \n 465: \t\treturn __redis_split_inline_command(parser);\n 466: \t}\n 467: \n 468: \tdo\n 469: \t{\n 470: \t\tint ret = __redis_parser_forward(parser);\n 471: \n 472: \t\tif (ret < 0)\n 473: \t\t\treturn ret;\n 474: \n 475: \t\tif (ret == 1)\n 476: \t\t{\n 477: \t\t\tstruct list_head *lnext = parser->read_list.next;\n 478: \t\t\tstruct __redis_read_record *next;\n 479: \n 480: \t\t\tparser->nleft--;\n 481: \t\t\tif (lnext && lnext != &parser->read_list)\n 482: \t\t\t{\n 483: \t\t\t\tnext = list_entry(lnext, struct __redis_read_record, list);\n 484: \t\t\t\tparser->cur = next->reply;\n 485: \t\t\t\tlist_del(lnext);\n 486: \t\t\t\tfree(next);\n 487: \t\t\t}\n 488: \n 489: \t\t\tif (parser->nleft > 0)\n 490: \t\t\t\tparser->status = REDIS_GET_CMD;\n 491: \t\t\telse\n 492: \t\t\t{\n 493: \t\t\t\tparser->parse_succ = 1;\n 494: \t\t\t\tparser->status = REDIS_PARSE_END;\n 495: \t\t\t}\n 496: \t\t}\n 497: \t\telse if (ret == 2)\n 498: \t\t\treturn 0;\n 499: \n 500: \t} while (parser->status != REDIS_PARSE_END);\n 501: \n 502: \t*size = parser->msgidx - msgsize_bak;\n 503: \treturn __redis_parse_done(&parser->reply, parser->msgbuf, 0);\n 504: }\n 505:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==196==ERROR: AddressSanitizer: heap-use-after-free on address 0x60200000c6f3 at pc 0x55895b0d934f bp 0x7ffd80fcb880 sp 0x7ffd80fcb870\nWRITE of size 1 at 0x60200000c6f3 thread T0\n    #0 0x55895b0d934e in hex2byte /sourcecode/lib/facil/http/http.c:2383\n    #1 0x55895b0d9ed0 in http_decode_url_unsafe /sourcecode/lib/facil/http/http.c:2426\n    #2 0x55895afc780a in fuzzloop /sharedockerin/ta1730101611048ltan/test_file.c:29\n    #3 0x55895b146249 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55895afc6ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f00f5f46d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f00f5f46e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55895afc6c04 in _start (/sharedockerin/ta1730101611048ltan/clouditera+0x1dbc04)\n\n0x60200000c6f3 is located 3 bytes inside of 8-byte region [0x60200000c6f0,0x60200000c6f8)\nfreed by thread T0 here:\n    #0 0x7f00f691f887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x7f00f60166ff  (/lib/x86_64-linux-gnu/libc.so.6+0xf96ff)\n    #2 0x60200000ca8f  (<unknown module>)\n\npreviously allocated by thread T0 here:\n    #0 0x7f00f691fc38 in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:164\n    #1 0x7f00f6012e73  (/lib/x86_64-linux-gnu/libc.so.6+0xf5e73)\n\nSUMMARY: AddressSanitizer: heap-use-after-free /sourcecode/lib/facil/http/http.c:2383 in hex2byte\nShadow bytes around the buggy address:\n  0x0c047fff9880: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff9890: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff98a0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff98b0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff98c0: fa fa fd fd fa fa fd fd fa fa fd fd fa fa 00 04\n=>0x0c047fff98d0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[fd]fa\n  0x0c047fff98e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff98f0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff9900: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff9910: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff9920: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: http_decode_url_unsafe(char *dest, char *url_data)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_url_unsafe\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <http1.h> //extract\n#include <http_internal.h> //extract\n#include <ctype.h> //extract\n#include <fcntl.h> //extract\n#include <signal.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include \"lib/facil/http/http.h\" //autogen\n\nint fuzzloop() {\n    char * dest = fuzzString(0);\n    char * url_data = fuzzString(1);\n    ssize_t ret = http_decode_url_unsafe(dest, url_data);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2375: static inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n2376:   if (source[0] >= '0' && source[0] <= '9')\n2377:     *dest = (source[0] - '0');\n2378:   else if ((source[0] >= 'a' && source[0] <= 'f') ||\n2379:            (source[0] >= 'A' && source[0] <= 'F'))\n2380:     *dest = (source[0] | 32) - 87;\n2381:   else\n2382:     return -1;\n2383:   *dest <<= 4;\n2384:   if (source[1] >= '0' && source[1] <= '9')\n2385:     *dest |= (source[1] - '0');\n2386:   else if ((source[1] >= 'a' && source[1] <= 'f') ||\n2387:            (source[1] >= 'A' && source[1] <= 'F'))\n2388:     *dest |= (source[1] | 32) - 87;\n2389:   else\n2390:     return -1;\n2391:   return 0;\n2392: }\n2393: \nStacktrace #1:\nFile: /sourcecode/lib/facil/http/http.c\n2416: ssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n2417:   char *pos = dest;\n2418:   while (*url_data) {\n2419:     if (*url_data == '+') {\n2420:       // decode space\n2421:       *(pos++) = ' ';\n2422:       ++url_data;\n2423:     } else if (*url_data == '%') {\n2424:       // decode hex value\n2425:       // this is a percent encoded value.\n2426:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2427:         return -1;\n2428:       pos++;\n2429:       url_data += 3;\n2430:     } else\n2431:       *(pos++) = *(url_data++);\n2432:   }\n2433:   *pos = 0;\n2434:   return pos - dest;\n2435: }\n2436:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==136==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000110 at pc 0x7fd10b45b397 bp 0x7ffd08600630 sp 0x7ffd085ffdd8\nREAD of size 11 at 0x602000000110 thread T0\n    #0 0x7fd10b45b396 in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x5579456bdd41 in AddHookBlob /home/clouditera/workdir-engine_c/betafuzz/structure/addHook.c:87\n    #2 0x7fd10b4b5301 in MemcmpInterceptorCommon(void*, int (*)(void const*, void const*, unsigned long), void const*, void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:882\n    #3 0x7fd10b4b5bc6 in __interceptor_memcmp ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:892\n    #4 0x7fd10b4b5bc6 in __interceptor_memcmp ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:887\n    #5 0x5579455a9cf5 in fio_cli_hash__find_map_pos_ /sourcecode/lib/facil/fio.h:5907\n    #6 0x5579455ab7dc in fio_cli_hash__insert_or_overwrite_ /sourcecode/lib/facil/fio.h:6005\n    #7 0x5579455ad6c1 in fio_cli_hash_insert /sourcecode/lib/facil/fio.h:6110\n    #8 0x5579455b2b40 in fio_cli_set /sourcecode/lib/facil/cli/fio_cli.c:430\n    #9 0x5579455a428e in fuzzloop /sharedockerin/ta1730101611651wvzs/test_file.c:25\n    #10 0x557945662749 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x5579455a39f8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7fd10aafcd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7fd10aafce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x5579455a3b44 in _start (/sharedockerin/ta1730101611651wvzs/clouditera+0xd8b44)\n\n0x602000000110 is located 0 bytes inside of 12-byte region [0x602000000110,0x60200000011c)\nfreed by thread T0 here:\n    #0 0x7fd10b4d5537 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127\n    #1 0x55794566298c in BetaWfree /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:97\n\npreviously allocated by thread T0 here:\n    #0 0x7fd10b4d5887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55794566295c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: heap-use-after-free ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\nShadow bytes around the buggy address:\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x0c047fff8000: fa fa fd fd fa fa 04 fa fa fa 05 fa fa fa 00 02\n  0x0c047fff8010: fa fa 06 fa fa fa 06 fa fa fa 00 03 fa fa fd fd\n=>0x0c047fff8020: fa fa[fd]fd fa fa fd fd fa fa fd fd fa fa 00 04\n  0x0c047fff8030: fa fa 00 04 fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 04\n  0x0c047fff8070: fa fa fd fd fa fa 00 04 fa fa fd fd fa fa 00 04\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: fio_cli_set(char *name, char *value)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_cli_set\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio.h> //extract\n#include <fio_cli.h> //extract\n#include <stdint.h> //extract\n#include <stdio.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <strings.h> //extract\n\nint fuzzloop() {\n    char * name = fuzzString(0);\n    char * value = fuzzString(1);\n    fio_cli_set(name, value);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.h\n5880: FIO_FUNC inline FIO_NAME(_map_s_) *\n5881:     FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n5882:                              FIO_SET_TYPE obj) {\n5883:   if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n5884:     hash_value = FIO_SET_HASH_FORCE;\n5885:   if (set->map) {\n5886:     /* make sure collisions don't effect seeking */\n5887:     if (set->has_collisions && set->pos != set->count) {\n5888:       FIO_NAME(rehash)(set);\n5889:     }\n5890:     size_t full_collisions_counter = 0;\n5891:     FIO_NAME(_map_s_) * pos;\n5892:     /*\n5893:      * Commonly, the hash is rotated, depending on it's state.\n5894:      * Different bits are used for each mapping, instead of a single new bit.\n5895:      */\n5896:     const uintptr_t mask = (1ULL << set->used_bits) - 1;\n5897: \n5898:     uintptr_t i;\n5899:     const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n5900:     uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n5901: \n5902:     /* O(1) access to object */\n5903:     pos = set->map + (hash_alt & mask);\n5904:     if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n5905:       return pos;\n5906:     if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n5907:       if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))\n5908:         return pos;\n5909:       /* full hash value collision detected */\n5910:       set->has_collisions = 1;\n5911:       ++full_collisions_counter;\n5912:     }\n5913: \n5914:     /* Handle partial / full collisions with cuckoo steps O(x) access time */\n5915:     i = 0;\n5916:     const uintptr_t limit =\n5917:         FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n5918:                                     ? FIO_SET_MAX_MAP_SEEK\n5919:                                     : (set->capa >> 2));\n5920:     while (i < limit) {\n5921:       i += FIO_SET_CUCKOO_STEPS;\n5922:       pos = set->map + ((hash_alt + i) & mask);\n5923:       if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n5924:         return pos;\n5925:       if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n5926:         if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))\n5927:           return pos;\n5928:         /* full hash value collision detected */\n5929:         set->has_collisions = 1;\n5930:         if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n5931:           /* is the hash under attack? */\n5932:           FIO_LOG_WARNING(\n5933:               \"(fio hash map) too many full collisions - under attack?\");\n5934:           set->under_attack = 1;\n5935:         }\n5936:         if (set->under_attack) {\n5937:           return pos;\n5938:         }\n5939:       }\n5940:     }\n5941:   }\n5942:   return NULL;\n5943:   (void)obj; /* in cases where FIO_SET_OBJ_COMPARE does nothing */\n5944: }\n5945: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.h\n5988: FIO_FUNC inline FIO_SET_TYPE\n5989: FIO_NAME(_insert_or_overwrite_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n5990:                                 FIO_SET_TYPE obj, int overwrite,\n5991:                                 FIO_SET_OBJ_TYPE *old) {\n5992:   if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n5993:     hash_value = FIO_SET_HASH_FORCE;\n5994: \n5995:   /* automatic fragmentation protection */\n5996:   if (FIO_NAME(is_fragmented)(set))\n5997:     FIO_NAME(rehash)(set);\n5998:   /* automatic capacity validation (we can never be at 100% capacity) */\n5999:   else if (set->pos >= set->capa) {\n6000:     ++set->used_bits;\n6001:     FIO_NAME(rehash)(set);\n6002:   }\n6003: \n6004:   /* locate future position */\n6005:   FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n6006: \n6007:   if (!pos) {\n6008:     /* inserting a new object, with too many holes in the map */\n6009:     FIO_SET_COPY(set->ordered[set->pos].obj, obj);\n6010:     set->ordered[set->pos].hash = hash_value;\n6011:     ++set->pos;\n6012:     ++set->count;\n6013:     FIO_NAME(rehash)(set);\n6014:     return set->ordered[set->pos - 1].obj;\n6015:   }\n6016: \n6017:   /* overwriting / new */\n6018:   if (pos->pos) {\n6019:     /* overwrite existing object */\n6020:     if (!overwrite) {\n6021:       FIO_SET_DESTROY(obj);\n6022:       return pos->pos->obj;\n6023:     }\n6024: #ifdef FIO_SET_KEY_TYPE\n6025:     if (old) {\n6026:       FIO_SET_OBJ_COPY((*old), pos->pos->obj.obj);\n6027:     }\n6028:     /* no need to recreate the key object, just the value object */\n6029:     FIO_SET_OBJ_DESTROY(pos->pos->obj.obj);\n6030:     FIO_SET_OBJ_COPY(pos->pos->obj.obj, obj.obj);\n6031:     return pos->pos->obj;\n6032: #else\n6033:     if (old) {\n6034:       FIO_SET_COPY((*old), pos->pos->obj);\n6035:     }\n6036:     FIO_SET_DESTROY(pos->pos->obj);\n6037: #endif\n6038:   } else {\n6039:     /* insert into new slot */\n6040:     pos->pos = set->ordered + set->pos;\n6041:     ++set->pos;\n6042:     ++set->count;\n6043:   }\n6044:   /* store object at position */\n6045:   pos->hash = hash_value;\n6046:   pos->pos->hash = hash_value;\n6047:   FIO_SET_COPY(pos->pos->obj, obj);\n6048: \n6049:   return pos->pos->obj;\n6050: }\n6051: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.h\n6106: FIO_FUNC void FIO_NAME(insert)(FIO_NAME(s) * set,\n6107:                                const FIO_SET_HASH_TYPE hash_value,\n6108:                                FIO_SET_KEY_TYPE key, FIO_SET_OBJ_TYPE obj,\n6109:                                FIO_SET_OBJ_TYPE *old) {\n6110:   FIO_NAME(_insert_or_overwrite_)\n6111:   (set, hash_value, (FIO_SET_TYPE){.key = key, .obj = obj}, 1, old);\n6112: }\n6113: \nStacktrace #3:\nFile: /sourcecode/lib/facil/cli/fio_cli.c\n 428: void fio_cli_set(char const *name, char const *value) {\n 429:   cstr_s n = (cstr_s){.data = name, .len = strlen(name)};\n 430:   fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n 431: }\n 432:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==711==ERROR: AddressSanitizer: invalid alignment requested in posix_memalign: 1844674407370, alignment must be a power of two and a multiple of sizeof(void*) == 8 (thread T0)\n    #0 0x7f18c540457c in __interceptor_posix_memalign ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:226\n    #1 0x5616102f990b in __portable_aligned_alloc /sourcecode/include/flatcc/portable/paligned_alloc.h:145\n    #2 0x5616103195d3 in flatcc_builder_aligned_alloc /sourcecode/src/runtime/builder.c:2029\n    #3 0x5616102f9789 in fuzzloop /dockerin/fuzz_drivers/tf1727601035333qzkb.c:21\n    #4 0x5616103294d9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==711==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: invalid-posix-memalign-alignment ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:226 in __interceptor_posix_memalign\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/test/json_test/generated -Iinclude -Isrc/runtime -DFLATCC_REFLECTION=1 -DPORTABLE_POSIX_MEMALIGN=1 -DFLATCC_JSON_PARSE_WIDE_SPACE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: flatcc_builder_aligned_alloc\n// Sign: flatcc_builder_aligned_alloc(size_t alignment, size_t size)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include \"flatcc/flatcc_builder.h\" //extract\n#include \"flatcc/flatcc_emitter.h\" //extract\n\nint fuzzloop() {\n    size_t alignment = (size_t)fuzzUint64(0);\n    size_t size = (size_t)fuzzUint64(1);\n    void * ret = flatcc_builder_aligned_alloc(alignment, size);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/flatcc/portable/paligned_alloc.h\n 137: static inline void *__portable_aligned_alloc(size_t alignment, size_t size)\n 138: {\n 139:     int err;\n 140:     void *p = 0;\n 141: \n 142:     if (alignment < sizeof(void *)) {\n 143:         alignment = sizeof(void *);\n 144:     }\n 145:     err = posix_memalign(&p, alignment, size);\n 146:     if (err && p) {\n 147:         free(p);\n 148:         p = 0;\n 149:     }\n 150:     return p;\n 151: }\n 152: \nStacktrace #1:\nFile: /sourcecode/src/runtime/builder.c\n2027: void *flatcc_builder_aligned_alloc(size_t alignment, size_t size)\n2028: {\n2029:     return FLATCC_BUILDER_ALIGNED_ALLOC(alignment, size);\n2030: }\n2031:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f4871c8cf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5603964d3644 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7f4871c92e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7f4871bf860b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7f4871bf443c in __asan::asan_memalign(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:1039\n    #5 0x7f4871c821a3 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #6 0x7f4871ae3724 in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reserve(unsigned long) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x14c724)\n    #7 0x5603964c4010 in YAML::Stream::get[abi:cxx11](int) /sourcecode/src/stream.cpp:278\n    #8 0x5603964c1dbf in fuzzloop /dockerin/fuzz_drivers/tf1729580069771alte.cpp:25\n    #9 0x5603964d22b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x5603964c1928 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7f4871690d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7f4871690e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x5603964c1a74 in _start (/dockerin/fuzz_drivers/tf1729580069771alte.out+0x13a74)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::Stream::get(int n)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML6Stream3getB5cxx11Ei\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <iostream> //extract\n#include \"stream.h\" //extract\n#include <sstream>\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream input(temp);\n    auto stream = std::make_unique<YAML::Stream>(input);\n    int n = fuzzInt32(1);\n    stream->get(n);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stream.cpp\n 275: std::string Stream::get(int n) {\n 276:   std::string ret;\n 277:   if (n > 0) {\n 278:     ret.reserve(static_cast<std::string::size_type>(n));\n 279:     for (int i = 0; i < n; i++)\n 280:       ret += get();\n 281:   }\n 282:   return ret;\n 283: }\n 284:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f6a80b8df18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x562ea75f9d24 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7f6a80b93e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7f6a80af960b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7f6a80af519a in __asan::asan_malloc(unsigned long, __sanitizer::BufferedStackTrace*) ../../../../src/libsanitizer/asan/asan_allocator.cpp:980\n    #5 0x7f6a80b81861 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:146\n    #6 0x562ea75a1c5b in CommTarget::init(sockaddr const*, unsigned int, int, int) /sourcecode/src/kernel/Communicator.cc:157\n    #7 0x562ea759e145 in fuzzloop /dockerin/fuzz_drivers/tf1729593105303qyfz.cpp:52\n    #8 0x562ea75f8999 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #9 0x562ea759db98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #10 0x7f6a7ff5ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #11 0x7f6a7ff5ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #12 0x562ea759dce4 in _start (/dockerin/fuzz_drivers/tf1729593105303qyfz.out+0x88ce4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:31:28\n// Signature: CommTarget::init(struct sockaddr *addr, socklen_t addrlen, int connect_timeout, int response_timeout)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN10CommTarget4initEPK8sockaddrjii\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I_include/workflow -I. -Isrc/kernel -DNDEBUG\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sys/types.h> //extract\n#include <sys/socket.h> //extract\n#include <sys/uio.h> //extract\n#include <errno.h> //extract\n#include <limits.h> //extract\n#include <time.h> //extract\n#include <fcntl.h> //extract\n#include <unistd.h> //extract\n#include <stddef.h> //extract\n#include <stdlib.h> //extract\n#include <string.h> //extract\n#include <pthread.h> //extract\n#include <openssl/ssl.h> //extract\n#include <openssl/bio.h> //extract\n#include \"list.h\" //extract\n#include \"msgqueue.h\" //extract\n#include \"thrdpool.h\" //extract\n#include \"poller.h\" //extract\n#include \"mpoller.h\" //extract\n#include \"Communicator.h\" //extract\n#include <memory> //autogen\n#include \"/usr/include/x86_64-linux-gnu/bits/socket.h\" //autogen\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    auto commtarget = std::make_unique<CommTarget>();\n    //file: /usr/include/x86_64-linux-gnu/bits/socket.h:180\n    //struct sockaddr\n    //  {\n    //    __SOCKADDR_COMMON (sa_);\t/* Common data: address family and length.  */\n    //    char sa_data[14];\t\t/* Address data.  */\n    //  };\n    sockaddr *addr = (sockaddr *)driverAllocMem(sizeof(sockaddr));\n    char *temp = fuzzFixBlob(0, sizeof(sockaddr));\n    memcpy(addr, temp, sizeof(addr));\n    unsigned int addrlen = fuzzUint32(1);\n    int connect_timeout = fuzzInt32(2);\n    int response_timeout = fuzzInt32(3);\n    commtarget->init(addr, addrlen, connect_timeout, response_timeout);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n 152: int CommTarget::init(const struct sockaddr *addr, socklen_t addrlen,\n 153: \t\t\t\t\t int connect_timeout, int response_timeout)\n 154: {\n 155: \tint ret;\n 156: \n 157: \tthis->addr = (struct sockaddr *)malloc(addrlen);\n 158: \tif (this->addr)\n 159: \t{\n 160: \t\tret = pthread_mutex_init(&this->mutex, NULL);\n 161: \t\tif (ret == 0)\n 162: \t\t{\n 163: \t\t\tmemcpy(this->addr, addr, addrlen);\n 164: \t\t\tthis->addrlen = addrlen;\n 165: \t\t\tthis->connect_timeout = connect_timeout;\n 166: \t\t\tthis->response_timeout = response_timeout;\n 167: \t\t\tINIT_LIST_HEAD(&this->idle_list);\n 168: \n 169: \t\t\tthis->ssl_ctx = NULL;\n 170: \t\t\tthis->ssl_connect_timeout = 0;\n 171: \t\t\treturn 0;\n 172: \t\t}\n 173: \n 174: \t\terrno = ret;\n 175: \t\tfree(this->addr);\n 176: \t}\n 177: \n 178: \treturn -1;\n 179: }\n 180:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f681b75cf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x555fb1835c44 in leak_malloc_hook /home/clouditera/workdir-engine_c/betafuzz/checkers/leakcheck.c:80\n    #2 0x7f681b762e02 in __sanitizer::RunMallocHooks(void const*, unsigned long) ../../../../src/libsanitizer/sanitizer_common/sanitizer_common.cpp:301\n    #3 0x7f681b6c860b in __asan::Allocator::Allocate(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType, bool) ../../../../src/libsanitizer/asan/asan_allocator.cpp:611\n    #4 0x7f681b6c443c in __asan::asan_memalign(unsigned long, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType) ../../../../src/libsanitizer/asan/asan_allocator.cpp:1039\n    #5 0x7f681b7521a3 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #6 0x7f681b5b3724 in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reserve(unsigned long) (/lib/x86_64-linux-gnu/libstdc++.so.6+0x14c724)\n    #7 0x555fb182b905 in protocol::TLVMessage::append(void const*, unsigned long*) /sourcecode/src/protocol/TLVMessage.cc:71\n    #8 0x555fb17d60b9 in fuzzloop /dockerin/fuzz_drivers/tf1729655956046jdki.cpp:18\n    #9 0x555fb18348b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x555fb17d5cb8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7f681ab29d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7f681ab29e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x555fb17d5e04 in _start (/dockerin/fuzz_drivers/tf1729655956046jdki.out+0x91e04)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:58:49\n// Signature: protocol::TLVMessage::append(void *buf, size_t *size)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol10TLVMessage6appendEPKvPm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/TLVMessage.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    protocol::TLVMessage msg;\n    char* buf = fuzzData(0);\n    size_t size = fuzzGetLen(0);\n    msg.append(buf, &size);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/TLVMessage.cc\n  41: int TLVMessage::append(const void *buf, size_t *size)\n  42: {\n  43: \tsize_t n = *size;\n  44: \tsize_t head_left;\n  45: \n  46: \thead_left = 8 - this->head_received;\n  47: \tif (head_left > 0)\n  48: \t{\n  49: \t\tvoid *p = (char *)this->head + this->head_received;\n  50: \n  51: \t\tif (n < head_left)\n  52: \t\t{\n  53: \t\t\tmemcpy(p, buf, n);\n  54: \t\t\tthis->head_received += n;\n  55: \t\t\treturn 0;\n  56: \t\t}\n  57: \n  58: \t\tmemcpy(p, buf, head_left);\n  59: \t\tthis->head_received = 8;\n  60: \t\tbuf = (const char *)buf + head_left;\n  61: \t\tn -= head_left;\n  62: \n  63: \t\tthis->type = (int)ntohl(this->head[0]);\n  64: \t\t*this->head = ntohl(this->head[1]);\n  65: \t\tif (*this->head > this->size_limit)\n  66: \t\t{\n  67: \t\t\terrno = EMSGSIZE;\n  68: \t\t\treturn -1;\n  69: \t\t}\n  70: \n  71: \t\tthis->value.reserve(*this->head);\n  72: \t}\n  73: \n  74: \tif (this->value.size() + n > *this->head)\n  75: \t{\n  76: \t\tn = *this->head - this->value.size();\n  77: \t\t*size = n + head_left;\n  78: \t}\n  79: \n  80: \tthis->value.append((const char *)buf, (const char *)buf + n);\n  81: \treturn this->value.size() == *this->head;\n  82: }\n  83:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==9497==ERROR: AddressSanitizer: memcpy-param-overlap: memory ranges [0x602000000110,0x61cd7f29acda) and [0x602000000150, 0x61cd7f29ad1a) overlap\n    #0 0x7fc1a5c711ed in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x556441c5634d in lzo_memcpy /sourcecode/lzo/minilzo.c:4366\n    #2 0x556441c555fb in fuzzloop /dockerin/fuzz_drivers/tf1728878215798zrlh.c:27\n    #3 0x556441c67919 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x556441c55398 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fc1a5312d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fc1a5312e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x556441c554e4 in _start (/dockerin/fuzz_drivers/tf1728878215798zrlh.out+0x1b4e4)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7fc1a5ceb887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556441c67b2c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7fc1a5ceb887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556441c67b2c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: memcpy-param-overlap ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Isrc -Ilzo -I/usr/include/python3.10 -DNDEBUG -DMINILZO_HAVE_CONFIG_H -DHAVE_CONFIG_H -D_GNU_SOURCE -DLIBDIR=/usr/local/lib -DSYSCONFDIR=/usr/local/etc -DICONDIR=/usr/local/share/pixmaps -D_GNU_SOURCE=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: lzo_memcpy\n// Sign: lzo_memcpy(void *dest, void *src, lzo_uint len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#  include <config.h> //extract\n#include <limits.h> //extract\n#include <stddef.h> //extract\n#include \"minilzo.h\" //extract\n#include <string.h> //extract\n#  include <assert.h> //extract\n#include \"lzo/lzoconf.h\" //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * dest = (void *)fuzzData(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * src = (void *)fuzzData(1);\n    unsigned long len = (unsigned long)fuzzUint64(2);\n    void * ret = lzo_memcpy(dest, src, len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lzo/minilzo.c\n4354: LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)\n4355: {\n4356: #if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCPY)\n4357:     lzo_hbyte_p p1 = LZO_STATIC_CAST(lzo_hbyte_p, dest);\n4358:     const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, src);\n4359:     if (!(len > 0) || p1 == p2)\n4360:         return dest;\n4361:     do\n4362:         *p1++ = *p2++;\n4363:     while __lzo_likely(--len > 0);\n4364:     return dest;\n4365: #else\n4366:     return memcpy(dest, src, len);\n4367: #endif\n4368: }\n4369:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==61672==ERROR: AddressSanitizer: memcpy-param-overlap: memory ranges [0x602000000110,0x61cd7f29acda) and [0x602000000150, 0x61cd7f29ad1a) overlap\n    #0 0x7f446f1ca1ed in __interceptor_memcpy ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827\n    #1 0x55810d53e285 in SDL_memcpy_REAL /sourcecode/src/stdlib/SDL_stdlib.c:527\n    #2 0x55810d53cb10 in fuzzloop /dockerin/fuzz_drivers/tf1728900807102zeyh.c:24\n    #3 0x55810d546a39 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x55810d53c8a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f446ef90d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f446ef90e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x55810d53c9f4 in _start (/dockerin/fuzz_drivers/tf1728900807102zeyh.out+0xf9f4)\n\n0x60200000011c is located 0 bytes to the right of 12-byte region [0x602000000110,0x60200000011c)\nallocated by thread T0 here:\n    #0 0x7f446f244887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55810d546c4c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\n0x60200000015c is located 0 bytes to the right of 12-byte region [0x602000000150,0x60200000015c)\nallocated by thread T0 here:\n    #0 0x7f446f244887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55810d546c4c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: memcpy-param-overlap ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:827 in __interceptor_memcpy\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/stdlib -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_stdinc.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_stdinc.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_memcpy_REAL\n// Sign: SDL_memcpy_REAL(void *dst, void *src, size_t len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"build/include/SDL2/SDL_stdinc.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * dst = (void *)fuzzData(0);\n    //Warn: fuzzData实际类型为unsigned char*, 可能与void*类型不兼容\n    void * src = (void *)fuzzData(1);\n    size_t len = (size_t)fuzzUint64(2);\n    void * ret = SDL_memcpy_REAL(dst, src, len);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_stdlib.c\n 521: void *SDL_memcpy(SDL_OUT_BYTECAP(len) void *dst, SDL_IN_BYTECAP(len) const void *src, size_t len)\n 522: {\n 523: #ifdef __GNUC__\n 524:     /* Presumably this is well tuned for speed.\n 525:        On my machine this is twice as fast as the C code below.\n 526:      */\n 527:     return __builtin_memcpy(dst, src, len);\n 528: #elif defined(HAVE_MEMCPY)\n 529:     return memcpy(dst, src, len);\n 530: #elif defined(HAVE_BCOPY)\n 531:     bcopy(src, dst, len);\n 532:     return dst;\n 533: #else\n 534:     /* GCC 4.9.0 with -O3 will generate movaps instructions with the loop\n 535:        using Uint32* pointers, so we need to make sure the pointers are\n 536:        aligned before we loop using them.\n 537:      */\n 538:     if (((uintptr_t)src & 0x3) || ((uintptr_t)dst & 0x3)) {\n 539:         /* Do an unaligned byte copy */\n 540:         Uint8 *srcp1 = (Uint8 *)src;\n 541:         Uint8 *dstp1 = (Uint8 *)dst;\n 542: \n 543:         while (len--) {\n 544:             *dstp1++ = *srcp1++;\n 545:         }\n 546:     } else {\n 547:         size_t left = (len % 4);\n 548:         Uint32 *srcp4, *dstp4;\n 549:         Uint8 *srcp1, *dstp1;\n 550: \n 551:         srcp4 = (Uint32 *)src;\n 552:         dstp4 = (Uint32 *)dst;\n 553:         len /= 4;\n 554:         while (len--) {\n 555:             *dstp4++ = *srcp4++;\n 556:         }\n 557: \n 558:         srcp1 = (Uint8 *)srcp4;\n 559:         dstp1 = (Uint8 *)dstp4;\n 560:         switch (left) {\n 561:         case 3:\n 562:             *dstp1++ = *srcp1++;\n 563:         case 2:\n 564:             *dstp1++ = *srcp1++;\n 565:         case 1:\n 566:             *dstp1++ = *srcp1++;\n 567:         }\n 568:     }\n 569:     return dst;\n 570: #endif /* __GNUC__ */\n 571: }\n 572:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==26852==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x7fffffff8 bytes\n    #0 0x7f381745b1e7 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99\n    #1 0x55f20df41187 in __gnu_cxx::new_allocator<void*>::allocate(unsigned long, void const*) /usr/include/c++/11/ext/new_allocator.h:127\n    #2 0x55f20df402bd in std::allocator_traits<std::allocator<void*> >::allocate(std::allocator<void*>&, unsigned long) /usr/include/c++/11/bits/alloc_traits.h:464\n    #3 0x55f20df3fd2a in std::_Vector_base<void*, std::allocator<void*> >::_M_allocate(unsigned long) /usr/include/c++/11/bits/stl_vector.h:346\n    #4 0x55f20df3efe7 in std::vector<void*, std::allocator<void*> >::_M_default_append(unsigned long) /usr/include/c++/11/bits/vector.tcc:635\n    #5 0x55f20df3e596 in std::vector<void*, std::allocator<void*> >::resize(unsigned long) /usr/include/c++/11/bits/stl_vector.h:940\n    #6 0x55f20df3df04 in YAML::AnchorDict<void*>::Register(unsigned long, void*) /sourcecode/include/yaml-cpp/contrib/anchordict.h:28\n    #7 0x55f20df3d891 in YAML::GraphBuilderAdapter::RegisterAnchor(unsigned long, void*) /sourcecode/src/contrib/graphbuilderadapter.cpp:72\n    #8 0x55f20df3d133 in YAML::GraphBuilderAdapter::OnScalar(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/contrib/graphbuilderadapter.cpp:26\n    #9 0x55f20df39ae6 in fuzzloop /dockerin/fuzz_drivers/tf1729582198612cekd.cpp:38\n    #10 0x55f20df4acc9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==26852==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: out-of-memory ../../../../src/libsanitizer/asan/asan_new_delete.cpp:99 in operator new(unsigned long)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 07:29:00\n// Signature: YAML::GraphBuilderAdapter::GetCurrentParent()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZNK4YAML19GraphBuilderAdapter16GetCurrentParentEv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/contrib/graphbuilderadapter.h\"\n#include \"yaml-cpp/contrib/graphbuilder.h\"\n#include \"yaml-cpp/anchor.h\" // Include to define anchor_t\n\n// Dummy implementation of GraphBuilderInterface for testing purposes\nclass DummyGraphBuilder : public YAML::GraphBuilderInterface {\npublic:\n    virtual ~DummyGraphBuilder() {}\n    virtual void *NewNull(const YAML::Mark &mark, void *pParentNode) { return nullptr; }\n    virtual void *NewScalar(const YAML::Mark &mark, const std::string &tag, void *pParentNode, const std::string &value) { return nullptr; }\n    virtual void *NewSequence(const YAML::Mark &mark, const std::string &tag, void *pParentNode) { return nullptr; }\n    virtual void AppendToSequence(void *pSequence, void *pNode) {}\n    virtual void *NewMap(const YAML::Mark &mark, const std::string &tag, void *pParentNode) { return nullptr; }\n    virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) {}\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    DummyGraphBuilder builder; // Use a concrete implementation\n    YAML::GraphBuilderAdapter adapter(builder);\n    YAML::Mark mark;\n\n    adapter.OnDocumentStart(mark);\n\n    char* tag = fuzzString(0);\n    YAML::anchor_t anchor = fuzzUint32(1); // Use YAML::anchor_t\n    char* value = fuzzString(2);\n    adapter.OnScalar(mark, tag, anchor, value);\n\n    adapter.OnDocumentEnd();\n\n    adapter.GetCurrentParent();\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/yaml-cpp/contrib/anchordict.h\n  18:  *\n  19:  * <p>Efficient implementation that can make assumptions about how\n  20:  * {@code anchor_t} values are assigned by the {@link Parser} class.\n  21:  */\n  22: template <class T>\n  23: class AnchorDict {\n  24:  public:\n  25:   AnchorDict() : m_data{} {}\n  26:   void Register(anchor_t anchor, T value) {\n  27:     if (anchor > m_data.size()) {\n  28:       m_data.resize(anchor);\n  29:     }\n  30:     m_data[anchor - 1] = value;\n  31:   }\n  32: \n  33:   T Get(anchor_t anchor) const { return m_data[anchor - 1]; }\n  34: \n  35:  private:\n  36:   std::vector<T> m_data;\n  37: };\n  38: }  // namespace YAML\n  39: \nStacktrace #1:\nFile: /sourcecode/src/contrib/graphbuilderadapter.cpp\n  70: void GraphBuilderAdapter::RegisterAnchor(anchor_t anchor, void *pNode) {\n  71:   if (anchor) {\n  72:     m_anchors.Register(anchor, pNode);\n  73:   }\n  74: }\n  75: \nStacktrace #2:\nFile: /sourcecode/src/contrib/graphbuilderadapter.cpp\n  22: void GraphBuilderAdapter::OnScalar(const Mark &mark, const std::string &tag,\n  23:                                    anchor_t anchor, const std::string &value) {\n  24:   void *pParent = GetCurrentParent();\n  25:   void *pNode = m_builder.NewScalar(mark, tag, pParent, value);\n  26:   RegisterAnchor(anchor, pNode);\n  27: \n  28:   DispositionNode(pNode);\n  29: }\n  30:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==151887==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x7fffffff8 bytes\n    #0 0x7f80d6b81887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x562070ae4c82 in __redis_create_array /sourcecode/src/protocol/redis_parser.c:66\n    #2 0x562070ae4fe5 in redis_reply_set_array /sourcecode/src/protocol/redis_parser.c:99\n    #3 0x562070ae3a1f in fuzzloop /dockerin/fuzz_drivers/tf1729594848501evph.cpp:20\n    #4 0x562070af3aa9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==151887==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: out-of-memory ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:59:36\n// Signature: redis_reply_set_array(size_t size, redis_reply_t *reply)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: redis_reply_set_array\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/redis_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    redis_reply_t reply;\n    redis_reply_init(&reply);\n\n    size_t size = fuzzUint32(0);\n    redis_reply_set_array(size, &reply);\n\n    redis_reply_deinit(&reply);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/redis_parser.c\n  63: static redis_reply_t **__redis_create_array(size_t size, redis_reply_t *reply)\n  64: {\n  65: \tsize_t elements = 0;\n  66: \tredis_reply_t **element = (redis_reply_t **)malloc(size * sizeof (void *));\n  67: \n  68: \tif (element)\n  69: \t{\n  70: \t\tsize_t i;\n  71: \n  72: \t\tfor (i = 0; i < size; i++)\n  73: \t\t{\n  74: \t\t\telement[i] = (redis_reply_t *)malloc(sizeof (redis_reply_t));\n  75: \t\t\tif (element[i])\n  76: \t\t\t{\n  77: \t\t\t\tredis_reply_init(element[i]);\n  78: \t\t\t\telements++;\n  79: \t\t\t\tcontinue;\n  80: \t\t\t}\n  81: \n  82: \t\t\tbreak;\n  83: \t\t}\n  84: \n  85: \t\tif (elements == size)\n  86: \t\t\treturn element;\n  87: \n  88: \t\twhile (elements > 0)\n  89: \t\t\tfree(element[--elements]);\n  90: \n  91: \t\tfree(element);\n  92: \t}\n  93: \n  94: \treturn NULL;\n  95: }\n  96: \nStacktrace #1:\nFile: /sourcecode/src/protocol/redis_parser.c\n  97: int redis_reply_set_array(size_t size, redis_reply_t *reply)\n  98: {\n  99: \tredis_reply_t **element = __redis_create_array(size, reply);\n 100: \n 101: \tif (element == NULL)\n 102: \t\treturn -1;\n 103: \n 104: \tredis_reply_deinit(reply);\n 105: \treply->element = element;\n 106: \treply->elements = size;\n 107: \treply->type = REDIS_REPLY_TYPE_ARRAY;\n 108: \treturn 0;\n 109: }\n 110:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==41238==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0xbefe8500e8 bytes\n    #0 0x7f6c3b974887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56189c3c4749 in real_malloc /sourcecode/src/stdlib/SDL_malloc.c:5196\n    #2 0x56189c3c4d26 in SDL_malloc_REAL /sourcecode/src/stdlib/SDL_malloc.c:5295\n    #3 0x56189bcbecf3 in SDL_SIMDAlloc_REAL /sourcecode/src/cpuinfo/SDL_cpuinfo.c:1169\n    #4 0x56189bfbc4b6 in SDL_CreateRGBSurfaceWithFormat_REAL /sourcecode/src/video/SDL_surface.c:156\n    #5 0x56189bb6b611 in SDL_CreateRGBSurfaceWithFormat /sourcecode/src/dynapi/SDL_dynapi_procs.h:643\n    #6 0x56189bb55a44 in fuzzloop /dockerin/fuzz_drivers/tf1728900796533utkw.c:29\n    #7 0x56189c411259 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==41238==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: out-of-memory ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145 in __interceptor_malloc\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/include -Ibuild/include/SDL2 -Ibuild/include-config-/SDL2 -Ibuild/include-config- -Isrc/dynapi -DSDL_STATIC_LIB -DUSING_GENERATED_CONFIG_H -DHAVE_LINUX_VERSION_H -DMESA_EGL_NO_X11_HEADERS -DEGL_NO_X11 -D_REENTRANT -DSDL_BUILD_MAJOR_VERSION=2 -DSDL_BUILD_MINOR_VERSION=30 -DSDL_BUILD_MICRO_VERSION=8\n// 编译前执行PREPROCESS命令实现在头文件build/include/SDL2/SDL_surface.h中添加#pragma once以避免重复导入\n// PREPROCESS=header=build/include/SDL2/SDL_surface.h; if [[ $(head -n 1 $header) != \"#pragma once\" ]];then sed -i '1i#pragma once' $header; fi\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: SDL_CreateRGBSurfaceWithFormat\n// Sign: SDL_CreateRGBSurfaceWithFormat(Uint32 a, int b, int c, int d, Uint32 e)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"SDL_config.h\" //extract\n#include \"SDL_dynapi.h\" //extract\n#include \"SDL.h\" //extract\n#include \"SDL_syswm.h\" //extract\n#include \"SDL_vulkan.h\" //extract\n#include \"build/include/SDL2/SDL_surface.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned int a = fuzzUint32(0);\n    int b = fuzzInt32(1);\n    int c = fuzzInt32(2);\n    int d = fuzzInt32(3);\n    unsigned int e = fuzzUint32(4);\n    SDL_Surface * ret = SDL_CreateRGBSurfaceWithFormat(a, b, c, d, e);\n    if (ret == NULL)\n        return 0;\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5196: static void* SDLCALL real_malloc(size_t s) { return malloc(s); }\n5197: \nStacktrace #1:\nFile: /sourcecode/src/stdlib/SDL_malloc.c\n5287: void *SDL_malloc(size_t size)\n5288: {\n5289:     void *mem;\n5290: \n5291:     if (!size) {\n5292:         size = 1;\n5293:     }\n5294: \n5295:     mem = s_mem.malloc_func(size);\n5296:     if (mem) {\n5297:         SDL_AtomicIncRef(&s_mem.num_allocations);\n5298:     }\n5299:     return mem;\n5300: }\n5301: \nStacktrace #2:\nFile: /sourcecode/src/cpuinfo/SDL_cpuinfo.c\n1155: void *SDL_SIMDAlloc(const size_t len)\n1156: {\n1157:     const size_t alignment = SDL_SIMDGetAlignment();\n1158:     const size_t padding = (alignment - (len % alignment)) % alignment;\n1159:     Uint8 *retval = NULL;\n1160:     Uint8 *ptr;\n1161:     size_t to_allocate;\n1162: \n1163:     /* alignment + padding + sizeof(void *) is bounded (a few hundred\n1164:      * bytes max), so no need to check for overflow within that argument */\n1165:     if (SDL_size_add_overflow(len, alignment + padding + sizeof(void *), &to_allocate)) {\n1166:         return NULL;\n1167:     }\n1168: \n1169:     ptr = (Uint8 *)SDL_malloc(to_allocate);\n1170:     if (ptr) {\n1171:         /* store the actual allocated pointer right before our aligned pointer. */\n1172:         retval = ptr + sizeof(void *);\n1173:         retval += alignment - (((size_t)retval) % alignment);\n1174:         *(((void **)retval) - 1) = ptr;\n1175:     }\n1176:     return retval;\n1177: }\n1178: \nStacktrace #3:\nFile: /sourcecode/src/video/SDL_surface.c\n  77: SDL_Surface *SDL_CreateRGBSurfaceWithFormat(Uint32 flags, int width, int height, int depth,\n  78:                                Uint32 format)\n  79: {\n  80:     size_t pitch;\n  81:     SDL_Surface *surface;\n  82: \n  83:     /* The flags are no longer used, make the compiler happy */\n  84:     (void)flags;\n  85: \n  86:     if (width < 0) {\n  87:         SDL_InvalidParamError(\"width\");\n  88:         return NULL;\n  89:     }\n  90: \n  91:     if (height < 0) {\n  92:         SDL_InvalidParamError(\"height\");\n  93:         return NULL;\n  94:     }\n  95: \n  96:     if (SDL_ISPIXELFORMAT_FOURCC(format)) {\n  97:         SDL_SetError(\"invalid format\");\n  98:         return NULL;\n  99:     } else {\n 100:         pitch = SDL_CalculatePitch(format, width, SDL_FALSE);\n 101:         if (pitch > SDL_MAX_SINT32) {\n 102:             /* Overflow... */\n 103:             SDL_OutOfMemory();\n 104:             return NULL;\n 105:         }\n 106:     }\n 107: \n 108:     /* Allocate the surface */\n 109:     surface = (SDL_Surface *)SDL_calloc(1, sizeof(*surface));\n 110:     if (!surface) {\n 111:         SDL_OutOfMemory();\n 112:         return NULL;\n 113:     }\n 114: \n 115:     surface->format = SDL_AllocFormat(format);\n 116:     if (!surface->format) {\n 117:         SDL_FreeSurface(surface);\n 118:         return NULL;\n 119:     }\n 120:     surface->w = width;\n 121:     surface->h = height;\n 122:     surface->pitch = (int)pitch;\n 123:     SDL_SetClipRect(surface, NULL);\n 124: \n 125:     if (SDL_ISPIXELFORMAT_INDEXED(surface->format->format)) {\n 126:         SDL_Palette *palette =\n 127:             SDL_AllocPalette((1 << surface->format->BitsPerPixel));\n 128:         if (!palette) {\n 129:             SDL_FreeSurface(surface);\n 130:             return NULL;\n 131:         }\n 132:         if (palette->ncolors == 2) {\n 133:             /* Create a black and white bitmap palette */\n 134:             palette->colors[0].r = 0xFF;\n 135:             palette->colors[0].g = 0xFF;\n 136:             palette->colors[0].b = 0xFF;\n 137:             palette->colors[1].r = 0x00;\n 138:             palette->colors[1].g = 0x00;\n 139:             palette->colors[1].b = 0x00;\n 140:         }\n 141:         SDL_SetSurfacePalette(surface, palette);\n 142:         SDL_FreePalette(palette);\n 143:     }\n 144: \n 145:     /* Get the pixels */\n 146:     if (surface->w && surface->h) {\n 147:         /* Assumptions checked in surface_size_assumptions assert above */\n 148:         size_t size;\n 149:         if (SDL_size_mul_overflow(surface->h, surface->pitch, &size)) {\n 150:             /* Overflow... */\n 151:             SDL_FreeSurface(surface);\n 152:             SDL_OutOfMemory();\n 153:             return NULL;\n 154:         }\n 155: \n 156:         surface->pixels = SDL_SIMDAlloc(size);\n 157:         if (!surface->pixels) {\n 158:             SDL_FreeSurface(surface);\n 159:             SDL_OutOfMemory();\n 160:             return NULL;\n 161:         }\n 162:         surface->flags |= SDL_SIMD_ALIGNED;\n 163:         /* This is important for bitmaps */\n 164:         SDL_memset(surface->pixels, 0, size);\n 165:     }\n 166: \n 167:     /* Allocate an empty mapping */\n 168:     surface->map = SDL_AllocBlitMap();\n 169:     if (!surface->map) {\n 170:         SDL_FreeSurface(surface);\n 171:         return NULL;\n 172:     }\n 173: \n 174:     /* By default surface with an alpha mask are set up for blending */\n 175:     if (surface->format->Amask) {\n 176:         SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND);\n 177:     }\n 178: \n 179:     /* The surface is ready to go */\n 180:     surface->refcount = 1;\n 181:     return surface;\n 182: }\n 183: \nStacktrace #4:\nFile: /sourcecode/src/dynapi/SDL_dynapi_procs.h\n 643: SDL_DYNAPI_PROC(SDL_Surface*,SDL_CreateRGBSurfaceWithFormat,(Uint32 a, int b, int c, int d, Uint32 e),(a,b,c,d,e),return)\n 644:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==374859==ERROR: AddressSanitizer: allocator is out of memory trying to allocate 0x7fffffff8 bytes\n    #0 0x7fbf45521a57 in __interceptor_calloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154\n    #1 0x5582e91b500b in poller_create /sourcecode/src/kernel/poller.c:1173\n    #2 0x5582e91a6b1d in fuzzloop /dockerin/fuzz_drivers/tf1729655094044ocqe.cpp:21\n    #3 0x5582e91cb8b9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n\n==374859==HINT: if you don't care about these errors you may set allocator_may_return_null=1\nSUMMARY: AddressSanitizer: out-of-memory ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:154 in __interceptor_calloc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:01\n// Signature: poller_start(poller_t *poller)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: poller_start\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/kernel/poller.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    struct poller_params params = {\n        .max_open_files = fuzzUint32(0),\n        .callback = NULL,\n        .context = NULL\n    };\n\n    poller_t *poller = poller_create(&params);\n    if (poller) {\n        poller_start(poller);\n        poller_destroy(poller);\n    }\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/poller.c\n1171: poller_t *poller_create(const struct poller_params *params)\n1172: {\n1173: \tvoid **nodes_buf = (void **)calloc(params->max_open_files, sizeof (void *));\n1174: \tpoller_t *poller;\n1175: \n1176: \tif (nodes_buf)\n1177: \t{\n1178: \t\tpoller = __poller_create(nodes_buf, params);\n1179: \t\tif (poller)\n1180: \t\t\treturn poller;\n1181: \n1182: \t\tfree(nodes_buf);\n1183: \t}\n1184: \n1185: \treturn NULL;\n1186: }\n1187:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f792fdf7f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x557192f11899 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f792f81451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f792f8689fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f792f814475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f792f7fa7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f792fba4b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f792fbb020b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f792fbb0276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f792fbb04d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x557192ea94e1 in YAML::Parser::HandleYamlDirective(YAML::Token const&) /sourcecode/src/parser.cpp:72\n    #11 0x557192ea5688 in fuzzloop /dockerin/fuzz_drivers/tf1729061962993jopd.cpp:74\n    #12 0x557192f10a99 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x557192ea5028 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f792f7fbd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f792f7fbe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x557192ea5174 in _start (/dockerin/fuzz_drivers/tf1729061962993jopd.out+0x67174)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Parser::HandleYamlDirective(Token &token)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML6Parser19HandleYamlDirectiveERKNS_5TokenE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cstdio> //extract\n#include <sstream> //extract\n#include \"directives.h\"  // IWYU pragma: keep //extract\n#include \"scanner.h\"     // IWYU pragma: keep //extract\n#include \"singledocparser.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include <cstring> //autogen\n\n//  enum TYPE {\n//    DIRECTIVE,\n//    DOC_START,\n//    DOC_END,\n//    BLOCK_SEQ_START,\n//    BLOCK_MAP_START,\n//    BLOCK_SEQ_END,\n//    BLOCK_MAP_END,\n//    BLOCK_ENTRY,\n//    FLOW_SEQ_START,\n//    FLOW_MAP_START,\n//    FLOW_SEQ_END,\n//    FLOW_MAP_END,\n//    FLOW_MAP_COMPACT,\n//    FLOW_ENTRY,\n//    KEY,\n//    VALUE,\n//    ANCHOR,\n//    ALIAS,\n//    TAG,\n//    PLAIN_SCALAR,\n//    NON_PLAIN_SCALAR\n//  };\nYAML::Token::TYPE FuzzYAML_Token_TYPE(uint64_t rand) {\n    // DIRECTIVE=0 DOC_START=1 DOC_END=2 BLOCK_SEQ_START=3 BLOCK_MAP_START=4\n    // BLOCK_SEQ_END=5 BLOCK_MAP_END=6 BLOCK_ENTRY=7 FLOW_SEQ_START=8\n    // FLOW_MAP_START=9 FLOW_SEQ_END=10 FLOW_MAP_END=11 FLOW_MAP_COMPACT=12\n    // FLOW_ENTRY=13 KEY=14 VALUE=15 ANCHOR=16 ALIAS=17 TAG=18\n    // PLAIN_SCALAR=19 NON_PLAIN_SCALAR=20\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::Token::TYPE)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    YAML::Token::TYPE type_ = FuzzYAML_Token_TYPE(enum_rand);\n    auto parser = std::make_unique<YAML::Parser>();\n    std::string temp = fuzzString(1);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    YAML::Mark mark_ = scanner->mark();\n    YAML::Token token(type_, mark_);\n    parser->HandleYamlDirective(token);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/parser.cpp\n  70: void Parser::HandleYamlDirective(const Token& token) {\n  71:   if (token.params.size() != 1) {\n  72:     throw ParserException(token.mark, ErrorMsg::YAML_DIRECTIVE_ARGS);\n  73:   }\n  74: \n  75:   if (!m_pDirectives->version.isDefault) {\n  76:     throw ParserException(token.mark, ErrorMsg::REPEATED_YAML_DIRECTIVE);\n  77:   }\n  78: \n  79:   std::stringstream str(token.params[0]);\n  80:   str >> m_pDirectives->version.major;\n  81:   str.get();\n  82:   str >> m_pDirectives->version.minor;\n  83:   if (!str || str.peek() != EOF) {\n  84:     throw ParserException(\n  85:         token.mark, std::string(ErrorMsg::YAML_VERSION) + token.params[0]);\n  86:   }\n  87: \n  88:   if (m_pDirectives->version.major > 1) {\n  89:     throw ParserException(token.mark, ErrorMsg::YAML_MAJOR_VERSION);\n  90:   }\n  91: \n  92:   m_pDirectives->version.isDefault = false;\n  93:   // TODO: warning on major == 1, minor > 2?\n  94: }\n  95:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f7048155f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x562e6c4f1ed9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f704753b51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f704758f9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f704753b475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f70475217f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f70475823db  (/lib/x86_64-linux-gnu/libc.so.6+0x893db)\n    #7 0x7f70475826ef in __libc_fatal (/lib/x86_64-linux-gnu/libc.so.6+0x896ef)\n    #8 0x7f704758a2e7  (/lib/x86_64-linux-gnu/libc.so.6+0x912e7)\n    #9 0x7f7047591001 in pthread_mutex_lock (/lib/x86_64-linux-gnu/libc.so.6+0x98001)\n    #10 0x562e6c4d0b7b in poller_add_timer /sourcecode/src/kernel/poller.c:1550\n    #11 0x562e6c48b9f0 in mpoller_add_timer /sourcecode/src/kernel/mpoller.h:80\n    #12 0x562e6c4b1e34 in Communicator::sleep(SleepSession*) /sourcecode/src/kernel/Communicator.cc:1852\n    #13 0x562e6c48577e in CommScheduler::sleep(SleepSession*) (/dockerin/fuzz_drivers/tf1729655162704uxlq.out+0xad77e)\n    #14 0x562e6c48615c in SleepRequest::dispatch() (/dockerin/fuzz_drivers/tf1729655162704uxlq.out+0xae15c)\n    #15 0x562e6c486b0c in Workflow::start_series_work(SubTask*, std::function<void (SeriesWork const*)>) (/dockerin/fuzz_drivers/tf1729655162704uxlq.out+0xaeb0c)\n    #16 0x562e6c486ca8 in WFTimerTask::start() (/dockerin/fuzz_drivers/tf1729655162704uxlq.out+0xaeca8)\n    #17 0x562e6c4837bd in fuzzloop /dockerin/fuzz_drivers/tf1729655162704uxlq.cpp:40\n    #18 0x562e6c4f10d9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #19 0x562e6c482c38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #20 0x7f7047522d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #21 0x7f7047522e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #22 0x562e6c482d84 in _start (/dockerin/fuzz_drivers/tf1729655162704uxlq.out+0xaad84)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:01\n// Signature: WFTimerTask::WFTimerTask(CommScheduler *scheduler, std::function<void (WFTimerTask *)> cb)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN11WFTimerTaskC1EP13CommSchedulerSt8functionIFvPS_EE\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/WFTask.h\"\n#include \"_include/workflow/SleepRequest.h\"\n#include \"_include/workflow/Communicator.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    CommScheduler scheduler;\n    std::function<void (WFTimerTask *)> cb = [](WFTimerTask *task) {\n        // Callback function\n    };\n\n    // Provide a concrete implementation for the pure virtual function\n    class ConcreteWFTimerTask : public WFTimerTask {\n    public:\n        ConcreteWFTimerTask(CommScheduler *scheduler, std::function<void (WFTimerTask *)> cb)\n            : WFTimerTask(scheduler, cb) {}\n\n        virtual int duration(struct timespec *value) override {\n            // Implement the pure virtual function\n            // For example, set a fixed duration\n            value->tv_sec = 1;\n            value->tv_nsec = 0;\n            return 0;\n        }\n    };\n\n    ConcreteWFTimerTask *timerTask = new ConcreteWFTimerTask(&scheduler, cb);\n    timerTask->user_data = fuzzData(0);\n    timerTask->start();\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/poller.c\n1524: int poller_add_timer(const struct timespec *value, void *context, void **timer,\n1525: \t\t\t\t\t poller_t *poller)\n1526: {\n1527: \tstruct __poller_node *node;\n1528: \n1529: \tnode = (struct __poller_node *)malloc(sizeof (struct __poller_node));\n1530: \tif (node)\n1531: \t{\n1532: \t\tmemset(&node->data, 0, sizeof (struct poller_data));\n1533: \t\tnode->data.operation = PD_OP_TIMER;\n1534: \t\tnode->data.fd = -1;\n1535: \t\tnode->data.context = context;\n1536: \t\tnode->in_rbtree = 0;\n1537: \t\tnode->removed = 0;\n1538: \t\tnode->res = NULL;\n1539: \n1540: \t\tclock_gettime(CLOCK_MONOTONIC, &node->timeout);\n1541: \t\tnode->timeout.tv_sec += value->tv_sec;\n1542: \t\tnode->timeout.tv_nsec += value->tv_nsec;\n1543: \t\tif (node->timeout.tv_nsec >= 1000000000)\n1544: \t\t{\n1545: \t\t\tnode->timeout.tv_nsec -= 1000000000;\n1546: \t\t\tnode->timeout.tv_sec++;\n1547: \t\t}\n1548: \n1549: \t\t*timer = node;\n1550: \t\tpthread_mutex_lock(&poller->mutex);\n1551: \t\t__poller_insert_node(node, poller);\n1552: \t\tpthread_mutex_unlock(&poller->mutex);\n1553: \t\treturn 0;\n1554: \t}\n1555: \n1556: \treturn -1;\n1557: }\n1558: \nStacktrace #1:\nFile: /sourcecode/src/kernel/mpoller.h\n  74: static inline int mpoller_add_timer(const struct timespec *value, void *context,\n  75: \t\t\t\t\t\t\t\t\tvoid **timer, int *index,\n  76: \t\t\t\t\t\t\t\t\tmpoller_t *mpoller)\n  77: {\n  78: \tstatic unsigned int n = 0;\n  79: \t*index = n++ % mpoller->nthreads;\n  80: \treturn poller_add_timer(value, context, timer, mpoller->poller[*index]);\n  81: }\n  82: \nStacktrace #2:\nFile: /sourcecode/src/kernel/Communicator.cc\n1846: int Communicator::sleep(SleepSession *session)\n1847: {\n1848: \tstruct timespec value;\n1849: \n1850: \tif (session->duration(&value) >= 0)\n1851: \t{\n1852: \t\tif (mpoller_add_timer(&value, session, &session->timer, &session->index,\n1853: \t\t\t\t\t\t\t  this->mpoller) >= 0)\n1854: \t\t\treturn 0;\n1855: \t}\n1856: \n1857: \treturn -1;\n1858: }\n1859:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f2a69910f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x564343e95f69 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f2a68f4451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f2a68f989fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f2a68f44475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f2a68f2a7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f2a68f2a71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f2a68f3be95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x564343dafad2 in fiobj_hash_set /sourcecode/lib/facil/fiobj/fiobj_hash.c:200\n    #9 0x564343da5340 in fuzzloop /dockerin/fuzz_drivers/tf1729850026987ajbd.c:25\n    #10 0x564343e95169 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x564343da4a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f2a68f2bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f2a68f2be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x564343da4be4 in _start (/dockerin/fuzz_drivers/tf1729850026987ajbd.out+0x115be4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 09:53:37\n// Signature: fiobj_hash_set(FIOBJ hash, FIOBJ key, FIOBJ obj)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_hash_set\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <assert.h> //extract\n#include <fiobj_hash.h> //extract\n#include <fio.h> //extract\n#include <errno.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long hash = (unsigned long)fuzzUint64(0);\n    unsigned long key = (unsigned long)fuzzUint64(1);\n    unsigned long obj = (unsigned long)fuzzUint64(2);\n    int ret = fiobj_hash_set(hash, key, obj);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_hash.c\n 199: int fiobj_hash_set(FIOBJ hash, FIOBJ key, FIOBJ obj) {\n 200:   assert(hash && FIOBJ_TYPE_IS(hash, FIOBJ_T_HASH));\n 201:   if (FIOBJ_TYPE_IS(key, FIOBJ_T_STRING))\n 202:     fiobj_str_freeze(key);\n 203:   fio_hash___insert(&obj2hash(hash)->hash, fiobj_obj2hash(key), key, obj, NULL);\n 204:   fiobj_free(obj); /* take ownership - free the user's reference. */\n 205:   return 0;\n 206: }\n 207:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f65078def18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55d271f36509 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f65072fb51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f650734f9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f65072fb475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f65072e17f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f65072e171a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f65072f2e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55d271f0f282 in YAML::NodeBuilder::RegisterAnchor(unsigned long, YAML::detail::node&) /sourcecode/src/nodebuilder.cpp:130\n    #9 0x55d271f0e821 in YAML::NodeBuilder::Push(YAML::Mark const&, unsigned long) /sourcecode/src/nodebuilder.cpp:83\n    #10 0x55d271f0e56f in YAML::NodeBuilder::OnScalar(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/nodebuilder.cpp:49\n    #11 0x55d271f0cec8 in fuzzloop /dockerin/fuzz_drivers/tf1729571804697ojxz.cpp:24\n    #12 0x55d271f35709 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55d271f0ca38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f65072e2d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f65072e2e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55d271f0cb84 in _start (/dockerin/fuzz_drivers/tf1729571804697ojxz.out+0x34b84)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-22 04:35:43\n// Signature: YAML::NodeBuilder::NodeBuilder()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML11NodeBuilderC1Ev\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"include/yaml-cpp/mark.h\" // Added to fix undeclared symbol \"YAML::Mark\" error\n#include \"src/nodebuilder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    YAML::NodeBuilder builder;\n    YAML::Mark mark;\n    YAML::anchor_t anchor = fuzzUint8(0); // Changed to YAML::anchor_t\n    std::string tag = fuzzString(1);\n    std::string value = fuzzString(2);\n    YAML::EmitterStyle::value style = static_cast<YAML::EmitterStyle::value>(fuzzUint8(3) % 5); // Added YAML:: namespace\n\n    builder.OnDocumentStart(mark);\n    builder.OnScalar(mark, tag, anchor, value);\n    builder.OnSequenceStart(mark, tag, anchor, style);\n    builder.OnSequenceEnd();\n    builder.OnMapStart(mark, tag, anchor, style);\n    builder.OnMapEnd();\n    builder.OnDocumentEnd();\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nodebuilder.cpp\n 128: void NodeBuilder::RegisterAnchor(anchor_t anchor, detail::node& node) {\n 129:   if (anchor) {\n 130:     assert(anchor == m_anchors.size());\n 131:     m_anchors.push_back(&node);\n 132:   }\n 133: }\n 134: \nStacktrace #1:\nFile: /sourcecode/src/nodebuilder.cpp\n  80: detail::node& NodeBuilder::Push(const Mark& mark, anchor_t anchor) {\n  81:   detail::node& node = m_pMemory->create_node();\n  82:   node.set_mark(mark);\n  83:   RegisterAnchor(anchor, node);\n  84:   Push(node);\n  85:   return node;\n  86: }\n  87: \nStacktrace #2:\nFile: /sourcecode/src/nodebuilder.cpp\n  47: void NodeBuilder::OnScalar(const Mark& mark, const std::string& tag,\n  48:                            anchor_t anchor, const std::string& value) {\n  49:   detail::node& node = Push(mark, anchor);\n  50:   node.set_scalar(value);\n  51:   node.set_tag(tag);\n  52:   Pop();\n  53: }\n  54:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fe2d9027f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x56384e6c3999 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fe2d865b51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fe2d86af9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fe2d865b475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fe2d86417f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fe2d864171a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7fe2d8652e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x56384e5dbfbd in fiobj_hash_rehash /sourcecode/lib/facil/fiobj/fiobj_hash.c:50\n    #9 0x56384e5d3319 in fuzzloop /dockerin/fuzz_drivers/tf1728899912457kuib.c:22\n    #10 0x56384e6c2b99 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x56384e5d2a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7fe2d8642d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7fe2d8642e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x56384e5d2be4 in _start (/dockerin/fuzz_drivers/tf1728899912457kuib.out+0x115be4)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: fiobj_hash_rehash\n// Sign: fiobj_hash_rehash(FIOBJ h)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <assert.h> //extract\n#include <fiobj_hash.h> //extract\n#include <fio.h> //extract\n#include <errno.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long h = (unsigned long)fuzzUint64(0);\n    fiobj_hash_rehash(h);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_hash.c\n  49: void fiobj_hash_rehash(FIOBJ h) {\n  50:   assert(h && FIOBJ_TYPE_IS(h, FIOBJ_T_HASH));\n  51:   fio_hash___rehash(&obj2hash(h)->hash);\n  52: }\n  53:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f539c9dcf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x556a537c3f09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f539c3f951f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f539c44d9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f539c3f9475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f539c3df7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f539c3df71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f539c3f0e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x556a53776b70 in YAML::Scanner::peek() /sourcecode/src/scanner.cpp:37\n    #9 0x556a53774249 in fuzzloop /dockerin/fuzz_drivers/tf1729566972748lkxj.cpp:27\n    #10 0x556a537c3109 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x556a53773e68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f539c3e0d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f539c3e0e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x556a53773fb4 in _start (/dockerin/fuzz_drivers/tf1729566972748lkxj.out+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-22 03:15:59\n// Signature: YAML::Scanner::peek()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner4peekEv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream>\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    scanner->peek();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scanner.cpp\n  35: Token& Scanner::peek() {\n  36:   EnsureTokensInQueue();\n  37:   assert(!m_tokens.empty());  // should we be asserting here? I mean, we really\n  38:                               // just be checking\n  39:                               // if it's empty before peeking.\n  40: \n  41: #if 0\n  42: \t\tstatic Token *pLast = 0;\n  43: \t\tif(pLast != &m_tokens.front())\n  44: \t\t\tstd::cerr << \"peek: \" << m_tokens.front() << \"\\n\";\n  45: \t\tpLast = &m_tokens.front();\n  46: #endif\n  47: \n  48:   return m_tokens.front();\n  49: }\n  50:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f3b64c97f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x562e4c3d3709 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f3b646b451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f3b647089fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f3b646b4475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f3b6469a7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f3b64a44b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f3b64a5020b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f3b64a50276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f3b64a504d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x562e4c34a154 in YAML::LoadAllFromFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/parse.cpp:68\n    #11 0x562e4c347458 in fuzzloop /dockerin/fuzz_drivers/tf1729580069511oric.cpp:25\n    #12 0x562e4c3d2909 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x562e4c347098 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f3b6469bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f3b6469be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x562e4c3471e4 in _start (/dockerin/fuzz_drivers/tf1729580069511oric.out+0x881e4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::LoadAllFromFile(std::string &filename)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML15LoadAllFromFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"yaml-cpp/node/parse.h\" //extract\n#include <fstream> //extract\n#include <sstream> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string filename = fuzzString(0);\n    std::vector<YAML::Node> ret = YAML::LoadAllFromFile(filename);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/parse.cpp\n  65: std::vector<Node> LoadAllFromFile(const std::string& filename) {\n  66:   std::ifstream fin(filename);\n  67:   if (!fin) {\n  68:     throw BadFile(filename);\n  69:   }\n  70:   return LoadAll(fin);\n  71: }\n  72:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f32918ebf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x559dfaad8f49 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f3290f1f51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f3290f739fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f3290f1f475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f3290f057f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f3290f0571a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f3290f16e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x559dfa9f39a7 in fiobj_hash_clear /sourcecode/lib/facil/fiobj/fiobj_hash.c:330\n    #9 0x559dfa9e8319 in fuzzloop /dockerin/fuzz_drivers/tf1729822403072ygto.c:23\n    #10 0x559dfaad8149 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x559dfa9e7a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f3290f06d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f3290f06e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x559dfa9e7be4 in _start (/dockerin/fuzz_drivers/tf1729822403072ygto.out+0x115be4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-25 02:13:13\n// Signature: fiobj_hash_clear(FIOBJ hash)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_hash_clear\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <assert.h> //extract\n#include <fiobj_hash.h> //extract\n#include <fio.h> //extract\n#include <errno.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long hash = (unsigned long)fuzzUint64(0);\n    fiobj_hash_clear(hash);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_hash.c\n 329: void fiobj_hash_clear(const FIOBJ hash) {\n 330:   assert(hash && FIOBJ_TYPE_IS(hash, FIOBJ_T_HASH));\n 331:   fio_hash___free(&obj2hash(hash)->hash);\n 332: }\n 333:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f7bee431f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55a8a8481cf9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f7bede4e51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f7bedea29fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f7bede4e475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f7bede347f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f7bede3471a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f7bede45e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55a8a8417b00 in YAML::NodeBuilder::RegisterAnchor(unsigned long, YAML::detail::node&) /sourcecode/src/nodebuilder.cpp:130\n    #9 0x55a8a841709f in YAML::NodeBuilder::Push(YAML::Mark const&, unsigned long) /sourcecode/src/nodebuilder.cpp:83\n    #10 0x55a8a8416e63 in YAML::NodeBuilder::OnSequenceStart(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, YAML::EmitterStyle::value) /sourcecode/src/nodebuilder.cpp:57\n    #11 0x55a8a841366f in fuzzloop /dockerin/fuzz_drivers/tf1729061962969kckg.cpp:49\n    #12 0x55a8a8480ef9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55a8a8412f58 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f7bede35d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f7bede35e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55a8a84130a4 in _start (/dockerin/fuzz_drivers/tf1729061962969kckg.out+0x6b0a4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::NodeBuilder::OnSequenceStart(Mark &mark, std::string &tag, anchor_t anchor, YAML::EmitterStyle::value style)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML11NodeBuilder15OnSequenceStartERKNS_4MarkERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmNS_12EmitterStyle5valueE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/detail/node.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/node/type.h\" //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream>\n#include <cstring> //autogen\n\n//  enum value { Default, Block, Flow };\nYAML::EmitterStyle::value FuzzYAML_EmitterStyle_value(uint64_t rand) {\n    // Default=0 Block=1 Flow=2\n    static uint64_t values[] = {0, 1, 2, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::EmitterStyle::value)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(3);\n    YAML::EmitterStyle::value style = FuzzYAML_EmitterStyle_value(enum_rand);\n    auto nodebuilder = std::make_unique<YAML::NodeBuilder>();\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    YAML::Mark mark = scanner->mark();\n    std::string tag = fuzzString(1);\n    unsigned long anchor = (unsigned long)fuzzUint64(2);\n    nodebuilder->OnSequenceStart(mark, tag, anchor, style);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nodebuilder.cpp\n 128: void NodeBuilder::RegisterAnchor(anchor_t anchor, detail::node& node) {\n 129:   if (anchor) {\n 130:     assert(anchor == m_anchors.size());\n 131:     m_anchors.push_back(&node);\n 132:   }\n 133: }\n 134: \nStacktrace #1:\nFile: /sourcecode/src/nodebuilder.cpp\n  80: detail::node& NodeBuilder::Push(const Mark& mark, anchor_t anchor) {\n  81:   detail::node& node = m_pMemory->create_node();\n  82:   node.set_mark(mark);\n  83:   RegisterAnchor(anchor, node);\n  84:   Push(node);\n  85:   return node;\n  86: }\n  87: \nStacktrace #2:\nFile: /sourcecode/src/nodebuilder.cpp\n  55: void 10:01 2024-10-2810:01 2024-10-28(const Mark& mark, const std::string& tag,\n  56:                                   anchor_t anchor, EmitterStyle::value style) {\n  57:   detail::node& node = Push(mark, anchor);\n  58:   node.set_tag(tag);\n  59:   node.set_type(NodeType::Sequence);\n  60:   node.set_style(style);\n  61: }\n  62:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f27dc948f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x558ed641a019 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f27dc36551f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f27dc3b99fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f27dc365475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f27dc34b7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f27dc6f5b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f27dc70120b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f27dc701276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f27dc7014d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x558ed63cf750 in YAML::Scanner::ThrowParserException(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const /sourcecode/src/scanner.cpp:389\n    #11 0x558ed63ca2ef in fuzzloop /dockerin/fuzz_drivers/tf1729566972763fgkb.cpp:28\n    #12 0x558ed6419219 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x558ed63c9e68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f27dc34cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f27dc34ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x558ed63c9fb4 in _start (/dockerin/fuzz_drivers/tf1729566972763fgkb.out+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-22 03:15:59\n// Signature: YAML::Scanner::ThrowParserException(std::string &msg)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZNK4YAML7Scanner20ThrowParserExceptionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream>\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    std::string msg = fuzzString(1);\n    scanner->ThrowParserException(msg);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scanner.cpp\n 383: void Scanner::ThrowParserException(const std::string& msg) const {\n 384:   Mark mark = Mark::null_mark();\n 385:   if (!m_tokens.empty()) {\n 386:     const Token& token = m_tokens.front();\n 387:     mark = token.mark;\n 388:   }\n 389:   throw ParserException(mark, msg);\n 390: }\n 391:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f1c2c9e9f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x555c69dc9cf9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f1c2c40651f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f1c2c45a9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f1c2c406475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f1c2c3ec7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f1c2c3ec71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f1c2c3fde95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x555c69d5fb00 in YAML::NodeBuilder::RegisterAnchor(unsigned long, YAML::detail::node&) /sourcecode/src/nodebuilder.cpp:130\n    #9 0x555c69d5f09f in YAML::NodeBuilder::Push(YAML::Mark const&, unsigned long) /sourcecode/src/nodebuilder.cpp:83\n    #10 0x555c69d5eeff in YAML::NodeBuilder::OnMapStart(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, unsigned long, YAML::EmitterStyle::value) /sourcecode/src/nodebuilder.cpp:67\n    #11 0x555c69d5b66f in fuzzloop /dockerin/fuzz_drivers/tf1729580069689dpjq.cpp:48\n    #12 0x555c69dc8ef9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x555c69d5af58 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f1c2c3edd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f1c2c3ede3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x555c69d5b0a4 in _start (/dockerin/fuzz_drivers/tf1729580069689dpjq.out+0x6b0a4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::NodeBuilder::OnMapStart(Mark &mark, std::string &tag, anchor_t anchor, YAML::EmitterStyle::value style)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML11NodeBuilder10OnMapStartERKNS_4MarkERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmNS_12EmitterStyle5valueE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/detail/node.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/node/type.h\" //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream>\n#include <cstring> //autogen\n\n//  enum value { Default, Block, Flow };\nYAML::EmitterStyle::value FuzzYAML_EmitterStyle_value(uint64_t rand) {\n    // Default=0 Block=1 Flow=2\n    static uint64_t values[] = {0, 1, 2, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::EmitterStyle::value)values[index];\n}\n\nextern \"C\" int fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(3);\n    YAML::EmitterStyle::value style = FuzzYAML_EmitterStyle_value(enum_rand);\n    auto nodebuilder = std::make_unique<YAML::NodeBuilder>();\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    YAML::Mark mark = scanner->mark();\n    std::string tag = fuzzString(1);\n    unsigned long anchor = (unsigned long)fuzzUint64(2);\n    nodebuilder->OnMapStart(mark, tag, anchor, style);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nodebuilder.cpp\n 128: void NodeBuilder::RegisterAnchor(anchor_t anchor, detail::node& node) {\n 129:   if (anchor) {\n 130:     assert(anchor == m_anchors.size());\n 131:     m_anchors.push_back(&node);\n 132:   }\n 133: }\n 134: \nStacktrace #1:\nFile: /sourcecode/src/nodebuilder.cpp\n  80: detail::node& NodeBuilder::Push(const Mark& mark, anchor_t anchor) {\n  81:   detail::node& node = m_pMemory->create_node();\n  82:   node.set_mark(mark);\n  83:   RegisterAnchor(anchor, node);\n  84:   Push(node);\n  85:   return node;\n  86: }\n  87: \nStacktrace #2:\nFile: /sourcecode/src/nodebuilder.cpp\n  65: void NodeBuilder::OnMapStart(const Mark& mark, const std::string& tag,\n  66:                              anchor_t anchor, EmitterStyle::value style) {\n  67:   detail::node& node = Push(mark, anchor);\n  68:   node.set_type(NodeType::Map);\n  69:   node.set_tag(tag);\n  70:   node.set_style(style);\n  71:   m_mapDepth++;\n  72: }\n  73:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fae3a376f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55a3bd42fb19 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fae39d9351f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fae39de79fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fae39d93475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fae39d797f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fae39d7971a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7fae39d8ae95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55a3bd41fa65 in void YAML::EmitterState::_Set<YAML::EMITTER_MANIP>(YAML::Setting<YAML::EMITTER_MANIP>&, YAML::EMITTER_MANIP, YAML::FmtScope::value) /sourcecode/src/emitterstate.h:211\n    #9 0x55a3bd41d66c in YAML::EmitterState::SetFlowType(YAML::GroupType::value, YAML::EMITTER_MANIP, YAML::FmtScope::value) /sourcecode/src/emitterstate.cpp:359\n    #10 0x55a3bd419b97 in fuzzloop /sharedockerin/ta1729581129791rnwv/test_file.cpp:121\n    #11 0x55a3bd42ed19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #12 0x55a3bd419568 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #13 0x7fae39d7ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #14 0x7fae39d7ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #15 0x55a3bd4196b4 in _start (/sharedockerin/ta1729581129791rnwv/clouditera+0x216b4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::EmitterState::SetFlowType(YAML::GroupType::value groupType, YAML::EMITTER_MANIP value, YAML::FmtScope::value scope)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML12EmitterState11SetFlowTypeENS_9GroupType5valueENS_13EMITTER_MANIPENS_8FmtScope5valueE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <limits> //extract\n#include \"emitterstate.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\n//  enum value { NoType, Seq, Map };\nYAML::GroupType::value FuzzYAML_GroupType_value(uint64_t rand) {\n    // NoType=0 Seq=1 Map=2\n    static uint64_t values[] = {0, 1, 2, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::GroupType::value)values[index];\n}\n\n//enum EMITTER_MANIP {\n//  // general manipulators\n//  Auto,\n//  TagByKind,\n//  Newline,\n//\n//  // output character set\n//  EmitNonAscii,\n//  EscapeNonAscii,\n//  EscapeAsJson,\n//\n//  // string manipulators\n//  // Auto, // duplicate\n//  SingleQuoted,\n//  DoubleQuoted,\n//  Literal,\n//\n//  // null manipulators\n//  LowerNull,\n//  UpperNull,\n//  CamelNull,\n//  TildeNull,\n//\n//  // bool manipulators\n//  YesNoBool,      // yes, no\n//  TrueFalseBool,  // true, false\n//  OnOffBool,      // on, off\n//  UpperCase,      // TRUE, N\n//  LowerCase,      // f, yes\n//  CamelCase,      // No, Off\n//  LongBool,       // yes, On\n//  ShortBool,      // y, t\n//\n//  // int manipulators\n//  Dec,\n//  Hex,\n//  Oct,\n//\n//  // document manipulators\n//  BeginDoc,\n//  EndDoc,\n//\n//  // sequence manipulators\n//  BeginSeq,\n//  EndSeq,\n//  Flow,\n//  Block,\n//\n//  // map manipulators\n//  BeginMap,\n//  EndMap,\n//  Key,\n//  Value,\n//  // Flow, // duplicate\n//  // Block, // duplicate\n//  // Auto, // duplicate\n//  LongKey\n//};\nYAML::EMITTER_MANIP FuzzYAML_EMITTER_MANIP(uint64_t rand) {\n    // Auto=0 TagByKind=1 Newline=2 EmitNonAscii=3 EscapeNonAscii=4\n    // EscapeAsJson=5 SingleQuoted=6 DoubleQuoted=7 Literal=8\n    // LowerNull=9 UpperNull=10 CamelNull=11 TildeNull=12 YesNoBool=13\n    // TrueFalseBool=14 OnOffBool=15 UpperCase=16 LowerCase=17\n    // CamelCase=18 LongBool=19 ShortBool=20 Dec=21 Hex=22 Oct=23\n    // BeginDoc=24 EndDoc=25 BeginSeq=26 EndSeq=27 Flow=28 Block=29\n    // BeginMap=30 EndMap=31 Key=32 Value=33 LongKey=34\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::EMITTER_MANIP)values[index];\n}\n\n//  enum value { Local, Global };\nYAML::FmtScope::value FuzzYAML_FmtScope_value(uint64_t rand) {\n    // Local=0 Global=1\n    static uint64_t values[] = {0, 1, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::FmtScope::value)values[index];\n}\n\nextern \"C\" int fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    YAML::GroupType::value groupType = FuzzYAML_GroupType_value(enum_rand);\n    uint64_t enum_rand1 = fuzzUint64(1);\n    YAML::EMITTER_MANIP value = FuzzYAML_EMITTER_MANIP(enum_rand1);\n    uint64_t enum_rand2 = fuzzUint64(2);\n    YAML::FmtScope::value scope = FuzzYAML_FmtScope_value(enum_rand2);\n    auto emitterstate = std::make_unique<YAML::EmitterState>();\n    emitterstate->SetFlowType(groupType, value, scope);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/emitterstate.h\n 201:     case FmtScope::Local:\n 202:       m_modifiedSettings.push(fmt.set(value));\n 203:       break;\n 204:     case FmtScope::Global:\n 205:       fmt.set(value);\n 206:       m_globalModifiedSettings.push(\n 207:           fmt.set(value));  // this pushes an identity set, so when we restore,\n 208:       // it restores to the value here, and not the previous one\n 209:       break;\n 210:     default:\n 211:       assert(false);\n 212:   }\n 213: }\n 214: }  // namespace YAML\n 215: \n 216: #endif  // EMITTERSTATE_H_62B23520_7C8E_11DE_8A39_0800200C9A66\n 217: \nStacktrace #1:\nFile: /sourcecode/src/emitterstate.cpp\n 354: bool EmitterState::SetFlowType(GroupType::value groupType, EMITTER_MANIP value,\n 355:                                FmtScope::value scope) {\n 356:   switch (value) {\n 357:     case Block:\n 358:     case Flow:\n 359:       _Set(groupType == GroupType::Seq ? m_seqFmt : m_mapFmt, value, scope);\n 360:       return true;\n 361:     default:\n 362:       return false;\n 363:   }\n 364: }\n 365:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7ff23bdb8f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5572f0af1f09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7ff23b7d551f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7ff23b8299fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7ff23b7d5475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7ff23b7bb7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7ff23bb65b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7ff23bb7120b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7ff23bb71276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7ff23bb714d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x5572f0ae7f31 in YAML::Exp::Escape[abi:cxx11](YAML::Stream&) /sourcecode/src/exp.cpp:134\n    #11 0x5572f0ae35ab in YAML::ScanScalar[abi:cxx11](YAML::Stream&, YAML::ScanScalarParams&) /sourcecode/src/scanscalar.cpp:71\n    #12 0x5572f0ad45ae in YAML::Scanner::ScanQuotedScalar() /sourcecode/src/scantoken.cpp:361\n    #13 0x5572f0aa2249 in fuzzloop /dockerin/fuzz_drivers/tf1729044067573sryj.cpp:34\n    #14 0x5572f0af1109 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #15 0x5572f0aa1e68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #16 0x7ff23b7bcd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #17 0x7ff23b7bce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #18 0x5572f0aa1fb4 in _start (/dockerin/fuzz_drivers/tf1729044067573sryj.out+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:00:58\n// Signature: YAML::Scanner::ScanQuotedScalar()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner16ScanQuotedScalarEv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream> //extract\n#include \"regex_yaml.h\" //extract\n#include \"regeximpl.h\" //extract\n#include \"scanscalar.h\" //extract\n#include \"scantag.h\"  // IWYU pragma: keep //extract\n#include \"tag.h\"      // IWYU pragma: keep //extract\n#include \"yaml-cpp/mark.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    scanner->ScanQuotedScalar();\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/exp.cpp\n  74: std::string Escape(Stream& in) {\n  75:   // eat slash\n  76:   char escape = in.get();\n  77: \n  78:   // switch on escape character\n  79:   char ch = in.get();\n  80: \n  81:   // first do single quote, since it's easier\n  82:   if (escape == '\\'' && ch == '\\'')\n  83:     return \"\\'\";\n  84: \n  85:   // now do the slash (we're not gonna check if it's a slash - you better pass\n  86:   // one!)\n  87:   switch (ch) {\n  88:     case '0':\n  89:       return std::string(1, '\\x00');\n  90:     case 'a':\n  91:       return \"\\x07\";\n  92:     case 'b':\n  93:       return \"\\x08\";\n  94:     case 't':\n  95:     case '\\t':\n  96:       return \"\\x09\";\n  97:     case 'n':\n  98:       return \"\\x0A\";\n  99:     case 'v':\n 100:       return \"\\x0B\";\n 101:     case 'f':\n 102:       return \"\\x0C\";\n 103:     case 'r':\n 104:       return \"\\x0D\";\n 105:     case 'e':\n 106:       return \"\\x1B\";\n 107:     case ' ':\n 108:       return R\"( )\";\n 109:     case '\\\"':\n 110:       return \"\\\"\";\n 111:     case '\\'':\n 112:       return \"\\'\";\n 113:     case '\\\\':\n 114:       return \"\\\\\";\n 115:     case '/':\n 116:       return \"/\";\n 117:     case 'N':\n 118:       return \"\\x85\";\n 119:     case '_':\n 120:       return \"\\xA0\";\n 121:     case 'L':\n 122:       return \"\\xE2\\x80\\xA8\";  // LS (#x2028)\n 123:     case 'P':\n 124:       return \"\\xE2\\x80\\xA9\";  // PS (#x2029)\n 125:     case 'x':\n 126:       return Escape(in, 2);\n 127:     case 'u':\n 128:       return Escape(in, 4);\n 129:     case 'U':\n 130:       return Escape(in, 8);\n 131:   }\n 132: \n 133:   std::stringstream msg;\n 134:   throw ParserException(in.mark(), std::string(ErrorMsg::INVALID_ESCAPE) + ch);\n 135: }\n 136: \nStacktrace #1:\nFile: /sourcecode/src/scanscalar.cpp\n  21: std::string ScanScalar(Stream& INPUT, ScanScalarParams& params) {\n  22:   bool foundNonEmptyLine = false;\n  23:   bool pastOpeningBreak = (params.fold == FOLD_FLOW);\n  24:   bool emptyLine = false, moreIndented = false;\n  25:   int foldedNewlineCount = 0;\n  26:   bool foldedNewlineStartedMoreIndented = false;\n  27:   std::size_t lastEscapedChar = std::string::npos;\n  28:   std::string scalar;\n  29:   params.leadingSpaces = false;\n  30: \n  31:   if (!params.end) {\n  32:     params.end = &Exp::Empty();\n  33:   }\n  34: \n  35:   while (INPUT) {\n  36:     // ********************************\n  37:     // Phase #1: scan until line ending\n  38: \n  39:     std::size_t lastNonWhitespaceChar = scalar.size();\n  40:     bool escapedNewline = false;\n  41:     while (!params.end->Matches(INPUT) && !Exp::Break().Matches(INPUT)) {\n  42:       if (!INPUT) {\n  43:         break;\n  44:       }\n  45: \n  46:       // document indicator?\n  47:       if (INPUT.column() == 0 && Exp::DocIndicator().Matches(INPUT)) {\n  48:         if (params.onDocIndicator == BREAK) {\n  49:           break;\n  50:         }\n...skip...\n  41:     while (!params.end->Matches(INPUT) && !Exp::Break().Matches(INPUT)) {\n  42:       if (!INPUT) {\n  43:         break;\n  44:       }\n  45: \n  46:       // document indicator?\n  47:       if (INPUT.column() == 0 && Exp::DocIndicator().Matches(INPUT)) {\n  48:         if (params.onDocIndicator == BREAK) {\n  49:           break;\n  50:         }\n  51:         if (params.onDocIndicator == THROW) {\n  52:           throw ParserException(INPUT.mark(), ErrorMsg::DOC_IN_SCALAR);\n  53:         }\n  54:       }\n  55: \n  56:       foundNonEmptyLine = true;\n  57:       pastOpeningBreak = true;\n  58: \n  59:       // escaped newline? (only if we're escaping on slash)\n  60:       if (params.escape == '\\\\' && Exp::EscBreak().Matches(INPUT)) {\n  61:         // eat escape character and get out (but preserve trailing whitespace!)\n  62:         INPUT.get();\n  63:         lastNonWhitespaceChar = scalar.size();\n  64:         lastEscapedChar = scalar.size();\n  65:         escapedNewline = true;\n  66:         break;\n  67:       }\n  68: \n  69:       // escape this?\n  70:       if (INPUT.peek() == params.escape) {\n  71:         scalar += Exp::Escape(INPUT);\n  72:         lastNonWhitespaceChar = scalar.size();\n  73:         lastEscapedChar = scalar.size();\n  74:         continue;\n  75:       }\n  76: \n  77:       // otherwise, just add the damn character\n  78:       char ch = INPUT.get();\n  79:       scalar += ch;\n  80:       if (ch != ' ' && ch != '\\t') {\n  81:         lastNonWhitespaceChar = scalar.size();\n  82:       }\n  83:     }\n  84: \n  85:     // eof? if we're looking to eat something, then we throw\n  86:     if (!INPUT) {\n  87:       if (params.eatEnd) {\n  88:         throw ParserException(INPUT.mark(), ErrorMsg::EOF_IN_SCALAR);\n  89:       }\n  90:       break;\n  91:     }\n  92: \n  93:     // doc indicator?\n  94:     if (params.onDocIndicator == BREAK && INPUT.column() == 0 &&\n  95:         Exp::DocIndicator().Matches(INPUT)) {\n  96:       break;\n  97:     }\n  98: \n  99:     // are we done via character match?\n 100:     int n = params.end->Match(INPUT);\n...skip...\n 222:         if (pos < lastEscapedChar || pos == std::string::npos) {\n 223:           pos = lastEscapedChar;\n 224:         }\n 225:       }\n 226:       if (pos == std::string::npos) {\n 227:         scalar.erase();\n 228:       } else if (pos + 1 < scalar.size()) {\n 229:         scalar.erase(pos + 2);\n 230:       }\n 231:     } break;\n 232:     case STRIP: {\n 233:       std::size_t pos = scalar.find_last_not_of('\\n');\n 234:       if (lastEscapedChar != std::string::npos) {\n 235:         if (pos < lastEscapedChar || pos == std::string::npos) {\n 236:           pos = lastEscapedChar;\n 237:         }\n 238:       }\n 239:       if (pos == std::string::npos) {\n 240:         scalar.erase();\n 241:       } else if (pos < scalar.size()) {\n 242:         scalar.erase(pos + 1);\n 243:       }\n 244:     } break;\n 245:     default:\n 246:       break;\n 247:   }\n 248: \n 249:   return scalar;\n 250: }\n 251: \nStacktrace #2:\nFile: /sourcecode/src/scantoken.cpp\n 331: void Scanner::ScanQuotedScalar() {\n 332:   std::string scalar;\n 333: \n 334:   // peek at single or double quote (don't eat because we need to preserve (for\n 335:   // the time being) the input position)\n 336:   char quote = INPUT.peek();\n 337:   bool single = (quote == '\\'');\n 338: \n 339:   // setup the scanning parameters\n 340:   ScanScalarParams params;\n 341:   RegEx end = (single ? RegEx(quote) & !Exp::EscSingleQuote() : RegEx(quote));\n 342:   params.end = &end;\n 343:   params.eatEnd = true;\n 344:   params.escape = (single ? '\\'' : '\\\\');\n 345:   params.indent = 0;\n 346:   params.fold = FOLD_FLOW;\n 347:   params.eatLeadingWhitespace = true;\n 348:   params.trimTrailingSpaces = false;\n 349:   params.chomp = CLIP;\n 350:   params.onDocIndicator = THROW;\n 351: \n 352:   // insert a potential simple key\n 353:   InsertPotentialSimpleKey();\n 354: \n 355:   Mark mark = INPUT.mark();\n 356: \n 357:   // now eat that opening quote\n 358:   INPUT.get();\n 359: \n 360:   // and scan\n 361:   scalar = ScanScalar(INPUT, params);\n 362:   m_simpleKeyAllowed = false;\n 363:   m_canBeJSONFlow = true;\n 364: \n 365:   Token token(Token::NON_PLAIN_SCALAR, mark);\n 366:   token.value = scalar;\n 367:   m_tokens.push(token);\n 368: }\n 369:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f11c2f11f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x560026d3cf09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f11c292e51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f11c29829fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f11c292e475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f11c29147f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f11c2cbeb9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f11c2cca20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f11c2cca276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f11c2cca4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x560026d1ac8c in YAML::Scanner::ScanFlowEnd() /sourcecode/src/scantoken.cpp:106\n    #11 0x560026ced249 in fuzzloop /dockerin/fuzz_drivers/tf1729061963004oqsi.cpp:34\n    #12 0x560026d3c109 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x560026cece68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f11c2915d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f11c2915e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x560026cecfb4 in _start (/dockerin/fuzz_drivers/tf1729061963004oqsi.out+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Scanner::ScanFlowEnd()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner11ScanFlowEndEv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream> //extract\n#include \"regex_yaml.h\" //extract\n#include \"regeximpl.h\" //extract\n#include \"scanscalar.h\" //extract\n#include \"scantag.h\"  // IWYU pragma: keep //extract\n#include \"tag.h\"      // IWYU pragma: keep //extract\n#include \"yaml-cpp/mark.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    scanner->ScanFlowEnd();\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scantoken.cpp\n 104: void Scanner::ScanFlowEnd() {\n 105:   if (InBlockContext())\n 106:     throw ParserException(INPUT.mark(), ErrorMsg::FLOW_END);\n 107: \n 108:   // we might have a solo entry in the flow context\n 109:   if (InFlowContext()) {\n 110:     if (m_flows.top() == FLOW_MAP && VerifySimpleKey())\n 111:       m_tokens.push(Token(Token::VALUE, INPUT.mark()));\n 112:     else if (m_flows.top() == FLOW_SEQ)\n 113:       InvalidateSimpleKey();\n 114:   }\n 115: \n 116:   m_simpleKeyAllowed = false;\n 117:   m_canBeJSONFlow = true;\n 118: \n 119:   // eat\n 120:   Mark mark = INPUT.mark();\n 121:   char ch = INPUT.get();\n 122: \n 123:   // check that it matches the start\n 124:   FLOW_MARKER flowType = (ch == Keys::FlowSeqEnd ? FLOW_SEQ : FLOW_MAP);\n 125:   if (m_flows.top() != flowType)\n 126:     throw ParserException(mark, ErrorMsg::FLOW_END);\n 127:   m_flows.pop();\n 128: \n 129:   Token::TYPE type = (flowType ? Token::FLOW_SEQ_END : Token::FLOW_MAP_END);\n 130:   m_tokens.push(Token(type, mark));\n 131: }\n 132:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "不确定", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f184678ff18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x559947a82659 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f18461ac51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f18462009fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f18461ac475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f18461927f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f184653cb9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f184654820b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f1846548276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f18465484d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x559947a65b7d in YAML::Scanner::ScanBlockScalar() /sourcecode/src/scantoken.cpp:416\n    #11 0x559947a33225 in fuzzloop /dockerin/fuzz_drivers/tf1729571827258uqxw.cpp:20\n    #12 0x559947a81859 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x559947a32e48 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f1846193d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f1846193e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x559947a32f94 in _start (/dockerin/fuzz_drivers/tf1729571827258uqxw.out+0x45f94)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-22 04:36:53\n// Signature: YAML::Scanner::ScanBlockScalar()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner15ScanBlockScalarEv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/scanner.h\"\n#include <sstream>\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* fuzzStr = fuzzString(0);\n    std::istringstream inputStream(fuzzStr);\n    YAML::Scanner scanner(inputStream);\n    scanner.ScanBlockScalar();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scantoken.cpp\n 375: void Scanner::ScanBlockScalar() {\n 376:   std::string scalar;\n 377: \n 378:   ScanScalarParams params;\n 379:   params.indent = 1;\n 380:   params.detectIndent = true;\n 381: \n 382:   // eat block indicator ('|' or '>')\n 383:   Mark mark = INPUT.mark();\n 384:   char indicator = INPUT.get();\n 385:   params.fold = (indicator == Keys::FoldedScalar ? FOLD_BLOCK : DONT_FOLD);\n 386: \n 387:   // eat chomping/indentation indicators\n 388:   params.chomp = CLIP;\n 389:   int n = Exp::Chomp().Match(INPUT);\n 390:   for (int i = 0; i < n; i++) {\n 391:     char ch = INPUT.get();\n 392:     if (ch == '+')\n 393:       params.chomp = KEEP;\n 394:     else if (ch == '-')\n 395:       params.chomp = STRIP;\n 396:     else if (Exp::Digit().Matches(ch)) {\n 397:       if (ch == '0')\n 398:         throw ParserException(INPUT.mark(), ErrorMsg::ZERO_INDENT_IN_BLOCK);\n 399: \n 400:       params.indent = ch - '0';\n 401:       params.detectIndent = false;\n 402:     }\n 403:   }\n 404: \n 405:   // now eat whitespace\n 406:   while (Exp::Blank().Matches(INPUT))\n 407:     INPUT.eat(1);\n 408: \n 409:   // and comments to the end of the line\n 410:   if (Exp::Comment().Matches(INPUT))\n 411:     while (INPUT && !Exp::Break().Matches(INPUT))\n 412:       INPUT.eat(1);\n 413: \n 414:   // if it's not a line break, then we ran into a bad character inline\n 415:   if (INPUT && !Exp::Break().Matches(INPUT))\n 416:     throw ParserException(INPUT.mark(), ErrorMsg::CHAR_IN_BLOCK);\n 417: \n 418:   // set the initial indentation\n 419:   if (GetTopIndent() >= 0)\n 420:     params.indent += GetTopIndent();\n 421: \n 422:   params.eatLeadingWhitespace = false;\n 423:   params.trimTrailingSpaces = false;\n 424:   params.onTabInIndentation = THROW;\n 425: \n 426:   scalar = ScanScalar(INPUT, params);\n 427: \n 428:   // simple keys always ok after block scalars (since we're gonna start a new\n 429:   // line anyways)\n 430:   m_simpleKeyAllowed = true;\n 431:   m_canBeJSONFlow = false;\n 432: \n 433:   Token token(Token::NON_PLAIN_SCALAR, mark);\n 434:   token.value = scalar;\n 435:   m_tokens.push(token);\n 436: }\n 437:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fee69fe6f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55b635dbc329 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fee693cc51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fee694209fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fee693cc475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fee693b27f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fee69d93b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7fee69d9f20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7fee69d9f276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7fee69d9f4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x55b635dac8e6 in ghc::filesystem::create_directory_symlink(ghc::filesystem::path const&, ghc::filesystem::path const&) include/ghc/filesystem.hpp:4164\n    #11 0x55b635da81b3 in fuzzloop /dockerin/fuzz_drivers/tf1728370218698szbj.cpp:45\n    #12 0x55b635dbb529 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55b635da7a28 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7fee693b3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7fee693b3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55b635da7b74 in _start (/dockerin/fuzz_drivers/tf1728370218698szbj.out+0x20b74)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude/ghc\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZN3ghc10filesystem24create_directory_symlinkERKNS0_4pathES3_\n// Sign: ghc::filesystem::create_directory_symlink(path &to, path &new_symlink)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"include/ghc/filesystem.hpp\" //extract\n#include <cstring> //autogen\n\n//enum class portable_error {\n//    none = 0,\n//    exists,\n//    not_found,\n//    not_supported,\n//    not_implemented,\n//    invalid_argument,\n//    is_a_directory,\n//};\nghc::filesystem::detail::portable_error Fuzzghc_filesystem_detail_portable_error(uint64_t rand) {\n    // none=0 exists=1 not_found=2 not_supported=3 not_implemented=4\n    // invalid_argument=5 is_a_directory=6\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (ghc::filesystem::detail::portable_error)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    ghc::filesystem::detail::portable_error err = Fuzzghc_filesystem_detail_portable_error(enum_rand);\n    uint64_t enum_rand1 = fuzzUint64(1);\n    ghc::filesystem::detail::portable_error err1 = Fuzzghc_filesystem_detail_portable_error(enum_rand1);\n    std::error_code ec = ghc::filesystem::detail::make_error_code(err);\n    ghc::filesystem::path to = ghc::filesystem::current_path(ec);\n    std::error_code ec1 = ghc::filesystem::detail::make_error_code(err1);\n    ghc::filesystem::path new_symlink = ghc::filesystem::current_path(ec1);\n    ghc::filesystem::create_directory_symlink(to, new_symlink);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/ghc/filesystem.hpp\n4159: GHC_INLINE void create_directory_symlink(const path& to, const path& new_symlink)\n4160: {\n4161:     std::error_code ec;\n4162:     create_directory_symlink(to, new_symlink, ec);\n4163:     if (ec) {\n4164:         throw filesystem_error(detail::systemErrorText(ec.value()), to, new_symlink, ec);\n4165:     }\n4166: }\n4167:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f9145a26f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x561722c956f9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f914544351f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f91454979fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f9145443475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f91454297f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f91457d3b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f91457df20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f91457df276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f91457df4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x561722c0af0f in YAML::LoadFile(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/parse.cpp:35\n    #11 0x561722c0942f in fuzzloop /dockerin/fuzz_drivers/tf1729566972582yatb.cpp:25\n    #12 0x561722c948f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x561722c09078 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f914542ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f914542ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x561722c091c4 in _start (/dockerin/fuzz_drivers/tf1729566972582yatb.out+0x881c4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241021-2174542\n// Date: 2024-10-22 03:15:59\n// Signature: YAML::LoadFile(std::string &filename)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML8LoadFileERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"yaml-cpp/node/parse.h\" //extract\n#include <fstream> //extract\n#include <sstream> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string filename = fuzzString(0);\n    YAML::Node ret = YAML::LoadFile(filename);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/parse.cpp\n  32: Node LoadFile(const std::string& filename) {\n  33:   std::ifstream fin(filename);\n  34:   if (!fin) {\n  35:     throw BadFile(filename);\n  36:   }\n  37:   return Load(fin);\n  38: }\n  39:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f0b283f1f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x564cc0536f09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f0b27e0e51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f0b27e629fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f0b27e0e475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f0b27df47f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f0b2819eb9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f0b281aa20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f0b281aa276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f0b281aa4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x564cc0526186 in YAML::ScanTagSuffix[abi:cxx11](YAML::Stream&) /sourcecode/src/scantag.cpp:77\n    #11 0x564cc051836e in YAML::Scanner::ScanTag() /sourcecode/src/scantoken.cpp:286\n    #12 0x564cc04e7249 in fuzzloop /sharedockerin/ta1729063013902abwy/test_file.cpp:34\n    #13 0x564cc0536109 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #14 0x564cc04e6e68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #15 0x7f0b27df5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #16 0x7f0b27df5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #17 0x564cc04e6fb4 in _start (/sharedockerin/ta1729063013902abwy/clouditera+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Scanner::ScanTag()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner7ScanTagEv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream> //extract\n#include \"regex_yaml.h\" //extract\n#include \"regeximpl.h\" //extract\n#include \"scanscalar.h\" //extract\n#include \"scantag.h\"  // IWYU pragma: keep //extract\n#include \"tag.h\"      // IWYU pragma: keep //extract\n#include \"yaml-cpp/mark.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    scanner->ScanTag();\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scantag.cpp\n  65: const std::string ScanTagSuffix(Stream& INPUT) {\n  66:   std::string tag;\n  67: \n  68:   while (INPUT) {\n  69:     int n = Exp::Tag().Match(INPUT);\n  70:     if (n <= 0)\n  71:       break;\n  72: \n  73:     tag += INPUT.get(n);\n  74:   }\n  75: \n  76:   if (tag.empty())\n  77:     throw ParserException(INPUT.mark(), ErrorMsg::TAG_WITH_NO_SUFFIX);\n  78: \n  79:   return tag;\n  80: }\n  81: \nStacktrace #1:\nFile: /sourcecode/src/scantoken.cpp\n 256: void Scanner::ScanTag() {\n 257:   // insert a potential simple key\n 258:   InsertPotentialSimpleKey();\n 259:   m_simpleKeyAllowed = false;\n 260:   m_canBeJSONFlow = false;\n 261: \n 262:   Token token(Token::TAG, INPUT.mark());\n 263: \n 264:   // eat the indicator\n 265:   INPUT.get();\n 266: \n 267:   if (INPUT && INPUT.peek() == Keys::VerbatimTagStart) {\n 268:     std::string tag = ScanVerbatimTag(INPUT);\n 269: \n 270:     token.value = tag;\n 271:     token.data = Tag::VERBATIM;\n 272:   } else {\n 273:     bool canBeHandle;\n 274:     token.value = ScanTagHandle(INPUT, canBeHandle);\n 275:     if (!canBeHandle && token.value.empty())\n 276:       token.data = Tag::NON_SPECIFIC;\n 277:     else if (token.value.empty())\n 278:       token.data = Tag::SECONDARY_HANDLE;\n 279:     else\n 280:       token.data = Tag::PRIMARY_HANDLE;\n 281: \n 282:     // is there a suffix?\n 283:     if (canBeHandle && INPUT.peek() == Keys::Tag) {\n 284:       // eat the indicator\n 285:       INPUT.get();\n 286:       token.params.push_back(ScanTagSuffix(INPUT));\n 287:       token.data = Tag::NAMED_HANDLE;\n 288:     }\n 289:   }\n 290: \n 291:   m_tokens.push(token);\n 292: }\n 293:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "低危", "D": "高危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7ff9b9dc1f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55e62cc29749 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7ff9b97de51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7ff9b98329fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7ff9b97de475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7ff9b97c47f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7ff9b97c471a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7ff9b97d5e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55e62cbf39e6 in YAML::Emitter::FlowMapPrepareLongKeyValue(YAML::EmitterNodeType::value) /sourcecode/src/emitter.cpp:465\n    #9 0x55e62cbf0bee in fuzzloop /sharedockerin/ta1729587940610octr/test_file.cpp:19\n    #10 0x55e62cc28949 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x55e62cbf08e8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7ff9b97c5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7ff9b97c5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x55e62cbf0a34 in _start (/sharedockerin/ta1729587940610octr/clouditera+0x33a34)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 07:04:20\n// Signature: YAML::Emitter::FlowMapPrepareLongKeyValue(YAML::EmitterNodeType::value child)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Emitter26FlowMapPrepareLongKeyValueENS_15EmitterNodeType5valueE\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n\n#include \"include/yaml-cpp/yaml.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    YAML::Emitter emitter;\n    YAML::EmitterNodeType::value child = static_cast<YAML::EmitterNodeType::value>(fuzzInt8(0));\n    emitter.FlowMapPrepareLongKeyValue(child);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/emitter.cpp\n 442: void Emitter::FlowMapPrepareLongKeyValue(EmitterNodeType::value child) {\n 443:   const std::size_t lastIndent = m_pState->LastIndent();\n 444: \n 445:   if (!m_pState->HasBegunNode()) {\n 446:     if (m_stream.comment())\n 447:       m_stream << \"\\n\";\n 448:     m_stream << IndentTo(lastIndent);\n 449:     m_stream << \":\";\n 450:   }\n 451: \n 452:   switch (child) {\n 453:     case EmitterNodeType::NoType:\n 454:       break;\n 455:     case EmitterNodeType::Property:\n 456:     case EmitterNodeType::Scalar:\n 457:     case EmitterNodeType::FlowSeq:\n 458:     case EmitterNodeType::FlowMap:\n 459:       SpaceOrIndentTo(\n 460:           m_pState->HasBegunContent() || m_pState->CurGroupChildCount() > 0,\n 461:           lastIndent);\n 462:       break;\n 463:     case EmitterNodeType::BlockSeq:\n 464:     case EmitterNodeType::BlockMap:\n 465:       assert(false);\n 466:       break;\n 467:   }\n 468: }\n 469:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f6d092a4f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x559953282f69 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f6d088d851f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f6d0892c9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f6d088d8475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f6d088be7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f6d088be71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f6d088cfe95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55995319cf40 in fiobj_hash_replace /sourcecode/lib/facil/fiobj/fiobj_hash.c:240\n    #9 0x559953192340 in fuzzloop /dockerin/fuzz_drivers/tf1729828850384yvoy.c:25\n    #10 0x559953282169 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x559953191a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f6d088bfd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f6d088bfe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x559953191be4 in _start (/dockerin/fuzz_drivers/tf1729828850384yvoy.out+0x115be4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 04:00:28\n// Signature: fiobj_hash_replace(FIOBJ hash, FIOBJ key, FIOBJ obj)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_hash_replace\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <assert.h> //extract\n#include <fiobj_hash.h> //extract\n#include <fio.h> //extract\n#include <errno.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long hash = (unsigned long)fuzzUint64(0);\n    unsigned long key = (unsigned long)fuzzUint64(1);\n    unsigned long obj = (unsigned long)fuzzUint64(2);\n    FIOBJ ret = fiobj_hash_replace(hash, key, obj);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_hash.c\n 239: FIOBJ fiobj_hash_replace(FIOBJ hash, FIOBJ key, FIOBJ obj) {\n 240:   assert(hash && FIOBJ_TYPE_IS(hash, FIOBJ_T_HASH));\n 241:   FIOBJ old = FIOBJ_INVALID;\n 242:   fio_hash___insert(&obj2hash(hash)->hash, fiobj_obj2hash(key), key, obj, &old);\n 243:   fiobj_free(obj); /* take ownership - free the user's reference. */\n 244:   return old;\n 245: }\n 246:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f2428b3bf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55af92cf7f09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f242855851f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f24285ac9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f2428558475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f242853e7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f24288e8b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f24288f420b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f24288f4276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f24288f44d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x55af92cd7795 in YAML::Scanner::ScanKey() /sourcecode/src/scantoken.cpp:177\n    #11 0x55af92ca8249 in fuzzloop /dockerin/fuzz_drivers/tf1729580069731zwuq.cpp:33\n    #12 0x55af92cf7109 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55af92ca7e68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f242853fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f242853fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55af92ca7fb4 in _start (/dockerin/fuzz_drivers/tf1729580069731zwuq.out+0x49fb4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::Scanner::ScanKey()\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Scanner7ScanKeyEv\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream> //extract\n#include \"regex_yaml.h\" //extract\n#include \"regeximpl.h\" //extract\n#include \"scanscalar.h\" //extract\n#include \"scantag.h\"  // IWYU pragma: keep //extract\n#include \"tag.h\"      // IWYU pragma: keep //extract\n#include \"yaml-cpp/mark.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    scanner->ScanKey();\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/scantoken.cpp\n 173: void Scanner::ScanKey() {\n 174:   // handle keys differently in the block context (and manage indents)\n 175:   if (InBlockContext()) {\n 176:     if (!m_simpleKeyAllowed)\n 177:       throw ParserException(INPUT.mark(), ErrorMsg::MAP_KEY);\n 178: \n 179:     PushIndentTo(INPUT.column(), IndentMarker::MAP);\n 180:   }\n 181: \n 182:   // can only put a simple key here if we're in block context\n 183:   m_simpleKeyAllowed = InBlockContext();\n 184: \n 185:   // eat\n 186:   Mark mark = INPUT.mark();\n 187:   INPUT.eat(1);\n 188:   m_tokens.push(Token(Token::KEY, mark));\n 189: }\n 190:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fc3c13f4f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55f25f042a09 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fc3c0e1151f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fc3c0e659fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fc3c0e11475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fc3c0df77f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fc3c0df771a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7fc3c0e08e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55f25f032951 in void YAML::EmitterState::_Set<YAML::EMITTER_MANIP>(YAML::Setting<YAML::EMITTER_MANIP>&, YAML::EMITTER_MANIP, YAML::FmtScope::value) /sourcecode/src/emitterstate.h:211\n    #9 0x55f25f030149 in YAML::EmitterState::SetOutputCharset(YAML::EMITTER_MANIP, YAML::FmtScope::value) /sourcecode/src/emitterstate.cpp:246\n    #10 0x55f25f02ca84 in fuzzloop /sharedockerin/ta1729063013469qwlc/test_file.cpp:110\n    #11 0x55f25f041c09 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #12 0x55f25f02c568 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #13 0x7fc3c0df8d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #14 0x7fc3c0df8e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #15 0x55f25f02c6b4 in _start (/sharedockerin/ta1729063013469qwlc/clouditera+0x216b4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::EmitterState::SetOutputCharset(YAML::EMITTER_MANIP value, YAML::FmtScope::value scope)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML12EmitterState16SetOutputCharsetENS_13EMITTER_MANIPENS_8FmtScope5valueE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <limits> //extract\n#include \"emitterstate.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\n//enum EMITTER_MANIP {\n//  // general manipulators\n//  Auto,\n//  TagByKind,\n//  Newline,\n//\n//  // output character set\n//  EmitNonAscii,\n//  EscapeNonAscii,\n//  EscapeAsJson,\n//\n//  // string manipulators\n//  // Auto, // duplicate\n//  SingleQuoted,\n//  DoubleQuoted,\n//  Literal,\n//\n//  // null manipulators\n//  LowerNull,\n//  UpperNull,\n//  CamelNull,\n//  TildeNull,\n//\n//  // bool manipulators\n//  YesNoBool,      // yes, no\n//  TrueFalseBool,  // true, false\n//  OnOffBool,      // on, off\n//  UpperCase,      // TRUE, N\n//  LowerCase,      // f, yes\n//  CamelCase,      // No, Off\n//  LongBool,       // yes, On\n//  ShortBool,      // y, t\n//\n//  // int manipulators\n//  Dec,\n//  Hex,\n//  Oct,\n//\n//  // document manipulators\n//  BeginDoc,\n//  EndDoc,\n//\n//  // sequence manipulators\n//  BeginSeq,\n//  EndSeq,\n//  Flow,\n//  Block,\n//\n//  // map manipulators\n//  BeginMap,\n//  EndMap,\n//  Key,\n//  Value,\n//  // Flow, // duplicate\n//  // Block, // duplicate\n//  // Auto, // duplicate\n//  LongKey\n//};\nYAML::EMITTER_MANIP FuzzYAML_EMITTER_MANIP(uint64_t rand) {\n    // Auto=0 TagByKind=1 Newline=2 EmitNonAscii=3 EscapeNonAscii=4\n    // EscapeAsJson=5 SingleQuoted=6 DoubleQuoted=7 Literal=8\n    // LowerNull=9 UpperNull=10 CamelNull=11 TildeNull=12 YesNoBool=13\n    // TrueFalseBool=14 OnOffBool=15 UpperCase=16 LowerCase=17\n    // CamelCase=18 LongBool=19 ShortBool=20 Dec=21 Hex=22 Oct=23\n    // BeginDoc=24 EndDoc=25 BeginSeq=26 EndSeq=27 Flow=28 Block=29\n    // BeginMap=30 EndMap=31 Key=32 Value=33 LongKey=34\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::EMITTER_MANIP)values[index];\n}\n\n//  enum value { Local, Global };\nYAML::FmtScope::value FuzzYAML_FmtScope_value(uint64_t rand) {\n    // Local=0 Global=1\n    static uint64_t values[] = {0, 1, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::FmtScope::value)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    YAML::EMITTER_MANIP value = FuzzYAML_EMITTER_MANIP(enum_rand);\n    uint64_t enum_rand1 = fuzzUint64(1);\n    YAML::FmtScope::value scope = FuzzYAML_FmtScope_value(enum_rand1);\n    auto emitterstate = std::make_unique<YAML::EmitterState>();\n    emitterstate->SetOutputCharset(value, scope);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/emitterstate.h\n 201:     case FmtScope::Local:\n 202:       m_modifiedSettings.push(fmt.set(value));\n 203:       break;\n 204:     case FmtScope::Global:\n 205:       fmt.set(value);\n 206:       m_globalModifiedSettings.push(\n 207:           fmt.set(value));  // this pushes an identity set, so when we restore,\n 208:       // it restores to the value here, and not the previous one\n 209:       break;\n 210:     default:\n 211:       assert(false);\n 212:   }\n 213: }\n 214: }  // namespace YAML\n 215: \n 216: #endif  // EMITTERSTATE_H_62B23520_7C8E_11DE_8A39_0800200C9A66\n 217: \nStacktrace #1:\nFile: /sourcecode/src/emitterstate.cpp\n 240: bool EmitterState::SetOutputCharset(EMITTER_MANIP value,\n 241:                                     FmtScope::value scope) {\n 242:   switch (value) {\n 243:     case EmitNonAscii:\n 244:     case EscapeNonAscii:\n 245:     case EscapeAsJson:\n 246:       _Set(m_charset, value, scope);\n 247:       return true;\n 248:     default:\n 249:       return false;\n 250:   }\n 251: }\n 252:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "高危", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f4f4a308f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55a7ea1ceac9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f4f49d2551f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f4f49d799fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f4f49d25475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f4f49d0b7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f4f4a0b5b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f4f4a0c120b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f4f4a0c1276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f4f4a0c14d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x55a7ea1b2771 in YAML::detail::node_data::insert(YAML::detail::node&, YAML::detail::node&, std::shared_ptr<YAML::detail::memory_holder> const&) /sourcecode/src/node_data.cpp:203\n    #11 0x55a7ea1ae02a in fuzzloop /dockerin/fuzz_drivers/tf1729580657241xijt.cpp:33\n    #12 0x55a7ea1cdcc9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55a7ea1ada58 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f4f49d0cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f4f49d0ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55a7ea1adba4 in _start (/dockerin/fuzz_drivers/tf1729580657241xijt.out+0x2bba4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 07:03:50\n// Signature: YAML::detail::node_data::insert(node &key, node &value, shared_memory_holder &pMemory)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML6detail9node_data6insertERNS0_4nodeES3_RKSt10shared_ptrINS0_13memory_holderEE\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DYAML_CPP_STATIC_DEFINE -I. -I./include -I./src\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"include/yaml-cpp/yaml.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    YAML::detail::node_data data;\n    YAML::detail::node key;\n    YAML::detail::node value;\n    YAML::detail::shared_memory_holder pMemory;\n\n    char* fuzzTag = fuzzString(0);\n    data.set_tag(fuzzTag);\n\n    int8_t fuzzType = fuzzInt8(1);\n    data.set_type(static_cast<YAML::NodeType::value>(fuzzType));\n\n    char* fuzzScalar = fuzzString(2);\n    data.set_scalar(fuzzScalar);\n\n    int8_t fuzzStyle = fuzzInt8(3);\n    data.set_style(static_cast<YAML::EmitterStyle::value>(fuzzStyle));\n\n    data.insert(key, value, pMemory);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/node_data.cpp\n 192: void node_data::insert(node& key, node& value,\n 193:                        const shared_memory_holder& pMemory) {\n 194:   switch (m_type) {\n 195:     case NodeType::Map:\n 196:       break;\n 197:     case NodeType::Undefined:\n 198:     case NodeType::Null:\n 199:     case NodeType::Sequence:\n 200:       convert_to_map(pMemory);\n 201:       break;\n 202:     case NodeType::Scalar:\n 203:       throw BadSubscript(m_mark, key);\n 204:   }\n 205: \n 206:   insert_map_pair(key, value);\n 207: }\n 208:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fb2fbcc4f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55eca18806f9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fb2fb6e151f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fb2fb7359fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fb2fb6e1475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fb2fb6c77f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fb2fba71b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7fb2fba7d20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7fb2fba7d276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7fb2fba7d4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x55eca1816591 in YAML::SingleDocParser::LookupAnchor(YAML::Mark const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const /sourcecode/src/singledocparser.cpp:430\n    #11 0x55eca1810bd1 in YAML::SingleDocParser::HandleNode(YAML::EventHandler&) /sourcecode/src/singledocparser.cpp:72\n    #12 0x55eca1810113 in YAML::SingleDocParser::HandleDocument(YAML::EventHandler&) /sourcecode/src/singledocparser.cpp:41\n    #13 0x55eca1807663 in YAML::Parser::HandleNextDocument(YAML::EventHandler&) /sourcecode/src/parser.cpp:37\n    #14 0x55eca17f5b85 in YAML::Load(std::istream&) /sourcecode/src/parse.cpp:25\n    #15 0x55eca17f5534 in YAML::Load(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /sourcecode/src/parse.cpp:14\n    #16 0x55eca17f442f in fuzzloop /sharedockerin/ta1729581130068cuhz/test_file.cpp:25\n    #17 0x55eca187f8f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #18 0x55eca17f4078 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #19 0x7fb2fb6c8d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #20 0x7fb2fb6c8e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #21 0x55eca17f41c4 in _start (/sharedockerin/ta1729581130068cuhz/clouditera+0x881c4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:21\n// Signature: YAML::Load(std::string &input)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML4LoadERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"yaml-cpp/node/parse.h\" //extract\n#include <fstream> //extract\n#include <sstream> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" int fuzzloop() {\n    std::string input = fuzzString(0);\n    YAML::Node ret = YAML::Load(input);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/singledocparser.cpp\n 424: anchor_t SingleDocParser::LookupAnchor(const Mark& mark,\n 425:                                        const std::string& name) const {\n 426:   auto it = m_anchors.find(name);\n 427:   if (it == m_anchors.end()) {\n 428:     std::stringstream ss;\n 429:     ss << ErrorMsg::UNKNOWN_ANCHOR << name;\n 430:     throw ParserException(mark, ss.str());\n 431:   }\n 432: \n 433:   return it->second;\n 434: }\n 435: \nStacktrace #1:\nFile: /sourcecode/src/singledocparser.cpp\n  50: void SingleDocParser::HandleNode(EventHandler& eventHandler) {\n  51:   DepthGuard<500> depthguard(depth, m_scanner.mark(), ErrorMsg::BAD_FILE);\n  52: \n  53:   // an empty node *is* a possibility\n  54:   if (m_scanner.empty()) {\n  55:     eventHandler.OnNull(m_scanner.mark(), NullAnchor);\n  56:     return;\n  57:   }\n  58: \n  59:   // save location\n  60:   Mark mark = m_scanner.peek().mark;\n  61: \n  62:   // special case: a value node by itself must be a map, with no header\n  63:   if (m_scanner.peek().type == Token::VALUE) {\n  64:     eventHandler.OnMapStart(mark, \"?\", NullAnchor, EmitterStyle::Default);\n  65:     HandleMap(eventHandler);\n  66:     eventHandler.OnMapEnd();\n  67:     return;\n  68:   }\n  69: \n  70:   // special case: an alias node\n  71:   if (m_scanner.peek().type == Token::ALIAS) {\n  72:     eventHandler.OnAlias(mark, LookupAnchor(mark, m_scanner.peek().value));\n  73:     m_scanner.pop();\n  74:     return;\n  75:   }\n  76: \n  77:   std::string tag;\n  78:   std::string anchor_name;\n  79:   anchor_t anchor;\n  80:   ParseProperties(tag, anchor, anchor_name);\n  81: \n  82:   if (!anchor_name.empty())\n  83:     eventHandler.OnAnchor(mark, anchor_name);\n  84: \n  85:   // after parsing properties, an empty node is again a possibility\n  86:   if (m_scanner.empty()) {\n  87:     eventHandler.OnNull(mark, anchor);\n  88:     return;\n  89:   }\n  90: \n  91:   const Token& token = m_scanner.peek();\n  92: \n  93:   // add non-specific tags\n  94:   if (tag.empty())\n  95:     tag = (token.type == Token::NON_PLAIN_SCALAR ? \"!\" : \"?\");\n  96:   \n  97:   if (token.type == Token::PLAIN_SCALAR \n  98:       && tag.compare(\"?\") == 0 && IsNullString(token.value)) {\n  99:     eventHandler.OnNull(mark, anchor);\n 100:     m_scanner.pop();\n 101:     return;\n 102:   }\n 103: \n 104:   // now split based on what kind of node we should be\n 105:   switch (token.type) {\n 106:     case Token::PLAIN_SCALAR:\n 107:     case Token::NON_PLAIN_SCALAR:\n 108:       eventHandler.OnScalar(mark, tag, anchor, token.value);\n 109:       m_scanner.pop();\n 110:       return;\n 111:     case Token::FLOW_SEQ_START:\n 112:       eventHandler.OnSequenceStart(mark, tag, anchor, EmitterStyle::Flow);\n 113:       HandleSequence(eventHandler);\n 114:       eventHandler.OnSequenceEnd();\n 115:       return;\n 116:     case Token::BLOCK_SEQ_START:\n 117:       eventHandler.OnSequenceStart(mark, tag, anchor, EmitterStyle::Block);\n 118:       HandleSequence(eventHandler);\n 119:       eventHandler.OnSequenceEnd();\n 120:       return;\n 121:     case Token::FLOW_MAP_START:\n 122:       eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Flow);\n 123:       HandleMap(eventHandler);\n 124:       eventHandler.OnMapEnd();\n 125:       return;\n 126:     case Token::BLOCK_MAP_START:\n 127:       eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Block);\n 128:       HandleMap(eventHandler);\n 129:       eventHandler.OnMapEnd();\n 130:       return;\n 131:     case Token::KEY:\n 132:       // compact maps can only go in a flow sequence\n 133:       if (m_pCollectionStack->GetCurCollectionType() ==\n 134:           CollectionType::FlowSeq) {\n 135:         eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Flow);\n 136:         HandleMap(eventHandler);\n 137:         eventHandler.OnMapEnd();\n 138:         return;\n 139:       }\n 140:       break;\n 141:     default:\n 142:       break;\n 143:   }\n 144: \n 145:   if (tag == \"?\")\n 146:     eventHandler.OnNull(mark, anchor);\n 147:   else\n 148:     eventHandler.OnScalar(mark, tag, anchor, \"\");\n 149: }\n 150: \nStacktrace #2:\nFile: /sourcecode/src/singledocparser.cpp\n  30: void SingleDocParser::HandleDocument(EventHandler& eventHandler) {\n  31:   assert(!m_scanner.empty());  // guaranteed that there are tokens\n  32:   assert(!m_curAnchor);\n  33: \n  34:   eventHandler.OnDocumentStart(m_scanner.peek().mark);\n  35: \n  36:   // eat doc start\n  37:   if (m_scanner.peek().type == Token::DOC_START)\n  38:     m_scanner.pop();\n  39: \n  40:   // recurse!\n  41:   HandleNode(eventHandler);\n  42: \n  43:   eventHandler.OnDocumentEnd();\n  44: \n  45:   // and finally eat any doc ends we see\n  46:   while (!m_scanner.empty() && m_scanner.peek().type == Token::DOC_END)\n  47:     m_scanner.pop();\n  48: }\n  49: \nStacktrace #3:\nFile: /sourcecode/src/parser.cpp\n  27: bool Parser::HandleNextDocument(EventHandler& eventHandler) {\n  28:   if (!m_pScanner)\n  29:     return false;\n  30: \n  31:   ParseDirectives();\n  32:   if (m_pScanner->empty()) {\n  33:     return false;\n  34:   }\n  35: \n  36:   SingleDocParser sdp(*m_pScanner, *m_pDirectives);\n  37:   sdp.HandleDocument(eventHandler);\n  38:   return true;\n  39: }\n  40: \nStacktrace #4:\nFile: /sourcecode/src/parse.cpp\n  22: Node Load(std::istream& input) {\n  23:   Parser parser(input);\n  24:   NodeBuilder builder;\n  25:   if (!parser.HandleNextDocument(builder)) {\n  26:     return Node();\n  27:   }\n  28: \n  29:   return builder.Root();\n  30: }\n  31: \nStacktrace #5:\nFile: /sourcecode/src/parse.cpp\n  12: Node Load(const std::string& input) {\n  13:   std::stringstream stream(input);\n  14:   return Load(stream);\n  15: }\n  16:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f8c7a207f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55cf69283099 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f8c79c2451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f8c79c789fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f8c79c24475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f8c79c0a7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f8c79c0a71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f8c79c1be95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55cf69253da2 in YAML::EmitterState::ForceFlow() /sourcecode/src/emitterstate.cpp:74\n    #9 0x55cf6924bc4e in YAML::Emitter::EmitEndSeq() /sourcecode/src/emitter.cpp:211\n    #10 0x55cf6924aee6 in YAML::Emitter::SetLocalValue(YAML::EMITTER_MANIP) /sourcecode/src/emitter.cpp:114\n    #11 0x55cf69249d0b in fuzzloop /sharedockerin/ta1729063014331wont/test_file.cpp:102\n    #12 0x55cf69282299 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55cf69249908 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f8c79c0bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f8c79c0be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55cf69249a54 in _start (/sharedockerin/ta1729063014331wont/clouditera+0x34a54)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Emitter::SetLocalValue(YAML::EMITTER_MANIP value)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML7Emitter13SetLocalValueENS_13EMITTER_MANIPE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <sstream> //extract\n#include \"emitterutils.h\" //extract\n#include \"indentation.h\"  // IWYU pragma: keep //extract\n#include \"yaml-cpp/emitter.h\" //extract\n#include \"yaml-cpp/emitterdef.h\" //extract\n#include \"yaml-cpp/emittermanip.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\n//enum EMITTER_MANIP {\n//  // general manipulators\n//  Auto,\n//  TagByKind,\n//  Newline,\n//\n//  // output character set\n//  EmitNonAscii,\n//  EscapeNonAscii,\n//  EscapeAsJson,\n//\n//  // string manipulators\n//  // Auto, // duplicate\n//  SingleQuoted,\n//  DoubleQuoted,\n//  Literal,\n//\n//  // null manipulators\n//  LowerNull,\n//  UpperNull,\n//  CamelNull,\n//  TildeNull,\n//\n//  // bool manipulators\n//  YesNoBool,      // yes, no\n//  TrueFalseBool,  // true, false\n//  OnOffBool,      // on, off\n//  UpperCase,      // TRUE, N\n//  LowerCase,      // f, yes\n//  CamelCase,      // No, Off\n//  LongBool,       // yes, On\n//  ShortBool,      // y, t\n//\n//  // int manipulators\n//  Dec,\n//  Hex,\n//  Oct,\n//\n//  // document manipulators\n//  BeginDoc,\n//  EndDoc,\n//\n//  // sequence manipulators\n//  BeginSeq,\n//  EndSeq,\n//  Flow,\n//  Block,\n//\n//  // map manipulators\n//  BeginMap,\n//  EndMap,\n//  Key,\n//  Value,\n//  // Flow, // duplicate\n//  // Block, // duplicate\n//  // Auto, // duplicate\n//  LongKey\n//};\nYAML::EMITTER_MANIP FuzzYAML_EMITTER_MANIP(uint64_t rand) {\n    // Auto=0 TagByKind=1 Newline=2 EmitNonAscii=3 EscapeNonAscii=4\n    // EscapeAsJson=5 SingleQuoted=6 DoubleQuoted=7 Literal=8\n    // LowerNull=9 UpperNull=10 CamelNull=11 TildeNull=12 YesNoBool=13\n    // TrueFalseBool=14 OnOffBool=15 UpperCase=16 LowerCase=17\n    // CamelCase=18 LongBool=19 ShortBool=20 Dec=21 Hex=22 Oct=23\n    // BeginDoc=24 EndDoc=25 BeginSeq=26 EndSeq=27 Flow=28 Block=29\n    // BeginMap=30 EndMap=31 Key=32 Value=33 LongKey=34\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::EMITTER_MANIP)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    YAML::EMITTER_MANIP value = FuzzYAML_EMITTER_MANIP(enum_rand);\n    auto emitter = std::make_unique<YAML::Emitter>();\n    emitter->SetLocalValue(value);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/emitterstate.cpp\n  73: void EmitterState::ForceFlow() {\n  74:   assert(!m_groups.empty());\n  75:   if (m_groups.empty()) {\n  76:     return;\n  77:   }\n  78: \n  79:   m_groups.back()->flowType = FlowType::Flow;\n  80: }\n  81: \nStacktrace #1:\nFile: /sourcecode/src/emitter.cpp\n 205: void Emitter::EmitEndSeq() {\n 206:   if (!good())\n 207:     return;\n 208:   FlowType::value originalType = m_pState->CurGroupFlowType();\n 209: \n 210:   if (m_pState->CurGroupChildCount() == 0)\n 211:     m_pState->ForceFlow();\n 212: \n 213:   if (m_pState->CurGroupFlowType() == FlowType::Flow) {\n 214:     if (m_stream.comment())\n 215:       m_stream << \"\\n\";\n 216:     if (originalType == FlowType::Block || m_pState->HasBegunNode())\n 217:       m_stream << IndentTo(m_pState->CurIndent());\n 218:     if (originalType == FlowType::Block) {\n 219:       m_stream << \"[\";\n 220:     } else {\n 221:       if (m_pState->CurGroupChildCount() == 0 && !m_pState->HasBegunNode())\n 222:         m_stream << \"[\";\n 223:     }\n 224:     m_stream << \"]\";\n 225:   }\n 226: \n 227:   m_pState->EndedGroup(GroupType::Seq);\n 228: }\n 229: \nStacktrace #2:\nFile: /sourcecode/src/emitter.cpp\n  99: Emitter& Emitter::SetLocalValue(EMITTER_MANIP value) {\n 100:   if (!good())\n 101:     return *this;\n 102: \n 103:   switch (value) {\n 104:     case BeginDoc:\n 105:       EmitBeginDoc();\n 106:       break;\n 107:     case EndDoc:\n 108:       EmitEndDoc();\n 109:       break;\n 110:     case BeginSeq:\n 111:       EmitBeginSeq();\n 112:       break;\n 113:     case EndSeq:\n 114:       EmitEndSeq();\n 115:       break;\n 116:     case BeginMap:\n 117:       EmitBeginMap();\n 118:       break;\n 119:     case EndMap:\n 120:       EmitEndMap();\n 121:       break;\n 122:     case Key:\n 123:     case Value:\n 124:       // deprecated (these can be deduced by the parity of nodes in a map)\n 125:       break;\n 126:     case TagByKind:\n 127:       EmitKindTag();\n 128:       break;\n 129:     case Newline:\n 130:       EmitNewline();\n 131:       break;\n 132:     default:\n 133:       m_pState->SetLocalValue(value);\n 134:       break;\n 135:   }\n 136:   return *this;\n 137: }\n 138:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fc701292f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x563d4d8e8b49 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fc700caf51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fc700d039fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fc700caf475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fc700c957f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fc70103fb9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7fc70104b20b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7fc70104b276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7fc70104b4d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x563d4d87df09 in YAML::SingleDocParser::ParseTag(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /sourcecode/src/singledocparser.cpp:400\n    #11 0x563d4d87dcae in YAML::SingleDocParser::ParseProperties(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, unsigned long&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /sourcecode/src/singledocparser.cpp:386\n    #12 0x563d4d8790f6 in YAML::SingleDocParser::HandleNode(YAML::EventHandler&) /sourcecode/src/singledocparser.cpp:80\n    #13 0x563d4d87853d in YAML::SingleDocParser::HandleDocument(YAML::EventHandler&) /sourcecode/src/singledocparser.cpp:41\n    #14 0x563d4d86fa8d in YAML::Parser::HandleNextDocument(YAML::EventHandler&) /sourcecode/src/parser.cpp:37\n    #15 0x563d4d85dfaf in YAML::Load(std::istream&) /sourcecode/src/parse.cpp:25\n    #16 0x563d4d85dcc5 in YAML::Load(char const*) /sourcecode/src/parse.cpp:19\n    #17 0x563d4d85d272 in fuzzloop /sharedockerin/ta1729063014324apvy/test_file.cpp:26\n    #18 0x563d4d8e7d49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #19 0x563d4d85cf38 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #20 0x7fc700c96d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #21 0x7fc700c96e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #22 0x563d4d85d084 in _start (/sharedockerin/ta1729063014324apvy/clouditera+0x87084)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-56ea8a1\n// Date: 2024-10-16 06:59:14\n// Signature: YAML::Load(char *input)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML4LoadEPKc\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"yaml-cpp/node/parse.h\" //extract\n#include <fstream> //extract\n#include <sstream> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    char * input = fuzzString(0);\n    YAML::Node ret = YAML::Load(input);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/singledocparser.cpp\n 397: void SingleDocParser::ParseTag(std::string& tag) {\n 398:   Token& token = m_scanner.peek();\n 399:   if (!tag.empty())\n 400:     throw ParserException(token.mark, ErrorMsg::MULTIPLE_TAGS);\n 401: \n 402:   Tag tagInfo(token);\n 403:   tag = tagInfo.Translate(m_directives);\n 404:   m_scanner.pop();\n 405: }\n 406: \nStacktrace #1:\nFile: /sourcecode/src/singledocparser.cpp\n 374: void SingleDocParser::ParseProperties(std::string& tag, anchor_t& anchor,\n 375:                                       std::string& anchor_name) {\n 376:   tag.clear();\n 377:   anchor_name.clear();\n 378:   anchor = NullAnchor;\n 379: \n 380:   while (true) {\n 381:     if (m_scanner.empty())\n 382:       return;\n 383: \n 384:     switch (m_scanner.peek().type) {\n 385:       case Token::TAG:\n 386:         ParseTag(tag);\n 387:         break;\n 388:       case Token::ANCHOR:\n 389:         ParseAnchor(anchor, anchor_name);\n 390:         break;\n 391:       default:\n 392:         return;\n 393:     }\n 394:   }\n 395: }\n 396: \nStacktrace #2:\nFile: /sourcecode/src/singledocparser.cpp\n  50: void SingleDocParser::HandleNode(EventHandler& eventHandler) {\n  51:   DepthGuard<500> depthguard(depth, m_scanner.mark(), ErrorMsg::BAD_FILE);\n  52: \n  53:   // an empty node *is* a possibility\n  54:   if (m_scanner.empty()) {\n  55:     eventHandler.OnNull(m_scanner.mark(), NullAnchor);\n  56:     return;\n  57:   }\n  58: \n  59:   // save location\n  60:   Mark mark = m_scanner.peek().mark;\n  61: \n  62:   // special case: a value node by itself must be a map, with no header\n  63:   if (m_scanner.peek().type == Token::VALUE) {\n  64:     eventHandler.OnMapStart(mark, \"?\", NullAnchor, EmitterStyle::Default);\n  65:     HandleMap(eventHandler);\n  66:     eventHandler.OnMapEnd();\n  67:     return;\n  68:   }\n  69: \n  70:   // special case: an alias node\n  71:   if (m_scanner.peek().type == Token::ALIAS) {\n  72:     eventHandler.OnAlias(mark, LookupAnchor(mark, m_scanner.peek().value));\n  73:     m_scanner.pop();\n  74:     return;\n  75:   }\n  76: \n  77:   std::string tag;\n  78:   std::string anchor_name;\n  79:   anchor_t anchor;\n  80:   ParseProperties(tag, anchor, anchor_name);\n  81: \n  82:   if (!anchor_name.empty())\n  83:     eventHandler.OnAnchor(mark, anchor_name);\n  84: \n  85:   // after parsing properties, an empty node is again a possibility\n  86:   if (m_scanner.empty()) {\n  87:     eventHandler.OnNull(mark, anchor);\n  88:     return;\n  89:   }\n  90: \n  91:   const Token& token = m_scanner.peek();\n  92: \n  93:   // add non-specific tags\n  94:   if (tag.empty())\n  95:     tag = (token.type == Token::NON_PLAIN_SCALAR ? \"!\" : \"?\");\n  96:   \n  97:   if (token.type == Token::PLAIN_SCALAR \n  98:       && tag.compare(\"?\") == 0 && IsNullString(token.value)) {\n  99:     eventHandler.OnNull(mark, anchor);\n 100:     m_scanner.pop();\n 101:     return;\n 102:   }\n 103: \n 104:   // now split based on what kind of node we should be\n 105:   switch (token.type) {\n 106:     case Token::PLAIN_SCALAR:\n 107:     case Token::NON_PLAIN_SCALAR:\n 108:       eventHandler.OnScalar(mark, tag, anchor, token.value);\n 109:       m_scanner.pop();\n 110:       return;\n 111:     case Token::FLOW_SEQ_START:\n 112:       eventHandler.OnSequenceStart(mark, tag, anchor, EmitterStyle::Flow);\n 113:       HandleSequence(eventHandler);\n 114:       eventHandler.OnSequenceEnd();\n 115:       return;\n 116:     case Token::BLOCK_SEQ_START:\n 117:       eventHandler.OnSequenceStart(mark, tag, anchor, EmitterStyle::Block);\n 118:       HandleSequence(eventHandler);\n 119:       eventHandler.OnSequenceEnd();\n 120:       return;\n 121:     case Token::FLOW_MAP_START:\n 122:       eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Flow);\n 123:       HandleMap(eventHandler);\n 124:       eventHandler.OnMapEnd();\n 125:       return;\n 126:     case Token::BLOCK_MAP_START:\n 127:       eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Block);\n 128:       HandleMap(eventHandler);\n 129:       eventHandler.OnMapEnd();\n 130:       return;\n 131:     case Token::KEY:\n 132:       // compact maps can only go in a flow sequence\n 133:       if (m_pCollectionStack->GetCurCollectionType() ==\n 134:           CollectionType::FlowSeq) {\n 135:         eventHandler.OnMapStart(mark, tag, anchor, EmitterStyle::Flow);\n 136:         HandleMap(eventHandler);\n 137:         eventHandler.OnMapEnd();\n 138:         return;\n 139:       }\n 140:       break;\n 141:     default:\n 142:       break;\n 143:   }\n 144: \n 145:   if (tag == \"?\")\n 146:     eventHandler.OnNull(mark, anchor);\n 147:   else\n 148:     eventHandler.OnScalar(mark, tag, anchor, \"\");\n 149: }\n 150: \nStacktrace #3:\nFile: /sourcecode/src/singledocparser.cpp\n  30: void SingleDocParser::HandleDocument(EventHandler& eventHandler) {\n  31:   assert(!m_scanner.empty());  // guaranteed that there are tokens\n  32:   assert(!m_curAnchor);\n  33: \n  34:   eventHandler.OnDocumentStart(m_scanner.peek().mark);\n  35: \n  36:   // eat doc start\n  37:   if (m_scanner.peek().type == Token::DOC_START)\n  38:     m_scanner.pop();\n  39: \n  40:   // recurse!\n  41:   HandleNode(eventHandler);\n  42: \n  43:   eventHandler.OnDocumentEnd();\n  44: \n  45:   // and finally eat any doc ends we see\n  46:   while (!m_scanner.empty() && m_scanner.peek().type == Token::DOC_END)\n  47:     m_scanner.pop();\n  48: }\n  49: \nStacktrace #4:\nFile: /sourcecode/src/parser.cpp\n  27: bool Parser::HandleNextDocument(EventHandler& eventHandler) {\n  28:   if (!m_pScanner)\n  29:     return false;\n  30: \n  31:   ParseDirectives();\n  32:   if (m_pScanner->empty()) {\n  33:     return false;\n  34:   }\n  35: \n  36:   SingleDocParser sdp(*m_pScanner, *m_pDirectives);\n  37:   sdp.HandleDocument(eventHandler);\n  38:   return true;\n  39: }\n  40: \nStacktrace #5:\nFile: /sourcecode/src/parse.cpp\n  22: Node Load(std::istream& input) {\n  23:   Parser parser(input);\n  24:   NodeBuilder builder;\n  25:   if (!parser.HandleNextDocument(builder)) {\n  26:     return Node();\n  27:   }\n  28: \n  29:   return builder.Root();\n  30: }\n  31: \nStacktrace #6:\nFile: /sourcecode/src/parse.cpp\n  17: Node Load(const char* input) {\n  18:   std::stringstream stream(input);\n  19:   return Load(stream);\n  20: }\n  21:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "中危", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f1cdf848f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x563e61c4b899 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f1cdf26551f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f1cdf2b99fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f1cdf265475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f1cdf24b7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f1cdf5f5b9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f1cdf60120b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f1cdf601276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f1cdf6014d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x563e61be3fcb in YAML::Parser::HandleTagDirective(YAML::Token const&) /sourcecode/src/parser.cpp:98\n    #11 0x563e61bdf688 in fuzzloop /dockerin/fuzz_drivers/tf1729580069713kkub.cpp:73\n    #12 0x563e61c4aa99 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x563e61bdf028 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f1cdf24cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f1cdf24ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x563e61bdf174 in _start (/dockerin/fuzz_drivers/tf1729580069713kkub.out+0x67174)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 06:54:20\n// Signature: YAML::Parser::HandleTagDirective(Token &token)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML6Parser18HandleTagDirectiveERKNS_5TokenE\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE -fno-access-control\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cstdio> //extract\n#include <sstream> //extract\n#include \"directives.h\"  // IWYU pragma: keep //extract\n#include \"scanner.h\"     // IWYU pragma: keep //extract\n#include \"singledocparser.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include \"yaml-cpp/parser.h\" //extract\n#include <cassert> //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include <cstring> //autogen\n\n//  enum TYPE {\n//    DIRECTIVE,\n//    DOC_START,\n//    DOC_END,\n//    BLOCK_SEQ_START,\n//    BLOCK_MAP_START,\n//    BLOCK_SEQ_END,\n//    BLOCK_MAP_END,\n//    BLOCK_ENTRY,\n//    FLOW_SEQ_START,\n//    FLOW_MAP_START,\n//    FLOW_SEQ_END,\n//    FLOW_MAP_END,\n//    FLOW_MAP_COMPACT,\n//    FLOW_ENTRY,\n//    KEY,\n//    VALUE,\n//    ANCHOR,\n//    ALIAS,\n//    TAG,\n//    PLAIN_SCALAR,\n//    NON_PLAIN_SCALAR\n//  };\nYAML::Token::TYPE FuzzYAML_Token_TYPE(uint64_t rand) {\n    // DIRECTIVE=0 DOC_START=1 DOC_END=2 BLOCK_SEQ_START=3 BLOCK_MAP_START=4\n    // BLOCK_SEQ_END=5 BLOCK_MAP_END=6 BLOCK_ENTRY=7 FLOW_SEQ_START=8\n    // FLOW_MAP_START=9 FLOW_SEQ_END=10 FLOW_MAP_END=11 FLOW_MAP_COMPACT=12\n    // FLOW_ENTRY=13 KEY=14 VALUE=15 ANCHOR=16 ALIAS=17 TAG=18\n    // PLAIN_SCALAR=19 NON_PLAIN_SCALAR=20\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (YAML::Token::TYPE)values[index];\n}\n\nextern \"C\" int fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    YAML::Token::TYPE type_ = FuzzYAML_Token_TYPE(enum_rand);\n    auto parser = std::make_unique<YAML::Parser>();\n    std::string temp = fuzzString(1);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    YAML::Mark mark_ = scanner->mark();\n    YAML::Token token(type_, mark_);\n    parser->HandleTagDirective(token);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/parser.cpp\n  96: void Parser::HandleTagDirective(const Token& token) {\n  97:   if (token.params.size() != 2)\n  98:     throw ParserException(token.mark, ErrorMsg::TAG_DIRECTIVE_ARGS);\n  99: \n 100:   const std::string& handle = token.params[0];\n 101:   const std::string& prefix = token.params[1];\n 102:   if (m_pDirectives->tags.find(handle) != m_pDirectives->tags.end()) {\n 103:     throw ParserException(token.mark, ErrorMsg::REPEATED_TAG_DIRECTIVE);\n 104:   }\n 105: \n 106:   m_pDirectives->tags[handle] = prefix;\n 107: }\n 108:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "高危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f9f1e63cf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x56073e8e8849 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f9f1da2251f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f9f1da769fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f9f1da22475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f9f1da087f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x56073e815c81 in testing::internal::posix::Abort() /sourcecode/build/googletest-source/googletest/include/gtest/internal/gtest-port.h:2102\n    #7 0x56073e771aa0 in testing::TestPartResultArray::GetTestPartResult(int) const /sourcecode/build/googletest-source/googletest/src/gtest-test-part.cc:72\n    #8 0x56073e742ff9 in fuzzloop /dockerin/fuzz_drivers/tf1728877392065aant.cpp:21\n    #9 0x56073e8e7a49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x56073e742cc8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7f9f1da09d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7f9f1da09e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x56073e742e14 in _start (/dockerin/fuzz_drivers/tf1728877392065aant.out+0x275e14)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ibuild/googletest-source/googletest/include -Ibuild/googletest-source/googletest -Ibuild/googletest-source/googletest/include/gtest -Ibuild/googletest-source/googletest/src -DGTEST_HAS_PTHREAD=1\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZNK7testing19TestPartResultArray17GetTestPartResultEi\n// Sign: testing::TestPartResultArray::GetTestPartResult(int index)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"build/googletest-source/googletest/include/gtest/gtest-test-part.h\" //extract\n#include <memory> //autogen\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto testpartresultarray = std::make_unique<testing::TestPartResultArray>();\n    int index = fuzzInt32(0);\n    testpartresultarray->GetTestPartResult(index);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/build/googletest-source/googletest/include/gtest/internal/gtest-port.h\n2102: [[noreturn]] inline void Abort() { abort(); }\n2103: \nStacktrace #1:\nFile: /sourcecode/build/googletest-source/googletest/src/gtest-test-part.cc\n  69: const TestPartResult& TestPartResultArray::GetTestPartResult(int index) const {\n  70:   if (index < 0 || index >= size()) {\n  71:     printf(\"\\nInvalid index (%d) into TestPartResultArray.\\n\", index);\n  72:     internal::posix::Abort();\n  73:   }\n  74: \n  75:   return array_[static_cast<size_t>(index)];\n  76: }\n  77:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f0d3104af18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55855f5e79b9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f0d3067e51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f0d306d29fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f0d3067e475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f0d306647f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f0d3066471a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f0d30675e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x55855f501bea in fiobj_hash_pop /sourcecode/lib/facil/fiobj/fiobj_hash.c:219\n    #9 0x55855f4f7333 in fuzzloop /dockerin/fuzz_drivers/tf1729675748868dvxd.c:23\n    #10 0x55855f5e6bb9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x55855f4f6a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f0d30665d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f0d30665e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x55855f4f6be4 in _start (/dockerin/fuzz_drivers/tf1729675748868dvxd.out+0x115be4)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n// Version: dev-v2.4.5-20241014-c950afb\n// Target: fiobj_hash_pop\n// Sign: fiobj_hash_pop(FIOBJ hash, FIOBJ *key)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fiobject.h> //extract\n#include <assert.h> //extract\n#include <fiobj_hash.h> //extract\n#include <fio.h> //extract\n#include <errno.h> //extract\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned long hash = (unsigned long)fuzzUint64(0);\n    unsigned long * key = (long *)fuzzFixBlob(1, 1 * sizeof(unsigned long));\n    FIOBJ ret = fiobj_hash_pop(hash, key);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_hash.c\n 218: FIOBJ fiobj_hash_pop(FIOBJ hash, FIOBJ *key) {\n 219:   assert(hash && FIOBJ_TYPE_IS(hash, FIOBJ_T_HASH));\n 220:   FIOBJ old;\n 221:   if (fio_hash___count(&obj2hash(hash)->hash))\n 222:     return FIOBJ_INVALID;\n 223:   old = fiobj_dup(fio_hash___last(&obj2hash(hash)->hash).obj);\n 224:   if (key)\n 225:     *key = fiobj_dup(fio_hash___last(&obj2hash(hash)->hash).key);\n 226:   fio_hash___pop(&obj2hash(hash)->hash);\n 227:   return old;\n 228: }\n 229:\n崩溃的严重程度是什么？", "A": "不确定", "B": "中危", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f0e5d927f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5609b9e77ab9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f0e5d34451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f0e5d3989fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f0e5d344475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f0e5d32a7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f0e5d32a71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f0e5d33be95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x5609b9e0d8b8 in YAML::NodeBuilder::RegisterAnchor(unsigned long, YAML::detail::node&) /sourcecode/src/nodebuilder.cpp:130\n    #9 0x5609b9e0ce57 in YAML::NodeBuilder::Push(YAML::Mark const&, unsigned long) /sourcecode/src/nodebuilder.cpp:83\n    #10 0x5609b9e0cac3 in YAML::NodeBuilder::OnNull(YAML::Mark const&, unsigned long) /sourcecode/src/nodebuilder.cpp:36\n    #11 0x5609b9e094b5 in fuzzloop /dockerin/fuzz_drivers/tf1729044067442rtub.cpp:36\n    #12 0x5609b9e76cb9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x5609b9e08f58 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f0e5d32bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f0e5d32be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x5609b9e090a4 in _start (/dockerin/fuzz_drivers/tf1729044067442rtub.out+0x6b0a4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241016-12962a0\n// Date: 2024-10-16 02:00:58\n// Signature: YAML::NodeBuilder::OnNull(Mark &mark, anchor_t anchor)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN4YAML11NodeBuilder6OnNullERKNS_4MarkEm\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude -Isrc -DYAML_CPP_STATIC_DEFINE\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <cassert> //extract\n#include \"nodebuilder.h\" //extract\n#include \"yaml-cpp/node/detail/node.h\" //extract\n#include \"yaml-cpp/node/impl.h\" //extract\n#include \"yaml-cpp/node/node.h\" //extract\n#include \"yaml-cpp/node/type.h\" //extract\n#include <memory> //extract\n#include \"exp.h\" //extract\n#include \"scanner.h\" //extract\n#include \"token.h\" //extract\n#include \"yaml-cpp/exceptions.h\"  // IWYU pragma: keep //extract\n#include <sstream>\n#include <cstring> //autogen\n\nextern \"C\" {\nint fuzzloop() {\n    auto nodebuilder = std::make_unique<YAML::NodeBuilder>();\n    std::string temp = fuzzString(0);\n    std::istringstream in(temp);\n    auto scanner = std::make_unique<YAML::Scanner>(in);\n    YAML::Mark mark = scanner->mark();\n    unsigned long anchor = (unsigned long)fuzzUint64(1);\n    nodebuilder->OnNull(mark, anchor);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nodebuilder.cpp\n 128: void NodeBuilder::RegisterAnchor(anchor_t anchor, detail::node& node) {\n 129:   if (anchor) {\n 130:     assert(anchor == m_anchors.size());\n 131:     m_anchors.push_back(&node);\n 132:   }\n 133: }\n 134: \nStacktrace #1:\nFile: /sourcecode/src/nodebuilder.cpp\n  80: detail::node& NodeBuilder::Push(const Mark& mark, anchor_t anchor) {\n  81:   detail::node& node = m_pMemory->create_node();\n  82:   node.set_mark(mark);\n  83:   RegisterAnchor(anchor, node);\n  84:   Push(node);\n  85:   return node;\n  86: }\n  87: \nStacktrace #2:\nFile: /sourcecode/src/nodebuilder.cpp\n  35: void NodeBuilder::OnNull(const Mark& mark, anchor_t anchor) {\n  36:   detail::node& node = Push(mark, anchor);\n  37:   node.set_null();\n  38:   Pop();\n  39: }\n  40:\n崩溃的严重程度是什么？", "A": "低危", "B": "不确定", "C": "高危", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f5f4e548f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x560b37c85629 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f5f4d92e51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f5f4d9829fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f5f4d92e475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f5f4d9147f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x560b37b4c8fb in google::LogMessage::Fail() /sourcecode/src/logging.cc:1885\n    #7 0x560b37c706b8 in google::RawLog__(google::LogSeverity, char const*, int, char const*, ...) /sourcecode/src/raw_logging.cc:206\n    #8 0x560b37b47d57 in google::LogMessage::SendToLog() /sourcecode/src/logging.cc:1773\n    #9 0x560b37b2931c in fuzzloop /dockerin/fuzz_drivers/tf1728609773580dlzy.cpp:73\n    #10 0x560b37c84829 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x560b37b28f68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f5f4d915d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f5f4d915e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x560b37b290b4 in _start (/dockerin/fuzz_drivers/tf1728609773580dlzy.out+0x2130b4)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Isrc -Ibuild -DGLOG_NO_SYMBOLIZE_DETECTION -DGLOG_USE_GLOG_EXPORT -DGOOGLE_GLOG_IS_A_DLL\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZN6google10LogMessage9SendToLogEv\n// Sign: google::LogMessage::SendToLog()\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"glog/logging.h\" //extract\n#include <algorithm> //extract\n#include <cassert> //extract\n#include <chrono> //extract\n#include <cstddef> //extract\n#include <cstdint> //extract\n#include <iomanip> //extract\n#include <iterator> //extract\n#include <memory> //extract\n#include <mutex> //extract\n#include <shared_mutex> //extract\n#include <string> //extract\n#include <thread> //extract\n#include <tuple> //extract\n#include <type_traits> //extract\n#include <utility> //extract\n#include \"config.h\" //extract\n#include \"glog/platform.h\" //extract\n#include \"glog/raw_logging.h\" //extract\n#include \"stacktrace.h\" //extract\n#include \"utilities.h\" //extract\n#  include <dirent.h>  // for automatic removal of old logs //extract\n#include <fcntl.h> //extract\n#include <sys/stat.h> //extract\n#include <cctype>  // for std::isspace //extract\n#include <cerrno>  // for errno //extract\n#include <climits> //extract\n#include <cstdarg> //extract\n#include <cstdio> //extract\n#include <cstdlib> //extract\n#include <ctime> //extract\n#include <regex> //extract\n#include <sstream> //extract\n#include <vector> //extract\n#  include <pwd.h> //extract\n#  include <sys/utsname.h>  // For uname. //extract\n#  include <syslog.h> //extract\n#  include <sys/types.h> //extract\n#  include <unistd.h> //extract\nusing std::dec; //extract\nusing std::hex; //extract\nusing std::min; //extract\nusing std::ostream; //extract\nusing std::ostringstream; //extract\nusing std::setfill; //extract\nusing std::setw; //extract\nusing std::string; //extract\nusing std::vector; //extract\nusing std::fclose; //extract\nusing std::fflush; //extract\nusing std::FILE; //extract\nusing std::fprintf; //extract\nusing std::fwrite; //extract\nusing std::perror; //extract\n\nextern \"C\" {\nint fuzzloop() {\n    char * file = fuzzString(0);\n    int line = fuzzInt32(1);\n    auto logmessage = std::make_unique<google::LogMessage>(file, line);\n    logmessage->SendToLog();\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/logging.cc\n1885: void LogMessage::Fail() { g_logging_fail_func(); }\n1886: \nStacktrace #1:\nFile: /sourcecode/src/raw_logging.cc\n 146: GLOG_ATTRIBUTE_FORMAT(printf, 4, 5)\n 147: void RawLog__(LogSeverity severity, const char* file, int line,\n 148:               const char* format, ...) {\n 149:   if (!(FLAGS_logtostdout || FLAGS_logtostderr ||\n 150:         severity >= FLAGS_stderrthreshold || FLAGS_alsologtostderr ||\n 151:         !IsGoogleLoggingInitialized())) {\n 152:     return;  // this stderr log message is suppressed\n 153:   }\n 154: \n 155:   // We do not have any any option other that string streams to obtain the\n 156:   // thread identifier as the corresponding value is not convertible to an\n 157:   // integer. Use a statically allocated buffer to avoid dynamic memory\n 158:   // allocations.\n 159:   StaticStringBuf<kLogBufSize> sbuf;\n 160:   std::ostream oss(&sbuf);\n 161: \n 162:   oss << std::setw(5) << std::this_thread::get_id();\n 163: \n 164:   // can't call localtime_r here: it can allocate\n 165:   char buffer[kLogBufSize];\n 166:   char* buf = buffer;\n 167:   size_t size = sizeof(buffer);\n 168: \n 169:   // NOTE: this format should match the specification in base/logging.h\n 170:   DoRawLog(&buf, &size, \"%c00000000 00:00:00.000000 %s %s:%d] RAW: \",\n 171:            GetLogSeverityName(severity)[0], sbuf.data(),\n 172:            const_basename(const_cast<char*>(file)), line);\n 173: \n 174:   // Record the position and size of the buffer after the prefix\n 175:   const char* msg_start = buf;\n 176:   const size_t msg_size = size;\n 177: \n 178:   va_list ap;\n 179:   va_start(ap, format);\n 180:   bool no_chop = VADoRawLog(&buf, &size, format, ap);\n 181:   va_end(ap);\n 182:   if (no_chop) {\n 183:     DoRawLog(&buf, &size, \"\\n\");\n 184:   } else {\n 185:     DoRawLog(&buf, &size, \"RAW_LOG ERROR: The Message was too long!\\n\");\n 186:   }\n 187:   // We make a raw syscall to write directly to the stderr file descriptor,\n 188:   // avoiding FILE buffering (to avoid invoking malloc()), and bypassing\n 189:   // libc (to side-step any libc interception).\n 190:   // We write just once to avoid races with other invocations of RawLog__.\n 191:   safe_write(fileno(stderr), buffer, strlen(buffer));\n 192:   if (severity == GLOG_FATAL) {\n 193:     std::call_once(crashed, [file, line, msg_start, msg_size] {\n 194:       crash_reason.filename = file;\n 195:       crash_reason.line_number = line;\n 196:       memcpy(crash_buf, msg_start, msg_size);  // Don't include prefix\n 197:       crash_reason.message = crash_buf;\n 198: #ifdef HAVE_STACKTRACE\n 199:       crash_reason.depth =\n 200:           GetStackTrace(crash_reason.stack, ARRAYSIZE(crash_reason.stack), 1);\n 201: #else\n 202:       crash_reason.depth = 0;\n 203: #endif\n 204:       SetCrashReason(&crash_reason);\n 205:     });\n 206:     LogMessage::Fail();  // abort()\n 207:   }\n 208: }\n 209: \nStacktrace #2:\nFile: /sourcecode/src/logging.cc\n1770: void LogMessage::SendToLog() EXCLUSIVE_LOCKS_REQUIRED(log_mutex) {\n1771:   static bool already_warned_before_initgoogle = false;\n1772: \n1773:   RAW_DCHECK(data_->num_chars_to_log_ > 0 &&\n1774:                  data_->message_text_[data_->num_chars_to_log_ - 1] == '\\n',\n1775:              \"\");\n1776: \n1777:   // Messages of a given severity get logged to lower severity logs, too\n1778: \n1779:   if (!already_warned_before_initgoogle && !IsGoogleLoggingInitialized()) {\n1780:     const char w[] =\n1781:         \"WARNING: Logging before InitGoogleLogging() is \"\n1782:         \"written to STDERR\\n\";\n1783:     WriteToStderr(w, strlen(w));\n1784:     already_warned_before_initgoogle = true;\n1785:   }\n1786: \n1787:   // global flag: never log to file if set.  Also -- don't log to a\n1788:   // file if we haven't parsed the command line flags to get the\n1789:   // program name.\n1790:   if (FLAGS_logtostderr || FLAGS_logtostdout || !IsGoogleLoggingInitialized()) {\n1791:     if (FLAGS_logtostdout) {\n1792:       ColoredWriteToStdout(data_->severity_, data_->message_text_,\n1793:                            data_->num_chars_to_log_);\n1794:     } else {\n1795:       ColoredWriteToStderr(data_->severity_, data_->message_text_,\n1796:                            data_->num_chars_to_log_);\n1797:     }\n1798: \n1799:     // this could be protected by a flag if necessary.\n1800:     LogDestination::LogToSinks(\n1801:         data_->severity_, data_->fullname_, data_->basename_, data_->line_,\n1802:         time_, data_->message_text_ + data_->num_prefix_chars_,\n1803:         (data_->num_chars_to_log_ - data_->num_prefix_chars_ - 1));\n1804:   } else {\n1805:     // log this message to all log files of severity <= severity_\n1806:     LogDestination::LogToAllLogfiles(data_->severity_, time_.when(),\n1807:                                      data_->message_text_,\n1808:                                      data_->num_chars_to_log_);\n1809: \n1810:     LogDestination::MaybeLogToStderr(data_->severity_, data_->message_text_,\n1811:                                      data_->num_chars_to_log_,\n1812:                                      data_->num_prefix_chars_);\n1813:     LogDestination::MaybeLogToEmail(data_->severity_, data_->message_text_,\n1814:                                     data_->num_chars_to_log_);\n1815:     LogDestination::LogToSinks(\n1816:         data_->severity_, data_->fullname_, data_->basename_, data_->line_,\n1817:         time_, data_->message_text_ + data_->num_prefix_chars_,\n1818:         (data_->num_chars_to_log_ - data_->num_prefix_chars_ - 1));\n1819:     // NOTE: -1 removes trailing \\n\n1820:   }\n1821: \n1822:   // If we log a FATAL message, flush all the log destinations, then toss\n1823:   // a signal for others to catch. We leave the logs in a state that\n1824:   // someone else can use them (as long as they flush afterwards)\n1825:   if (data_->severity_ == GLOG_FATAL && exit_on_dfatal) {\n1826:     if (data_->first_fatal_) {\n1827:       // Store crash information so that it is accessible from within signal\n1828:       // handlers that may be invoked later.\n1829:       RecordCrashReason(&crash_reason);\n1830:       SetCrashReason(&crash_reason);\n1831: \n1832:       // Store shortened fatal message for other logs and GWQ status\n1833:       const size_t copy =\n1834:           min(data_->num_chars_to_log_, sizeof(fatal_message) - 1);\n1835:       memcpy(fatal_message, data_->message_text_, copy);\n1836:       fatal_message[copy] = '\\0';\n1837:       fatal_time = time_.when();\n1838:     }\n1839: \n1840:     if (!FLAGS_logtostderr && !FLAGS_logtostdout) {\n1841:       for (auto& log_destination : LogDestination::log_destinations_) {\n1842:         if (log_destination) {\n1843:           log_destination->logger_->Write(\n1844:               true, std::chrono::system_clock::time_point{}, \"\", 0);\n1845:         }\n1846:       }\n1847:     }\n1848: \n1849:     LogDestination::WaitForSinks(data_);\n1850:   }\n1851: }\n1852:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f374b14ef18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55a2e91db549 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f374a53451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f374a5889fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f374a534475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f374a51a7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f374a51a71a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f374a52be95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x7f374a589ed0  (/lib/x86_64-linux-gnu/libc.so.6+0x97ed0)\n    #9 0x55a2e91a5900 in Communicator::reply_idle_conn(CommSession*, CommTarget*) /sourcecode/src/kernel/Communicator.cc:1711\n    #10 0x55a2e918023c in fuzzloop /dockerin/fuzz_drivers/tf1729655176919ewhu.cpp:47\n    #11 0x55a2e91da749 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #12 0x55a2e917fbb8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #13 0x7f374a51bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #14 0x7f374a51be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #15 0x55a2e917fd04 in _start (/dockerin/fuzz_drivers/tf1729655176919ewhu.out+0x86d04)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:01\n// Signature: Communicator::reply_idle_conn(CommSession *session, CommTarget *target)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator15reply_idle_connEP11CommSessionP10CommTarget\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/Communicator.h\"\n\n// Derived class to implement the pure virtual functions of CommSession\nclass FuzzCommSession : public CommSession {\npublic:\n    FuzzCommSession() : CommSession() {}\n\n    // Implement the pure virtual functions\n    virtual CommMessageOut* message_out() override {\n        return this->out;\n    }\n\n    virtual CommMessageIn* message_in() override {\n        return this->in;\n    }\n\n    virtual void handle(int state, int error) override {\n        // Implement the handle function as needed\n    }\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    Communicator comm;\n    FuzzCommSession session; // Use the derived class\n    CommTarget target;\n\n    char* fuzzData1 = fuzzData(0);\n    int fuzzLen1 = fuzzGetLen(0);\n    char* fuzzData2 = fuzzData(1);\n    int fuzzLen2 = fuzzGetLen(1);\n\n    session.out = (CommMessageOut*)fuzzData1;\n    session.in = (CommMessageIn*)fuzzData2;\n\n    comm.reply_idle_conn(&session, &target);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1705: int Communicator::reply_idle_conn(CommSession *session, CommTarget *target)\n1706: {\n1707: \tstruct CommConnEntry *entry;\n1708: \tstruct list_head *pos;\n1709: \tint ret = -1;\n1710: \n1711: \tpthread_mutex_lock(&target->mutex);\n1712: \tif (!list_empty(&target->idle_list))\n1713: \t{\n1714: \t\tpos = target->idle_list.next;\n1715: \t\tentry = list_entry(pos, struct CommConnEntry, list);\n1716: \t\tlist_del(pos);\n1717: \n1718: \t\tsession->out = session->message_out();\n1719: \t\tif (session->out)\n1720: \t\t\tret = this->send_message(entry);\n1721: \n1722: \t\tif (ret < 0)\n1723: \t\t{\n1724: \t\t\tentry->error = errno;\n1725: \t\t\tmpoller_del(entry->sockfd, this->mpoller);\n1726: \t\t\tentry->state = CONN_STATE_ERROR;\n1727: \t\t\tret = 1;\n1728: \t\t}\n1729: \t}\n1730: \telse\n1731: \t\terrno = ENOENT;\n1732: \n1733: \tpthread_mutex_unlock(&target->mutex);\n1734: \treturn ret;\n1735: }\n1736:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f2565fd7f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x560a10fa2f49 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f256560b51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f256565f9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f256560b475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f25655f17f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f25655f171a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f2565602e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x560a10ebec9a in fiobj_data_assert_dynamic /sourcecode/lib/facil/fiobj/fiobj_data.c:946\n    #9 0x560a10eb2319 in fuzzloop /dockerin/fuzz_drivers/tf1729828200326dsme.c:28\n    #10 0x560a10fa2149 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #11 0x560a10eb1a98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #12 0x7f25655f2d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #13 0x7f25655f2e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #14 0x560a10eb1be4 in _start (/dockerin/fuzz_drivers/tf1729828200326dsme.out+0x115be4)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-25 03:49:50\n// Signature: fiobj_data_assert_dynamic(FIOBJ io)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fiobj_data_assert_dynamic\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Ilib -Ilib/facil -Ilib/facil/tls -Ilib/facil/fiobj -Ilib/facil/cli -Ilib/facil/http -Ilib/facil/http/parsers -Ilib/facil/redis\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include <fio_tmpfile.h> //extract\n#include <fiobj_data.h> //extract\n#include <fiobj_str.h> //extract\n#include <assert.h> //extract\n#include <errno.h> //extract\n#include <fcntl.h> //extract\n#include <string.h> //extract\n#include <sys/stat.h> //extract\n#include <sys/types.h> //extract\n#include <unistd.h> //extract\n#include <fio.h> //extract\n\nint fuzzloop() {\n    unsigned long io = (unsigned long)fuzzUint64(0);\n    fiobj_data_assert_dynamic(io);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fiobj/fiobj_data.c\n 941: void fiobj_data_assert_dynamic(FIOBJ io) {\n 942:   if (!io) {\n 943:     errno = ENFILE;\n 944:     return;\n 945:   }\n 946:   assert(FIOBJ_TYPE(io) == FIOBJ_T_DATA);\n 947:   fiobj_data_pre_write(io, 0);\n 948:   return;\n 949: }\n 950:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f0d11c3df18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x559df9d7eba9 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f0d1102351f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f0d110779fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f0d11023475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f0d110097f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f0d119eab9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7f0d119f620b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7f0d119f6276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7f0d119f64d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x559df9d5abd1 in ghc::filesystem::copy(ghc::filesystem::path const&, ghc::filesystem::path const&, ghc::filesystem::copy_options) include/ghc/filesystem.hpp:3802\n    #11 0x559df9d4691a in fuzzloop /dockerin/fuzz_drivers/tf1728370218707fsag.cpp:76\n    #12 0x559df9d7dda9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x559df9d45e98 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f0d1100ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f0d1100ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x559df9d45fe4 in _start (/dockerin/fuzz_drivers/tf1728370218707fsag.out+0x4efe4)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Iinclude/ghc\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZN3ghc10filesystem4copyERKNS0_4pathES3_NS0_12copy_optionsE\n// Sign: ghc::filesystem::copy(path &from, path &to, ghc::filesystem::copy_options options)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"include/ghc/filesystem.hpp\" //extract\n#include <cstring> //autogen\n\n//enum class portable_error {\n//    none = 0,\n//    exists,\n//    not_found,\n//    not_supported,\n//    not_implemented,\n//    invalid_argument,\n//    is_a_directory,\n//};\nghc::filesystem::detail::portable_error Fuzzghc_filesystem_detail_portable_error(uint64_t rand) {\n    // none=0 exists=1 not_found=2 not_supported=3 not_implemented=4\n    // invalid_argument=5 is_a_directory=6\n    static uint64_t values[] = {0, 1, 2, 3, 4, 5, 6, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (ghc::filesystem::detail::portable_error)values[index];\n}\n\n//enum class copy_options : uint16_t {\n//    none = 0,\n//\n//    skip_existing = 1,\n//    overwrite_existing = 2,\n//    update_existing = 4,\n//\n//    recursive = 8,\n//\n//    copy_symlinks = 0x10,\n//    skip_symlinks = 0x20,\n//\n//    directories_only = 0x40,\n//    create_symlinks = 0x80,\n//#ifndef GHC_OS_WEB\n//    create_hard_links = 0x100\n//#endif\n//};\nghc::filesystem::copy_options Fuzzghc_filesystem_copy_options(uint64_t rand) {\n    // none=0 skip_existing=1 overwrite_existing=2 update_existing=4\n    // recursive=8 copy_symlinks=16 skip_symlinks=32 directories_only=64\n    // create_symlinks=128 create_hard_links=256\n    static uint64_t values[] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, (uint64_t)-1};\n    int size = sizeof(values) / sizeof(values[0]);\n    values[size - 1] = rand;\n    int index = rand % size;\n    return (ghc::filesystem::copy_options)values[index];\n}\n\nextern \"C\" {\nint fuzzloop() {\n    uint64_t enum_rand = fuzzUint64(0);\n    ghc::filesystem::detail::portable_error err = Fuzzghc_filesystem_detail_portable_error(enum_rand);\n    uint64_t enum_rand1 = fuzzUint64(1);\n    ghc::filesystem::detail::portable_error err1 = Fuzzghc_filesystem_detail_portable_error(enum_rand1);\n    uint64_t enum_rand2 = fuzzUint64(2);\n    ghc::filesystem::copy_options options = Fuzzghc_filesystem_copy_options(enum_rand2);\n    std::error_code ec = ghc::filesystem::detail::make_error_code(err);\n    ghc::filesystem::path from = ghc::filesystem::current_path(ec);\n    std::error_code ec1 = ghc::filesystem::detail::make_error_code(err1);\n    ghc::filesystem::path to = ghc::filesystem::current_path(ec1);\n    ghc::filesystem::copy(from, to, options);\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/include/ghc/filesystem.hpp\n3797: GHC_INLINE void copy(const path& from, const path& to, copy_options options)\n3798: {\n3799:     std::error_code ec;\n3800:     copy(from, to, options, ec);\n3801:     if (ec) {\n3802:         throw filesystem_error(detail::systemErrorText(ec.value()), from, to, ec);\n3803:     }\n3804: }\n3805:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f56d62e8f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55ca48badc19 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f56d56ce51f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f56d57229fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f56d56ce475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f56d56b47f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7f56d56b471a  (/lib/x86_64-linux-gnu/libc.so.6+0x2871a)\n    #7 0x7f56d56c5e95 in __assert_fail (/lib/x86_64-linux-gnu/libc.so.6+0x39e95)\n    #8 0x7f56d5729138  (/lib/x86_64-linux-gnu/libc.so.6+0x9d138)\n    #9 0x7f56d57239cc  (/lib/x86_64-linux-gnu/libc.so.6+0x979cc)\n    #10 0x55ca48b4fbb4 in CommSchedGroup::add(CommSchedTarget*) /sourcecode/src/kernel/CommScheduler.cc:350\n    #11 0x55ca48b441a1 in fuzzloop /sharedockerin/ta1729664332015nekb/test_file.cpp:20\n    #12 0x55ca48bace19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #13 0x55ca48b43bd8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #14 0x7f56d56b5d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #15 0x7f56d56b5e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #16 0x55ca48b43d24 in _start (/sharedockerin/ta1729664332015nekb/clouditera+0x9ed24)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:45:12\n// Signature: CommSchedGroup::remove(CommSchedTarget *target)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN14CommSchedGroup6removeEP15CommSchedTarget\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/CommScheduler.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    CommSchedGroup group;\n    CommSchedTarget target;\n\n    group.init();\n    target.init(NULL, 0, fuzzInt32(0), fuzzInt32(1), fuzzUint32(2));\n    group.add(&target);\n\n    group.remove(&target);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/CommScheduler.cc\n 346: int CommSchedGroup::add(CommSchedTarget *target)\n 347: {\n 348: \tint ret = -1;\n 349: \n 350: \tpthread_mutex_lock(&target->mutex);\n 351: \tpthread_mutex_lock(&this->mutex);\n 352: \tif (target->group == NULL && target->wait_cnt == 0)\n 353: \t{\n 354: \t\tif (this->heap_insert(target) >= 0)\n 355: \t\t{\n 356: \t\t\ttarget->group = this;\n 357: \t\t\tthis->max_load += target->max_load;\n 358: \t\t\tthis->cur_load += target->cur_load;\n 359: \t\t\tif (this->wait_cnt > 0 && this->cur_load < this->max_load)\n 360: \t\t\t\tpthread_cond_signal(&this->cond);\n 361: \n 362: \t\t\tret = 0;\n 363: \t\t}\n 364: \t}\n 365: \telse if (target->group == this)\n 366: \t\terrno = EEXIST;\n 367: \telse if (target->group)\n 368: \t\terrno = EINVAL;\n 369: \telse\n 370: \t\terrno = EBUSY;\n 371: \n 372: \tpthread_mutex_unlock(&this->mutex);\n 373: \tpthread_mutex_unlock(&target->mutex);\n 374: \treturn ret;\n 375: }\n 376:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f36edabff18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x5631b206a629 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f36ecea551f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f36ecef99fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f36ecea5475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f36ece8b7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x5631b1f318fb in google::LogMessage::Fail() /sourcecode/src/logging.cc:1885\n    #7 0x5631b20556b8 in google::RawLog__(google::LogSeverity, char const*, int, char const*, ...) /sourcecode/src/raw_logging.cc:206\n    #8 0x5631b1f2cd57 in google::LogMessage::SendToLog() /sourcecode/src/logging.cc:1773\n    #9 0x5631b1f33468 in google::LogMessage::SaveOrSendToLog() /sourcecode/src/logging.cc:1917\n    #10 0x5631b1f0e31c in fuzzloop /dockerin/fuzz_drivers/tf1728368481825daan.cpp:73\n    #11 0x5631b2069829 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #12 0x5631b1f0df68 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #13 0x7f36ece8cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #14 0x7f36ece8ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #15 0x5631b1f0e0b4 in _start (/dockerin/fuzz_drivers/tf1728368481825daan.out+0x2130b4)\n模糊测试驱动如下：\n// Language=C++\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Isrc -Ibuild -DGLOG_NO_SYMBOLIZE_DETECTION -DGLOG_USE_GLOG_EXPORT -DGOOGLE_GLOG_IS_A_DLL -fno-access-control\n// Version: dev-v2.4.5-20240925-06d3cce\n// Target: _ZN6google10LogMessage15SaveOrSendToLogEv\n// Sign: google::LogMessage::SaveOrSendToLog()\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"glog/logging.h\" //extract\n#include <algorithm> //extract\n#include <cassert> //extract\n#include <chrono> //extract\n#include <cstddef> //extract\n#include <cstdint> //extract\n#include <iomanip> //extract\n#include <iterator> //extract\n#include <memory> //extract\n#include <mutex> //extract\n#include <shared_mutex> //extract\n#include <string> //extract\n#include <thread> //extract\n#include <tuple> //extract\n#include <type_traits> //extract\n#include <utility> //extract\n#include \"config.h\" //extract\n#include \"glog/platform.h\" //extract\n#include \"glog/raw_logging.h\" //extract\n#include \"stacktrace.h\" //extract\n#include \"utilities.h\" //extract\n#  include <dirent.h>  // for automatic removal of old logs //extract\n#include <fcntl.h> //extract\n#include <sys/stat.h> //extract\n#include <cctype>  // for std::isspace //extract\n#include <cerrno>  // for errno //extract\n#include <climits> //extract\n#include <cstdarg> //extract\n#include <cstdio> //extract\n#include <cstdlib> //extract\n#include <ctime> //extract\n#include <regex> //extract\n#include <sstream> //extract\n#include <vector> //extract\n#  include <pwd.h> //extract\n#  include <sys/utsname.h>  // For uname. //extract\n#  include <syslog.h> //extract\n#  include <sys/types.h> //extract\n#  include <unistd.h> //extract\nusing std::dec; //extract\nusing std::hex; //extract\nusing std::min; //extract\nusing std::ostream; //extract\nusing std::ostringstream; //extract\nusing std::setfill; //extract\nusing std::setw; //extract\nusing std::string; //extract\nusing std::vector; //extract\nusing std::fclose; //extract\nusing std::fflush; //extract\nusing std::FILE; //extract\nusing std::fprintf; //extract\nusing std::fwrite; //extract\nusing std::perror; //extract\n\nextern \"C\" {\nint fuzzloop() {\n    char * file = fuzzString(0);\n    int line = fuzzInt32(1);\n    auto logmessage = std::make_unique<google::LogMessage>(file, line);\n    logmessage->SaveOrSendToLog();\n    return 0;\n}\n} /* extern \"C\" */\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/logging.cc\n1885: void LogMessage::Fail() { g_logging_fail_func(); }\n1886: \nStacktrace #1:\nFile: /sourcecode/src/raw_logging.cc\n 146: GLOG_ATTRIBUTE_FORMAT(printf, 4, 5)\n 147: void RawLog__(LogSeverity severity, const char* file, int line,\n 148:               const char* format, ...) {\n 149:   if (!(FLAGS_logtostdout || FLAGS_logtostderr ||\n 150:         severity >= FLAGS_stderrthreshold || FLAGS_alsologtostderr ||\n 151:         !IsGoogleLoggingInitialized())) {\n 152:     return;  // this stderr log message is suppressed\n 153:   }\n 154: \n 155:   // We do not have any any option other that string streams to obtain the\n 156:   // thread identifier as the corresponding value is not convertible to an\n 157:   // integer. Use a statically allocated buffer to avoid dynamic memory\n 158:   // allocations.\n 159:   StaticStringBuf<kLogBufSize> sbuf;\n 160:   std::ostream oss(&sbuf);\n 161: \n 162:   oss << std::setw(5) << std::this_thread::get_id();\n 163: \n 164:   // can't call localtime_r here: it can allocate\n 165:   char buffer[kLogBufSize];\n 166:   char* buf = buffer;\n 167:   size_t size = sizeof(buffer);\n 168: \n 169:   // NOTE: this format should match the specification in base/logging.h\n 170:   DoRawLog(&buf, &size, \"%c00000000 00:00:00.000000 %s %s:%d] RAW: \",\n 171:            GetLogSeverityName(severity)[0], sbuf.data(),\n 172:            const_basename(const_cast<char*>(file)), line);\n 173: \n 174:   // Record the position and size of the buffer after the prefix\n 175:   const char* msg_start = buf;\n 176:   const size_t msg_size = size;\n 177: \n 178:   va_list ap;\n 179:   va_start(ap, format);\n 180:   bool no_chop = VADoRawLog(&buf, &size, format, ap);\n 181:   va_end(ap);\n 182:   if (no_chop) {\n 183:     DoRawLog(&buf, &size, \"\\n\");\n 184:   } else {\n 185:     DoRawLog(&buf, &size, \"RAW_LOG ERROR: The Message was too long!\\n\");\n 186:   }\n 187:   // We make a raw syscall to write directly to the stderr file descriptor,\n 188:   // avoiding FILE buffering (to avoid invoking malloc()), and bypassing\n 189:   // libc (to side-step any libc interception).\n 190:   // We write just once to avoid races with other invocations of RawLog__.\n 191:   safe_write(fileno(stderr), buffer, strlen(buffer));\n 192:   if (severity == GLOG_FATAL) {\n 193:     std::call_once(crashed, [file, line, msg_start, msg_size] {\n 194:       crash_reason.filename = file;\n 195:       crash_reason.line_number = line;\n 196:       memcpy(crash_buf, msg_start, msg_size);  // Don't include prefix\n 197:       crash_reason.message = crash_buf;\n 198: #ifdef HAVE_STACKTRACE\n 199:       crash_reason.depth =\n 200:           GetStackTrace(crash_reason.stack, ARRAYSIZE(crash_reason.stack), 1);\n 201: #else\n 202:       crash_reason.depth = 0;\n 203: #endif\n 204:       SetCrashReason(&crash_reason);\n 205:     });\n 206:     LogMessage::Fail();  // abort()\n 207:   }\n 208: }\n 209: \nStacktrace #2:\nFile: /sourcecode/src/logging.cc\n1770: void LogMessage::SendToLog() EXCLUSIVE_LOCKS_REQUIRED(log_mutex) {\n1771:   static bool already_warned_before_initgoogle = false;\n1772: \n1773:   RAW_DCHECK(data_->num_chars_to_log_ > 0 &&\n1774:                  data_->message_text_[data_->num_chars_to_log_ - 1] == '\\n',\n1775:              \"\");\n1776: \n1777:   // Messages of a given severity get logged to lower severity logs, too\n1778: \n1779:   if (!already_warned_before_initgoogle && !IsGoogleLoggingInitialized()) {\n1780:     const char w[] =\n1781:         \"WARNING: Logging before InitGoogleLogging() is \"\n1782:         \"written to STDERR\\n\";\n1783:     WriteToStderr(w, strlen(w));\n1784:     already_warned_before_initgoogle = true;\n1785:   }\n1786: \n1787:   // global flag: never log to file if set.  Also -- don't log to a\n1788:   // file if we haven't parsed the command line flags to get the\n1789:   // program name.\n1790:   if (FLAGS_logtostderr || FLAGS_logtostdout || !IsGoogleLoggingInitialized()) {\n1791:     if (FLAGS_logtostdout) {\n1792:       ColoredWriteToStdout(data_->severity_, data_->message_text_,\n1793:                            data_->num_chars_to_log_);\n1794:     } else {\n1795:       ColoredWriteToStderr(data_->severity_, data_->message_text_,\n1796:                            data_->num_chars_to_log_);\n1797:     }\n1798: \n1799:     // this could be protected by a flag if necessary.\n1800:     LogDestination::LogToSinks(\n1801:         data_->severity_, data_->fullname_, data_->basename_, data_->line_,\n1802:         time_, data_->message_text_ + data_->num_prefix_chars_,\n1803:         (data_->num_chars_to_log_ - data_->num_prefix_chars_ - 1));\n1804:   } else {\n1805:     // log this message to all log files of severity <= severity_\n1806:     LogDestination::LogToAllLogfiles(data_->severity_, time_.when(),\n1807:                                      data_->message_text_,\n1808:                                      data_->num_chars_to_log_);\n1809: \n1810:     LogDestination::MaybeLogToStderr(data_->severity_, data_->message_text_,\n1811:                                      data_->num_chars_to_log_,\n1812:                                      data_->num_prefix_chars_);\n1813:     LogDestination::MaybeLogToEmail(data_->severity_, data_->message_text_,\n1814:                                     data_->num_chars_to_log_);\n1815:     LogDestination::LogToSinks(\n1816:         data_->severity_, data_->fullname_, data_->basename_, data_->line_,\n1817:         time_, data_->message_text_ + data_->num_prefix_chars_,\n1818:         (data_->num_chars_to_log_ - data_->num_prefix_chars_ - 1));\n1819:     // NOTE: -1 removes trailing \\n\n1820:   }\n1821: \n1822:   // If we log a FATAL message, flush all the log destinations, then toss\n1823:   // a signal for others to catch. We leave the logs in a state that\n1824:   // someone else can use them (as long as they flush afterwards)\n1825:   if (data_->severity_ == GLOG_FATAL && exit_on_dfatal) {\n1826:     if (data_->first_fatal_) {\n1827:       // Store crash information so that it is accessible from within signal\n1828:       // handlers that may be invoked later.\n1829:       RecordCrashReason(&crash_reason);\n1830:       SetCrashReason(&crash_reason);\n1831: \n1832:       // Store shortened fatal message for other logs and GWQ status\n1833:       const size_t copy =\n1834:           min(data_->num_chars_to_log_, sizeof(fatal_message) - 1);\n1835:       memcpy(fatal_message, data_->message_text_, copy);\n1836:       fatal_message[copy] = '\\0';\n1837:       fatal_time = time_.when();\n1838:     }\n1839: \n1840:     if (!FLAGS_logtostderr && !FLAGS_logtostdout) {\n1841:       for (auto& log_destination : LogDestination::log_destinations_) {\n1842:         if (log_destination) {\n1843:           log_destination->logger_->Write(\n1844:               true, std::chrono::system_clock::time_point{}, \"\", 0);\n1845:         }\n1846:       }\n1847:     }\n1848: \n1849:     LogDestination::WaitForSinks(data_);\n1850:   }\n1851: }\n1852: \nStacktrace #3:\nFile: /sourcecode/src/logging.cc\n1907: void LogMessage::SaveOrSendToLog() EXCLUSIVE_LOCKS_REQUIRED(log_mutex) {\n1908:   if (data_->outvec_ != nullptr) {\n1909:     RAW_DCHECK(data_->num_chars_to_log_ > 0 &&\n1910:                    data_->message_text_[data_->num_chars_to_log_ - 1] == '\\n',\n1911:                \"\");\n1912:     // Omit prefix of message and trailing newline when recording in outvec_.\n1913:     const char* start = data_->message_text_ + data_->num_prefix_chars_;\n1914:     size_t len = data_->num_chars_to_log_ - data_->num_prefix_chars_ - 1;\n1915:     data_->outvec_->push_back(string(start, len));\n1916:   } else {\n1917:     SendToLog();\n1918:   }\n1919: }\n1920:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7f3bdaa5bf18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x561399428759 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7f3bda6c451f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7f3bda7189fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7f3bda6c4475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7f3bda6aa7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x56139925e0af in OpenSSLDie /sourcecode/crypto/cryptlib.c:919\n    #7 0x561399259cc0 in ssl3_cbc_copy_mac /sourcecode/ssl/s3_cbc.c:276\n    #8 0x561399259068 in fuzzloop /dockerin/fuzz_drivers/tf1728981988695iduw.c:44\n    #9 0x561399427959 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #10 0x561399258cc8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #11 0x7f3bda6abd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #12 0x7f3bda6abe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #13 0x561399258e14 in _start (/dockerin/fuzz_drivers/tf1728981988695iduw.out+0xa1e14)\n模糊测试驱动如下：\n// Language=C\n// Engine=clouditera\n// CFLAGS用于指定编译时的参数, 可以指定多个参数, 以空格分隔 \n// CFLAGS=-I. -Icrypto -Iinclude -Issl -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DL_ENDIAN -DTERMIO -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM\n// Version: dev-v2.4.6-20241015-543df72\n// Target: ssl3_cbc_copy_mac\n// Sign: ssl3_cbc_copy_mac(unsigned char *out, SSL3_RECORD *rec, unsigned int md_size, unsigned int orig_len)\n\n// 引入模糊测试相关头文件\n#include \"FuzzAgent.h\"\n\n// 引入被测接口相关头文件\n#include \"ssl_locl.h\" //extract\n#include <openssl/md5.h> //extract\n#include <openssl/sha.h> //extract\n#include \"include/openssl/ssl3.h\" //autogen\n#include <string.h> //autogen\n\nint fuzzloop() {\n    unsigned char * out = (unsigned char *)fuzzData(0);\n    //file: include/openssl/ssl3.h:348\n    //typedef struct ssl3_record_st\n    //\t{\n    ///*r */\tint type;               /* type of record */\n    ///*rw*/\tunsigned int length;    /* How many bytes available */\n    ///*r */\tunsigned int off;       /* read/write offset into 'buf' */\n    ///*rw*/\tunsigned char *data;    /* pointer to the record data */\n    ///*rw*/\tunsigned char *input;   /* where the decode bytes are */\n    ///*r */\tunsigned char *comp;    /* only used with decompression - malloc()ed */\n    ///*r */  unsigned long epoch;    /* epoch number, needed by DTLS1 */\n    ///*r */  unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */\n    //\t} SSL3_RECORD;\n    struct ssl3_record_st *rec = (struct ssl3_record_st *)driverAllocMem(sizeof(struct ssl3_record_st));\n    rec->type = fuzzInt32(1);\n    rec->off = fuzzUint32(2);\n    rec->comp = (unsigned char *)fuzzData(3);\n    rec->epoch = (unsigned long)fuzzUint64(4);\n    int arrLen = sizeof(rec->seq_num);\n    char *temp = fuzzFixBlob(5, arrLen);\n    memcpy(rec->seq_num, temp, arrLen);;\n    \n    unsigned int md_size = fuzzUint32(6);\n    unsigned int orig_len = fuzzUint32(7);\n    ssl3_cbc_copy_mac(out, rec, md_size, orig_len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/crypto/cryptlib.c\n 913: void OpenSSLDie(const char *file,int line,const char *assertion)\n 914: \t{\n 915: \tOPENSSL_showfatal(\n 916: \t\t\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",\n 917: \t\tfile,line,assertion);\n 918: #if !defined(_WIN32) || defined(__CYGWIN__)\n 919: \tabort();\n 920: #else\n 921: \t/* Win32 abort() customarily shows a dialog, but we just did that... */\n 922: \traise(SIGABRT);\n 923: \t_exit(3);\n 924: #endif\n 925: \t}\n 926: \nStacktrace #1:\nFile: /sourcecode/ssl/s3_cbc.c\n 254: void ssl3_cbc_copy_mac(unsigned char* out,\n 255: \t\t       const SSL3_RECORD *rec,\n 256: \t\t       unsigned md_size,unsigned orig_len)\n 257: \t{\n 258: #if defined(CBC_MAC_ROTATE_IN_PLACE)\n 259: \tunsigned char rotated_mac_buf[64+EVP_MAX_MD_SIZE];\n 260: \tunsigned char *rotated_mac;\n 261: #else\n 262: \tunsigned char rotated_mac[EVP_MAX_MD_SIZE];\n 263: #endif\n 264: \n 265: \t/* mac_end is the index of |rec->data| just after the end of the MAC. */\n 266: \tunsigned mac_end = rec->length;\n 267: \tunsigned mac_start = mac_end - md_size;\n 268: \t/* scan_start contains the number of bytes that we can ignore because\n 269: \t * the MAC's position can only vary by 255 bytes. */\n 270: \tunsigned scan_start = 0;\n 271: \tunsigned i, j;\n 272: \tunsigned div_spoiler;\n 273: \tunsigned rotate_offset;\n 274: \n 275: \tOPENSSL_assert(orig_len >= md_size);\n 276: \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n 277: \n 278: #if defined(CBC_MAC_ROTATE_IN_PLACE)\n 279: \trotated_mac = rotated_mac_buf + ((0-(size_t)rotated_mac_buf)&63);\n 280: #endif\n 281: \n 282: \t/* This information is public so it's safe to branch based on it. */\n 283: \tif (orig_len > md_size + 255 + 1)\n 284: \t\tscan_start = orig_len - (md_size + 255 + 1);\n 285: \t/* div_spoiler contains a multiple of md_size that is used to cause the\n 286: \t * modulo operation to be constant time. Without this, the time varies\n 287: \t * based on the amount of padding when running on Intel chips at least.\n 288: \t *\n 289: \t * The aim of right-shifting md_size is so that the compiler doesn't\n 290: \t * figure out that it can remove div_spoiler as that would require it\n 291: \t * to prove that md_size is always even, which I hope is beyond it. */\n 292: \tdiv_spoiler = md_size >> 1;\n 293: \tdiv_spoiler <<= (sizeof(div_spoiler)-1)*8;\n 294: \trotate_offset = (div_spoiler + mac_start - scan_start) % md_size;\n 295: \n 296: \tmemset(rotated_mac, 0, md_size);\n 297: \tfor (i = scan_start, j = 0; i < orig_len; i++)\n 298: \t\t{\n 299: \t\tunsigned char mac_started = constant_time_ge(i, mac_start);\n 300: \t\tunsigned char mac_ended = constant_time_ge(i, mac_end);\n 301: \t\tunsigned char b = rec->data[i];\n 302: \t\trotated_mac[j++] |= b & mac_started & ~mac_ended;\n 303: \t\tj &= constant_time_lt(j,md_size);\n 304: \t\t}\n 305: \n 306: \t/* Now rotate the MAC */\n 307: #if defined(CBC_MAC_ROTATE_IN_PLACE)\n 308: \tj = 0;\n 309: \tfor (i = 0; i < md_size; i++)\n 310: \t\t{\n 311: \t\t/* in case cache-line is 32 bytes, touch second line */\n 312: \t\t((volatile unsigned char *)rotated_mac)[rotate_offset^32];\n 313: \t\tout[j++] = rotated_mac[rotate_offset++];\n 314: \t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n 315: \t\t}\n 316: #else\n 317: \tmemset(out, 0, md_size);\n 318: \trotate_offset = md_size - rotate_offset;\n 319: \trotate_offset &= constant_time_lt(rotate_offset,md_size);\n 320: \tfor (i = 0; i < md_size; i++)\n 321: \t\t{\n 322: \t\tfor (j = 0; j < md_size; j++)\n 323: \t\t\tout[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\n 324: \t\trotate_offset++;\n 325: \t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n 326: \t\t}\n 327: #endif\n 328: \t}\n 329:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\nFuzzAgent Warning:No such file or directory,linux-vdso.so.1\n    #0 0x7fc584e00f18 in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cpp:86\n    #1 0x55fb5e2d3789 in CrashHandler /home/clouditera/workdir-engine_c/betafuzz/checkers/handlecrashes.c:281\n    #2 0x7fc5841e651f  (/lib/x86_64-linux-gnu/libc.so.6+0x4251f)\n    #3 0x7fc58423a9fb in pthread_kill (/lib/x86_64-linux-gnu/libc.so.6+0x969fb)\n    #4 0x7fc5841e6475 in raise (/lib/x86_64-linux-gnu/libc.so.6+0x42475)\n    #5 0x7fc5841cc7f2 in abort (/lib/x86_64-linux-gnu/libc.so.6+0x287f2)\n    #6 0x7fc584badb9d  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa2b9d)\n    #7 0x7fc584bb920b  (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae20b)\n    #8 0x7fc584bb9276 in std::terminate() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae276)\n    #9 0x7fc584bb94d7 in __cxa_throw (/lib/x86_64-linux-gnu/libstdc++.so.6+0xae4d7)\n    #10 0x7fc584bb066d in std::__throw_bad_function_call() (/lib/x86_64-linux-gnu/libstdc++.so.6+0xa566d)\n    #11 0x55fb5e12f604 in std::function<unsigned int (char const*, char const*, char const*)>::operator()(char const*, char const*, char const*) const (/dockerin/fuzz_drivers/tf1729655087871vsfn.out+0x3a1604)\n    #12 0x55fb5e123898 in UPSManualPolicy::another_strategy(ParsedURI const&, WFNSTracing*) /sourcecode/src/nameservice/UpstreamPolicies.cc:705\n    #13 0x55fb5e108183 in fuzzloop /dockerin/fuzz_drivers/tf1729655087871vsfn.cpp:25\n    #14 0x55fb5e2d2989 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #15 0x55fb5e1078d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #16 0x7fc5841cdd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #17 0x7fc5841cde3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #18 0x55fb5e107a24 in _start (/dockerin/fuzz_drivers/tf1729655087871vsfn.out+0x379a24)\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:44:01\n// Signature: UPSManualPolicy::another_strategy(ParsedURI &uri, WFNSTracing *tracing)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN15UPSManualPolicy16another_strategyERK9ParsedURIP11WFNSTracing\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    ParsedURI uri;\n    uri.path = fuzzString(0);\n    uri.query = fuzzString(1);\n    uri.fragment = fuzzString(2);\n\n    WFNSTracing tracing;\n    tracing.data = fuzzData(3);\n\n    UPSManualPolicy policy(fuzzBool(4), nullptr, nullptr);\n    policy.another_strategy(uri, &tracing);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 702: EndpointAddress *UPSManualPolicy::another_strategy(const ParsedURI& uri,\n 703: \t\t\t\t\t\t\t\t\t\t\t\t   WFNSTracing *tracing)\n 704: {\n 705: \tunsigned int hash_value = this->another_select(\n 706: \t\t\t\t\t\t\t\t\t\turi.path ? uri.path : \"\",\n 707: \t\t\t\t\t\t\t\t\t\turi.query ? uri.query : \"\",\n 708: \t\t\t\t\t\t\t\t\t\turi.fragment ? uri.fragment : \"\");\n 709: \treturn this->consistent_hash_with_group(hash_value, tracing);\n 710: }\n 711:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "低危", "D": "中危", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==358088==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff4f825060 at pc 0x560498056c1d bp 0x7fff4f824f00 sp 0x7fff4f824ef0\nREAD of size 8 at 0x7fff4f825060 thread T0\n    #0 0x560498056c1c in protocol::MySQLMessage::append(void const*, unsigned long*) /sourcecode/src/protocol/MySQLMessage.cc:101\n    #1 0x560497ff374f in fuzzloop /dockerin/fuzz_drivers/tf1729655844394tgvv.cpp:28\n    #2 0x5604980986f9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x560497ff3278 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f3a5d9e6d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f3a5d9e6e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x560497ff33c4 in _start (/dockerin/fuzz_drivers/tf1729655844394tgvv.out+0x10b3c4)\n\nAddress 0x7fff4f825060 is located in stack of thread T0 at offset 48 in frame\n    #0 0x560497ff3498 in fuzzloop /dockerin/fuzz_drivers/tf1729655844394tgvv.cpp:21\n\n  This frame has 4 object(s):\n    [48, 52) 'fuzz_len' (line 27) <== Memory access at offset 48 partially overflows this variable\n    [64, 224) 'vectors' (line 30)\n    [288, 1432) 'msg1' (line 23)\n    [1568, 2712) 'msg2' (line 24)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/protocol/MySQLMessage.cc:101 in protocol::MySQLMessage::append(void const*, unsigned long*)\nShadow bytes around the buggy address:\n  0x100069efc9b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efc9c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efc9d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efc9e0: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 f2 f2 f2\n  0x100069efc9f0: 00 f2 f2 f2 00 f3 f3 f3 00 00 00 00 00 00 00 00\n=>0x100069efca00: 00 00 00 00 00 00 f1 f1 f1 f1 f1 f1[04]f2 00 00\n  0x100069efca10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efca20: 00 00 f2 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00\n  0x100069efca30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efca40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100069efca50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:55:09\n// Signature: protocol::MySQLMessage::MySQLMessage(MySQLMessage &&move)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol12MySQLMessageC1EOS0_\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// Derived class to expose protected methods\nclass FuzzMySQLRequest : public protocol::MySQLRequest {\npublic:\n    using protocol::MySQLRequest::append;\n    using protocol::MySQLRequest::encode;\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    FuzzMySQLRequest msg1;\n    FuzzMySQLRequest msg2(std::move(msg1));\n\n    char* fuzz_data = fuzzData(0);\n    int fuzz_len = fuzzGetLen(0);\n    msg2.append(fuzz_data, (size_t*)&fuzz_len);\n\n    struct iovec vectors[10];\n    msg2.encode(vectors, 10);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n  97: int MySQLMessage::append(const void *buf, size_t *size)\n  98: {\n  99: \tconst void *stream_buf;\n 100: \tsize_t stream_len;\n 101: \tsize_t nleft = *size;\n 102: \tsize_t n;\n 103: \tint ret;\n 104: \n 105: \tcur_size_ += *size;\n 106: \tif (cur_size_ > this->size_limit)\n 107: \t{\n 108: \t\terrno = EMSGSIZE;\n 109: \t\treturn -1;\n 110: \t}\n 111: \n 112: \twhile (nleft > 0)\n 113: \t{\n 114: \t\tn = nleft;\n 115: \t\tret = mysql_stream_write(buf, &n, stream_);\n 116: \t\tif (ret > 0)\n 117: \t\t{\n 118: \t\t\tseqid_ = mysql_stream_get_seq(stream_);\n 119: \t\t\tmysql_stream_get_buf(&stream_buf, &stream_len, stream_);\n 120: \t\t\tret = decode_packet((const unsigned char *)stream_buf, stream_len);\n 121: \t\t\tif (ret == -2)\n 122: \t\t\t\terrno = EBADMSG;\n 123: \t\t}\n 124: \n 125: \t\tif (ret < 0)\n 126: \t\t\treturn -1;\n 127: \n 128: \t\tnleft -= n;\n 129: \t\tbuf = (const char *)buf + n;\n 130: \t}\n 131: \n 132: \treturn ret;\n 133: }\n 134:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==4562==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffff7a8c900 at pc 0x5595daeb870c bp 0x7ffff7a8c840 sp 0x7ffff7a8c830\nWRITE of size 8 at 0x7ffff7a8c900 thread T0\n    #0 0x5595daeb870b in fio_message_defer /sourcecode/lib/facil/fio.c:6419\n    #1 0x5595dae59539 in fuzzloop /dockerin/fuzz_drivers/tf1730095752286vqnc.c:23\n    #2 0x5595daf091c9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x5595dae589d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f2987802d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f2987802e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x5595dae58b24 in _start (/dockerin/fuzz_drivers/tf1730095752286vqnc.out+0xc5b24)\n\nAddress 0x7ffff7a8c900 is located in stack of thread T0 at offset 128 in frame\n    #0 0x5595dae5923d in fuzzloop /dockerin/fuzz_drivers/tf1730095752286vqnc.c:14\n\n  This frame has 1 object(s):\n    [48, 128) 'msg' (line 16) <== Memory access at offset 128 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/lib/facil/fio.c:6419 in fio_message_defer\nShadow bytes around the buggy address:\n  0x10007ef498d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef498e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef498f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49910: f1 f1 f1 f1 f1 f1 00 00 00 00 00 00 00 00 00 00\n=>0x10007ef49920:[f3]f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49930: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49940: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49950: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49960: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10007ef49970: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:07:36\n// Signature: fio_message_defer(fio_msg_s *msg_)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_message_defer\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fio.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    fio_msg_s msg = {\n        .channel = {.data = fuzzString(0), .len = fuzzGetLen(0)},\n        .msg = {.data = fuzzData(1), .len = fuzzGetLen(1)},\n        .filter = fuzzUint32(2),\n        .udata1 = (void *)fuzzInt64(3),\n        .udata2 = (void *)fuzzInt64(4)\n    };\n    fio_message_defer(&msg);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n6417: void fio_message_defer(fio_msg_s *msg_) {\n6418:   fio_msg_client_s *cl = (fio_msg_client_s *)msg_;\n6419:   cl->marker = 1;\n6420: }\n6421:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==638766==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffa1fce4e8 at pc 0x556af0540b52 bp 0x7fffa1fce410 sp 0x7fffa1fce400\nREAD of size 8 at 0x7fffa1fce4e8 thread T0\n    #0 0x556af0540b51 in Communicator::append_request(void const*, unsigned long*, __poller_message*) src/kernel/Communicator.cc:1203\n    #1 0x556af05530ca in fuzzloop /dockerin/fuzz_drivers/tf1729656038589skmf.cpp:55\n    #2 0x556af0584199 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x556af0528b78 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f0ea4be3d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f0ea4be3e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x556af0528cc4 in _start (/dockerin/fuzz_drivers/tf1729656038589skmf.out+0x86cc4)\n\nAddress 0x7fffa1fce4e8 is located in stack of thread T0 at offset 56 in frame\n    #0 0x556af0552bd1 in fuzzloop /dockerin/fuzz_drivers/tf1729656038589skmf.cpp:38\n\n  This frame has 2 object(s):\n    [32, 40) 'size' (line 41)\n    [64, 72) 'msg' (line 42) <== Memory access at offset 56 underflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow src/kernel/Communicator.cc:1203 in Communicator::append_request(void const*, unsigned long*, __poller_message*)\nShadow bytes around the buggy address:\n  0x1000743f1c40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1c70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1c80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x1000743f1c90: 00 00 00 00 00 00 f1 f1 f1 f1 00 f2 f2[f2]00 f3\n  0x1000743f1ca0: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1cb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1cc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1cd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000743f1ce0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:58:09\n// Signature: Communicator::append_request(void *buf, size_t *size, poller_message_t *msg)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator14append_requestEPKvPmP16__poller_message\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/Communicator.h\"\n#include \"_include/workflow/poller.h\"\n#include \"src/kernel/Communicator.cc\"\n\n// Placeholder for ConcreteCommSession\nclass ConcreteCommSession : public CommSession {\npublic:\n    ConcreteCommSession() {}\n    virtual ~ConcreteCommSession() {}\n\nprivate:\n    virtual CommMessageOut* message_out() override { return nullptr; }\n    virtual CommMessageIn* message_in() override { return nullptr; }\n    virtual void handle(int state, int error) override {}\n};\n\n// Placeholder for ConcreteCommMessageIn\nclass ConcreteCommMessageIn : public CommMessageIn {\npublic:\n    ConcreteCommMessageIn() {}\n    virtual ~ConcreteCommMessageIn() {}\n\nprivate:\n    virtual int append(const void* buf, size_t* size) override { return 0; }\n};\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* buf = fuzzData(0);\n    size_t size = fuzzGetLen(0);\n    poller_message_t msg;\n\n    // Create concrete instances of the abstract classes\n    struct CommConnEntry* entry = new CommConnEntry;\n    CommSession* session = new ConcreteCommSession; // Replace with a concrete implementation\n    CommMessageIn* messageIn = new ConcreteCommMessageIn; // Replace with a concrete implementation\n\n    // Set up the message structure\n    msg.append = Communicator::append_request;\n    entry->session = session;\n    session->in = messageIn;\n    messageIn->entry = entry;\n\n    Communicator::append_request(buf, &size, &msg);\n\n    delete messageIn;\n    delete session;\n    delete entry;\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n1200: int Communicator::append_request(const void *buf, size_t *size,\n1201: \t\t\t\t\t\t\t\t poller_message_t *msg)\n1202: {\n1203: \tCommMessageIn *in = (CommMessageIn *)msg;\n1204: \tstruct CommConnEntry *entry = in->entry;\n1205: \tCommSession *session = entry->session;\n1206: \tint timeout;\n1207: \tint ret;\n1208: \n1209: \tret = in->append(buf, size);\n1210: \tif (ret > 0)\n1211: \t{\n1212: \t\tentry->state = CONN_STATE_SUCCESS;\n1213: \t\ttimeout = -1;\n1214: \t}\n1215: \telse if (ret == 0 && session->timeout != 0)\n1216: \t\ttimeout = Communicator::next_timeout(session);\n1217: \telse\n1218: \t\treturn ret;\n1219: \n1220: \t/* This set_timeout() never fails, which is very important. */\n1221: \tmpoller_set_timeout(entry->sockfd, timeout, entry->mpoller);\n1222: \treturn ret;\n1223: }\n1224:\n崩溃的严重程度是什么？", "A": "高危", "B": "中危", "C": "不确定", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==2807==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc76ceaca0 at pc 0x56292c1cee24 bp 0x7ffc76cea810 sp 0x7ffc76cea800\nWRITE of size 1 at 0x7ffc76ceaca0 thread T0\n    #0 0x56292c1cee23 in http_decode_url /sourcecode/lib/facil/http/http.c:2412\n    #1 0x56292c0bc8c7 in fuzzloop /dockerin/fuzz_drivers/tf1730095317947wbjk.c:19\n    #2 0x56292c23b399 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56292c0bbab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f9eca17ad8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f9eca17ae3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56292c0bbc04 in _start (/dockerin/fuzz_drivers/tf1730095317947wbjk.out+0x1dbc04)\n\nAddress 0x7ffc76ceaca0 is located in stack of thread T0 at offset 1056 in frame\n    #0 0x56292c0bc7d9 in fuzzloop /dockerin/fuzz_drivers/tf1730095317947wbjk.c:15\n\n  This frame has 1 object(s):\n    [32, 1056) 'dest' (line 18) <== Memory access at offset 1056 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/lib/facil/http/http.c:2412 in http_decode_url\nShadow bytes around the buggy address:\n  0x10000ed95540: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed95550: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed95560: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed95570: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed95580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x10000ed95590: 00 00 00 00[f3]f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3\n  0x10000ed955a0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed955b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed955c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed955d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10000ed955e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:01:37\n// Signature: http_decode_url(char *dest, char *url_data, size_t length)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_decode_url\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/http/http1.h\"\n#include \"lib/facil/http/http_internal.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    char *url_data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    char dest[1024];\n    http_decode_url(dest, url_data, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n2394: ssize_t http_decode_url(char *dest, const char *url_data, size_t length) {\n2395:   char *pos = dest;\n2396:   const char *end = url_data + length;\n2397:   while (url_data < end) {\n2398:     if (*url_data == '+') {\n2399:       // decode space\n2400:       *(pos++) = ' ';\n2401:       ++url_data;\n2402:     } else if (*url_data == '%') {\n2403:       // decode hex value\n2404:       // this is a percent encoded value.\n2405:       if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n2406:         return -1;\n2407:       pos++;\n2408:       url_data += 3;\n2409:     } else\n2410:       *(pos++) = *(url_data++);\n2411:   }\n2412:   *pos = 0;\n2413:   return pos - dest;\n2414: }\n2415:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==3061==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffd38423ea0 at pc 0x55b125c2cce9 bp 0x7ffd38423dd0 sp 0x7ffd38423dc0\nREAD of size 8 at 0x7ffd38423ea0 thread T0\n    #0 0x55b125c2cce8 in dns_parser_append_message /sourcecode/src/protocol/dns_parser.c:815\n    #1 0x55b125c247bb in fuzzloop /dockerin/fuzz_drivers/tf1729594394092marz.cpp:22\n    #2 0x55b125c36f49 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55b125c24468 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f59e764ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f59e764ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55b125c245b4 in _start (/dockerin/fuzz_drivers/tf1729594394092marz.out+0x1d5b4)\n\nAddress 0x7ffd38423ea0 is located in stack of thread T0 at offset 48 in frame\n    #0 0x55b125c24688 in fuzzloop /dockerin/fuzz_drivers/tf1729594394092marz.cpp:14\n\n  This frame has 2 object(s):\n    [48, 52) 'fuzz_len' (line 19) <== Memory access at offset 48 partially overflows this variable\n    [64, 184) 'parser' (line 15)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/protocol/dns_parser.c:815 in dns_parser_append_message\nShadow bytes around the buggy address:\n  0x10002707c780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c790: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c7a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c7b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c7c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1\n=>0x10002707c7d0: f1 f1 f1 f1[04]f2 00 00 00 00 00 00 00 00 00 00\n  0x10002707c7e0: 00 00 00 00 00 f3 f3 f3 f3 f3 00 00 00 00 00 00\n  0x10002707c7f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c800: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c810: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10002707c820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:46:19\n// Signature: dns_parser_deinit(dns_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: dns_parser_deinit\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/dns_parser.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    dns_parser_t parser;\n    dns_parser_init(&parser);\n\n    char* fuzz_data = fuzzData(0);\n    int fuzz_len = fuzzGetLen(0);\n\n    // Cast the int* to size_t*\n    dns_parser_append_message(fuzz_data, reinterpret_cast<size_t*>(&fuzz_len), &parser);\n    dns_parser_parse_all(&parser);\n\n    dns_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/dns_parser.c\n 796: int dns_parser_append_message(const void *buf,\n 797: \t\t\t\t\t\t\t  size_t *n,\n 798: \t\t\t\t\t\t\t  dns_parser_t *parser)\n 799: {\n 800: \tint ret;\n 801: \tsize_t total;\n 802: \tsize_t new_size;\n 803: \tsize_t msgsize_bak;\n 804: \tvoid *new_buf;\n 805: \n 806: \tif (parser->complete)\n 807: \t{\n 808: \t\t*n = 0;\n 809: \t\treturn 1;\n 810: \t}\n 811: \n 812: \tif (!parser->single_packet)\n 813: \t{\n 814: \t\tmsgsize_bak = parser->msgsize;\n 815: \t\tif (parser->msgsize + *n > parser->bufsize)\n 816: \t\t{\n 817: \t\t\tnew_size = MAX(DNS_MSGBASE_INIT_SIZE, 2 * parser->bufsize);\n 818: \n 819: \t\t\twhile (new_size < parser->msgsize + *n)\n 820: \t\t\t\tnew_size *= 2;\n 821: \n 822: \t\t\tnew_buf = realloc(parser->msgbuf, new_size);\n 823: \t\t\tif (!new_buf)\n 824: \t\t\t\treturn -1;\n 825: \n 826: \t\t\tparser->msgbuf = new_buf;\n 827: \t\t\tparser->bufsize = new_size;\n 828: \t\t}\n 829: \n 830: \t\tmemcpy((char*)parser->msgbuf + parser->msgsize, buf, *n);\n 831: \t\tparser->msgsize += *n;\n 832: \n 833: \t\tif (parser->msgsize < 2)\n 834: \t\t\treturn 0;\n 835: \n 836: \t\ttotal = __dns_parser_uint16((char*)parser->msgbuf);\n 837: \t\tif (parser->msgsize < total + 2)\n 838: \t\t\treturn 0;\n 839: \n 840: \t\t*n = total + 2 - msgsize_bak;\n 841: \t\tparser->msgsize = total + 2;\n 842: \t\tparser->msgbase = (char*)parser->msgbuf + 2;\n 843: \t}\n 844: \telse\n 845: \t{\n 846: \t\tparser->msgbuf = malloc(*n);\n 847: \t\tmemcpy(parser->msgbuf, buf, *n);\n 848: \t\tparser->msgbase = parser->msgbuf;\n 849: \t\tparser->msgsize = *n;\n 850: \t\tparser->bufsize = *n;\n 851: \t}\n 852: \n 853: \tret = dns_parser_parse_all(parser);\n 854: \tif (ret < 0)\n 855: \t\treturn ret;\n 856: \n 857: \treturn 1;\n 858: }\n 859:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==6242==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe8b6dc710 at pc 0x55e24d07fcec bp 0x7ffe8b6dc620 sp 0x7ffe8b6dc610\nREAD of size 8 at 0x7ffe8b6dc710 thread T0\n    #0 0x55e24d07fceb in fio_message_metadata /sourcecode/lib/facil/fio.c:6369\n    #1 0x55e24d021554 in fuzzloop /dockerin/fuzz_drivers/tf1730095386117tnvu.c:24\n    #2 0x55e24d0d11d9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e24d0209d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f74c0bfcd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f74c0bfce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e24d020b24 in _start (/dockerin/fuzz_drivers/tf1730095386117tnvu.out+0xc5b24)\n\nAddress 0x7ffe8b6dc710 is located in stack of thread T0 at offset 144 in frame\n    #0 0x55e24d02123d in fuzzloop /dockerin/fuzz_drivers/tf1730095386117tnvu.c:14\n\n  This frame has 1 object(s):\n    [48, 128) 'msg' (line 16) <== Memory access at offset 144 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/lib/facil/fio.c:6369 in fio_message_metadata\nShadow bytes around the buggy address:\n  0x1000516d3890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d38a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d38b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d38c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d38d0: f1 f1 f1 f1 f1 f1 00 00 00 00 00 00 00 00 00 00\n=>0x1000516d38e0: f3 f3[f3]f3 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d38f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d3900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d3910: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d3920: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000516d3930: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:02:42\n// Signature: fio_message_metadata(fio_msg_s *msg, intptr_t type_id)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_message_metadata\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fio.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    fio_msg_s msg = {\n        .channel = { .data = fuzzString(0), .len = fuzzGetLen(0) },\n        .msg = { .data = fuzzData(1), .len = fuzzGetLen(1) },\n        .filter = fuzzUint32(2),\n        .udata1 = (void *)fuzzInt64(3),\n        .udata2 = (void *)fuzzInt64(4)\n    };\n    intptr_t type_id = fuzzInt64(5);\n    fio_message_metadata(&msg, type_id);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n6368: void *fio_message_metadata(fio_msg_s *msg, intptr_t type_id) {\n6369:   fio_msg_metadata_s *meta = ((fio_msg_client_s *)msg)->meta;\n6370:   size_t len = ((fio_msg_client_s *)msg)->meta_len;\n6371:   while (len) {\n6372:     --len;\n6373:     if (meta[len].type_id == type_id)\n6374:       return meta[len].metadata;\n6375:   }\n6376:   return NULL;\n6377: }\n6378:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "中危", "D": "不确定", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==130==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc1e2ca890 at pc 0x56552e4bb705 bp 0x7ffc1e2ca790 sp 0x7ffc1e2ca780\nWRITE of size 1 at 0x7ffc1e2ca890 thread T0\n    #0 0x56552e4bb704 in fio_ltoa /sourcecode/lib/facil/fio.c:4869\n    #1 0x56552e479345 in fuzzloop /sharedockerin/ta1730101611991syeu/test_file.c:18\n    #2 0x56552e528fd9 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x56552e4789d8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f26ae45ed8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f26ae45ee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x56552e478b24 in _start (/sharedockerin/ta1730101611991syeu/clouditera+0xc5b24)\n\nAddress 0x7ffc1e2ca890 is located in stack of thread T0 at offset 128 in frame\n    #0 0x56552e4bae89 in fio_ltoa /sourcecode/lib/facil/fio.c:4821\n\n  This frame has 2 object(s):\n    [48, 64) 'notation' (line 4822)\n    [80, 128) 'buf' (line 4826) <== Memory access at offset 128 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/lib/facil/fio.c:4869 in fio_ltoa\nShadow bytes around the buggy address:\n  0x100003c514c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c514d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c514e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c514f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c51500: 00 00 f1 f1 f1 f1 f1 f1 00 00 f2 f2 00 00 00 00\n=>0x100003c51510: 00 00[f3]f3 f3 f3 00 00 00 00 00 00 00 00 00 00\n  0x100003c51520: 00 00 00 00 f1 f1 f1 f1 f1 f1 00 00 00 00 00 00\n  0x100003c51530: 00 00 04 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00\n  0x100003c51540: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c51550: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100003c51560: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:04:20\n// Signature: fio_ltoa(char *dest, int64_t num, uint8_t base)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: fio_ltoa\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/fio.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    char dest[68];\n    int64_t num = fuzzInt64(0);\n    uint8_t base = fuzzUint8(1) % 17; // Valid bases are 0 to 16\n    fio_ltoa(dest, num, base);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n4821: size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n4822:   const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n4823:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n4824: \n4825:   size_t len = 0;\n4826:   char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n4827: \n4828:   if (!num)\n4829:     goto zero;\n4830: \n4831:   switch (base) {\n4832:   case 1: /* fallthrough */\n4833:   case 2:\n4834:     /* Base 2 */\n4835:     {\n4836:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4837:       uint8_t i = 0;    /* counting bits */\n4838:       dest[len++] = '0';\n4839:       dest[len++] = 'b';\n4840: \n4841:       while ((i < 64) && (n & 0x8000000000000000) == 0) {\n4842:         n = n << 1;\n4843:         i++;\n4844:       }\n4845:       /* make sure the Binary representation doesn't appear signed. */\n4846:       if (i) {\n4847:         dest[len++] = '0';\n4848:       }\n4849:       /* write to dest. */\n4850:       while (i < 64) {\n...skip...\n4839:       dest[len++] = 'b';\n4840: \n4841:       while ((i < 64) && (n & 0x8000000000000000) == 0) {\n4842:         n = n << 1;\n4843:         i++;\n4844:       }\n4845:       /* make sure the Binary representation doesn't appear signed. */\n4846:       if (i) {\n4847:         dest[len++] = '0';\n4848:       }\n4849:       /* write to dest. */\n4850:       while (i < 64) {\n4851:         dest[len++] = ((n & 0x8000000000000000) ? '1' : '0');\n4852:         n = n << 1;\n4853:         i++;\n4854:       }\n4855:       dest[len] = 0;\n4856:       return len;\n4857:     }\n4858:   case 8:\n4859:     /* Base 8 */\n4860:     {\n4861:       uint64_t l = 0;\n4862:       if (num < 0) {\n4863:         dest[len++] = '-';\n4864:         num = 0 - num;\n4865:       }\n4866:       dest[len++] = '0';\n4867: \n4868:       while (num) {\n4869:         buf[l++] = '0' + (num & 7);\n4870:         num = num >> 3;\n4871:       }\n4872:       while (l) {\n4873:         --l;\n4874:         dest[len++] = buf[l];\n4875:       }\n4876:       dest[len] = 0;\n4877:       return len;\n4878:     }\n4879: \n4880:   case 16:\n4881:     /* Base 16 */\n4882:     {\n4883:       uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n4884:       uint8_t i = 0;    /* counting bits */\n4885:       dest[len++] = '0';\n4886:       dest[len++] = 'x';\n4887:       while (i < 8 && (n & 0xFF00000000000000) == 0) {\n4888:         n = n << 8;\n4889:         i++;\n4890:       }\n4891:       /* make sure the Hex representation doesn't appear misleadingly signed. */\n4892:       if (i && (n & 0x8000000000000000)) {\n4893:         dest[len++] = '0';\n4894:         dest[len++] = '0';\n4895:       }\n4896:       /* write the damn thing, high to low */\n4897:       while (i < 8) {\n4898:         uint8_t tmp = (n & 0xF000000000000000) >> 60;\n...skip...\n4945:     num = t;\n4946:   }\n4947:   while (l) {\n4948:     --l;\n4949:     dest[len++] = buf[l];\n4950:   }\n4951:   dest[len] = 0;\n4952:   return len;\n4953: \n4954: zero:\n4955:   switch (base) {\n4956:   case 1:\n4957:   case 2:\n4958:     dest[len++] = '0';\n4959:     dest[len++] = 'b';\n4960:     break;\n4961:   case 8:\n4962:     dest[len++] = '0';\n4963:     break;\n4964:   case 16:\n4965:     dest[len++] = '0';\n4966:     dest[len++] = 'x';\n4967:     dest[len++] = '0';\n4968:     break;\n4969:   }\n4970:   dest[len++] = '0';\n4971:   dest[len] = 0;\n4972:   return len;\n4973: }\n4974:\n崩溃的严重程度是什么？", "A": "高危", "B": "不确定", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==559067==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe0fb215cc at pc 0x558c55607ed8 bp 0x7ffe0fb214c0 sp 0x7ffe0fb214b0\nWRITE of size 4 at 0x7ffe0fb215cc thread T0\n    #0 0x558c55607ed7 in CommService::incref() /sourcecode/src/kernel/Communicator.cc:281\n    #1 0x558c555fa6ee in Communicator::accept(sockaddr const*, unsigned int, int, void*) /sourcecode/src/kernel/Communicator.cc:1367\n    #2 0x558c555de11a in fuzzloop /dockerin/fuzz_drivers/tf1729655725590kkgn.cpp:30\n    #3 0x558c55637a09 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x558c555ddbd8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7fb1b616fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7fb1b616fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x558c555ddd24 in _start (/dockerin/fuzz_drivers/tf1729655725590kkgn.out+0x84d24)\n\nAddress 0x7ffe0fb215cc is located in stack of thread T0 at offset 92 in frame\n    #0 0x558c555dddf8 in fuzzloop /dockerin/fuzz_drivers/tf1729655725590kkgn.cpp:17\n\n  This frame has 2 object(s):\n    [48, 88) 'comm' (line 19) <== Memory access at offset 92 overflows this variable\n    [128, 144) 'addr' (line 22)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/kernel/Communicator.cc:281 in CommService::incref()\nShadow bytes around the buggy address:\n  0x100041f5c260: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c270: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c280: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c2a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1\n=>0x100041f5c2b0: f1 f1 f1 f1 00 00 00 00 00[f2]f2 f2 f2 f2 00 00\n  0x100041f5c2c0: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c2d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c2e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c2f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100041f5c300: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:54:54\n// Signature: Communicator::accept(struct sockaddr *addr, socklen_t addrlen, int sockfd, void *context)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN12Communicator6acceptEPK8sockaddrjiPv\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/Communicator.h\"\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    Communicator comm;\n    comm.init(fuzzUint32(0) % 10 + 1, fuzzUint32(1) % 10 + 1);\n\n    struct sockaddr_in addr;\n    addr.sin_family = AF_INET;\n    addr.sin_port = htons(fuzzUint16(2) % 65536);\n    inet_pton(AF_INET, fuzzString(3), &addr.sin_addr);\n\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) return -1;\n\n    Communicator::accept((struct sockaddr *)&addr, sizeof(addr), sockfd, &comm);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/kernel/Communicator.cc\n 279: inline void CommService::incref()\n 280: {\n 281: \t__sync_add_and_fetch(&this->ref, 1);\n 282: }\n 283: \nStacktrace #1:\nFile: /sourcecode/src/kernel/Communicator.cc\n1357: void *Communicator::accept(const struct sockaddr *addr, socklen_t addrlen,\n1358: \t\t\t\t\t\t   int sockfd, void *context)\n1359: {\n1360: \tCommService *service = (CommService *)context;\n1361: \tCommServiceTarget *target = new CommServiceTarget;\n1362: \n1363: \tif (target)\n1364: \t{\n1365: \t\tif (target->init(addr, addrlen, 0, service->response_timeout) >= 0)\n1366: \t\t{\n1367: \t\t\tservice->incref();\n1368: \t\t\ttarget->service = service;\n1369: \t\t\ttarget->sockfd = sockfd;\n1370: \t\t\ttarget->ref = 1;\n1371: \t\t\treturn target;\n1372: \t\t}\n1373: \n1374: \t\tdelete target;\n1375: \t}\n1376: \n1377: \tclose(sockfd);\n1378: \treturn NULL;\n1379: }\n1380:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==628024==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffddeaed098 at pc 0x55621b370abc bp 0x7ffddeaece40 sp 0x7ffddeaece30\nREAD of size 4 at 0x7ffddeaed098 thread T0\n    #0 0x55621b370abb in UPSGroupPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:292\n    #1 0x55621b376c29 in UPSWeightedRandomPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:480\n    #2 0x55621b37ee08 in UPSVNSWRRPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:655\n    #3 0x55621b364f7c in fuzzloop /dockerin/fuzz_drivers/tf1729655864284gmwn.cpp:31\n    #4 0x55621b530329 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x55621b364978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f9041808d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f9041808e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x55621b364ac4 in _start (/dockerin/fuzz_drivers/tf1729655864284gmwn.out+0x37aac4)\n\nAddress 0x7ffddeaed098 is located in stack of thread T0 at offset 216 in frame\n    #0 0x55621b364b98 in fuzzloop /dockerin/fuzz_drivers/tf1729655864284gmwn.cpp:15\n\n  This frame has 6 object(s):\n    [48, 49) '<unknown>'\n    [64, 120) 'addrParams' (line 20)\n    [160, 216) 'params' (line 26) <== Memory access at offset 216 overflows this variable\n    [256, 288) '<unknown>'\n    [320, 472) 'addr' (line 29)\n    [544, 920) 'policy' (line 17)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:292 in UPSGroupPolicy::add_server_locked(EndpointAddress*)\nShadow bytes around the buggy address:\n  0x10003bd559c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003bd559d0: 00 00 00 00 f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00\n  0x10003bd559e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003bd559f0: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f1 f1 f8 f2\n  0x10003bd55a00: 00 00 00 00 00 00 00 f2 f2 f2 f2 f2 00 00 00 00\n=>0x10003bd55a10: 00 00 00[f2]f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2\n  0x10003bd55a20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003bd55a30: 00 00 00 f2 f2 f2 f2 f2 f2 f2 f2 f2 00 00 00 00\n  0x10003bd55a40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003bd55a50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003bd55a60: 00 00 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:55:27\n// Signature: UPSVNSWRRPolicy::add_server_locked(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN15UPSVNSWRRPolicy17add_server_lockedEP15EndpointAddress\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFServiceGovernance.h\" // Added to fix undeclared symbol \"EndpointAddress\" error\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    UPSVNSWRRPolicy policy;\n    \n    // Create AddressParams object\n    AddressParams addrParams;\n    addrParams.weight = fuzzUint16(1);\n    addrParams.server_type = fuzzInt8(2);\n    addrParams.group_id = fuzzInt32(3);\n\n    // Create PolicyAddrParams object using AddressParams\n    PolicyAddrParams params(&addrParams);\n\n    // Create EndpointAddress object with the required arguments\n    EndpointAddress addr(fuzzString(0), &params);\n\n    policy.add_server_locked(&addr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 289: void UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n 290: {\n 291: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 292: \tint group_id = params->group_id;\n 293: \trb_node **p = &this->group_map.rb_node;\n 294: \trb_node *parent = NULL;\n 295: \tEndpointGroup *group;\n 296: \n 297: \tthis->server_map[addr->address].push_back(addr);\n 298: \n 299: \tif (params->server_type == 0)\n 300: \t\tthis->servers.push_back(addr);\n 301: \n 302: \twhile (*p)\n 303: \t{\n 304: \t\tparent = *p;\n 305: \t\tgroup = rb_entry(*p, EndpointGroup, rb);\n 306: \n 307: \t\tif (group_id < group->id)\n 308: \t\t\tp = &(*p)->rb_left;\n 309: \t\telse if (group_id > group->id)\n 310: \t\t\tp = &(*p)->rb_right;\n 311: \t\telse\n 312: \t\t\tbreak;\n 313: \t}\n 314: \n 315: \tif (*p == NULL)\n 316: \t{\n 317: \t\tgroup = new EndpointGroup(group_id, this);\n 318: \t\trb_link_node(&group->rb, parent, p);\n 319: \t\trb_insert_color(&group->rb, &this->group_map);\n 320: \t}\n 321: \n 322: \tpthread_mutex_lock(&group->mutex);\n 323: \tparams->group = group;\n 324: \tthis->recover_one_server(addr);\n 325: \tif (params->server_type == 0)\n 326: \t{\n 327: \t\tgroup->mains.push_back(addr);\n 328: \t\tgroup->weight += params->weight;\n 329: \t}\n 330: \telse\n 331: \t\tgroup->backups.push_back(addr);\n 332: \tpthread_mutex_unlock(&group->mutex);\n 333: }\n 334: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 476: void UPSWeightedRandomPolicy::add_server_locked(EndpointAddress *addr)\n 477: {\n 478: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 479: \n 480: \tUPSGroupPolicy::add_server_locked(addr);\n 481: \tif (params->server_type == 0)\n 482: \t\tthis->total_weight += params->weight;\n 483: }\n 484: \nStacktrace #2:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 653: void UPSVNSWRRPolicy::add_server_locked(EndpointAddress *addr)\n 654: {\n 655: \tUPSWeightedRandomPolicy::add_server_locked(addr);\n 656: \tinit();\n 657: }\n 658:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==5858==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffa297c758 at pc 0x55cccec30e3a bp 0x7fffa297c6a0 sp 0x7fffa297c690\nREAD of size 8 at 0x7fffa297c758 thread T0\n    #0 0x55cccec30e39 in http_sse_set_timout /sourcecode/lib/facil/http/http.c:1346\n    #1 0x55ccceb3397a in fuzzloop /dockerin/fuzz_drivers/tf1730095272215fpyt.c:24\n    #2 0x55cccecb2449 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55ccceb32ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fe62d537d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fe62d537e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55ccceb32c04 in _start (/dockerin/fuzz_drivers/tf1730095272215fpyt.out+0x1dbc04)\n\nAddress 0x7fffa297c758 is located in stack of thread T0 at offset 88 in frame\n    #0 0x55ccceb337d9 in fuzzloop /dockerin/fuzz_drivers/tf1730095272215fpyt.c:14\n\n  This frame has 1 object(s):\n    [48, 88) 'sse' (line 15) <== Memory access at offset 88 overflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/lib/facil/http/http.c:1346 in http_sse_set_timout\nShadow bytes around the buggy address:\n  0x100074527890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000745278a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000745278b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000745278c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x1000745278d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x1000745278e0: f1 f1 f1 f1 f1 f1 00 00 00 00 00[f3]f3 f3 f3 f3\n  0x1000745278f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100074527900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100074527910: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100074527920: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100074527930: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:00:52\n// Signature: http_sse_set_timout(http_sse_s *sse_, uint8_t timeout)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_sse_set_timout\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/http/http1.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    http_sse_s sse = {\n        .on_open = NULL,\n        .on_ready = NULL,\n        .on_shutdown = NULL,\n        .on_close = NULL,\n        .udata = NULL\n    };\n\n    uint8_t timeout = fuzzUint8(0);\n    http_sse_set_timout(&sse, timeout);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/http/http.c\n1342: void http_sse_set_timout(http_sse_s *sse_, uint8_t timeout) {\n1343:   if (!sse_)\n1344:     return;\n1345:   http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n1346:   fio_timeout_set(sse->uuid, timeout);\n1347: }\n1348:\n崩溃的严重程度是什么？", "A": "不确定", "B": "低危", "C": "中危", "D": "高危", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==640030==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff56a57bd8 at pc 0x558019ae391a bp 0x7fff56a579d0 sp 0x7fff56a579c0\nREAD of size 4 at 0x7fff56a57bd8 thread T0\n    #0 0x558019ae3919 in UPSGroupPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:292\n    #1 0x558019af2a66 in UPSConsistentHashPolicy::add_server_locked(EndpointAddress*) /sourcecode/src/nameservice/UpstreamPolicies.cc:678\n    #2 0x558019ad906f in fuzzloop /dockerin/fuzz_drivers/tf1729656021490sapd.cpp:31\n    #3 0x558019ca3f19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x558019ad8978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f80ee6ced8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f80ee6cee3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x558019ad8ac4 in _start (/dockerin/fuzz_drivers/tf1729656021490sapd.out+0x378ac4)\n\nAddress 0x7fff56a57bd8 is located in stack of thread T0 at offset 216 in frame\n    #0 0x558019ad8b98 in fuzzloop /dockerin/fuzz_drivers/tf1729656021490sapd.cpp:15\n\n  This frame has 7 object(s):\n    [48, 49) '<unknown>'\n    [64, 120) 'params' (line 20)\n    [160, 216) 'policyParams' (line 26) <== Memory access at offset 216 overflows this variable\n    [256, 288) '<unknown>'\n    [320, 352) '<unknown>'\n    [384, 536) 'addr' (line 29)\n    [608, 952) 'policy' (line 17)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:292 in UPSGroupPolicy::add_server_locked(EndpointAddress*)\nShadow bytes around the buggy address:\n  0x10006ad42f20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10006ad42f30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10006ad42f40: 00 00 00 00 00 00 f1 f1 f1 f1 00 f3 f3 f3 00 00\n  0x10006ad42f50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10006ad42f60: f1 f1 f1 f1 f1 f1 f8 f2 00 00 00 00 00 00 00 f2\n=>0x10006ad42f70: f2 f2 f2 f2 00 00 00 00 00 00 00[f2]f2 f2 f2 f2\n  0x10006ad42f80: f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2\n  0x10006ad42f90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10006ad42fa0: 00 00 00 f2 f2 f2 f2 f2 f2 f2 f2 f2 00 00 00 00\n  0x10006ad42fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10006ad42fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:58:16\n// Signature: UPSConsistentHashPolicy::add_server_locked(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSConsistentHashPolicy17add_server_lockedEP15EndpointAddress\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFServiceGovernance.h\" // Added to fix undeclared symbol \"EndpointAddress\" error\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    UPSConsistentHashPolicy policy(nullptr);\n    \n    // Create AddressParams object\n    AddressParams params;\n    params.weight = fuzzUint16(1);\n    params.server_type = fuzzInt8(2);\n    params.group_id = fuzzInt32(3);\n\n    // Create PolicyAddrParams object using AddressParams\n    PolicyAddrParams policyParams(&params);\n\n    // Create EndpointAddress object with the required arguments\n    EndpointAddress addr(fuzzString(0), &policyParams);\n\n    policy.add_server_locked(&addr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 289: void UPSGroupPolicy::add_server_locked(EndpointAddress *addr)\n 290: {\n 291: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 292: \tint group_id = params->group_id;\n 293: \trb_node **p = &this->group_map.rb_node;\n 294: \trb_node *parent = NULL;\n 295: \tEndpointGroup *group;\n 296: \n 297: \tthis->server_map[addr->address].push_back(addr);\n 298: \n 299: \tif (params->server_type == 0)\n 300: \t\tthis->servers.push_back(addr);\n 301: \n 302: \twhile (*p)\n 303: \t{\n 304: \t\tparent = *p;\n 305: \t\tgroup = rb_entry(*p, EndpointGroup, rb);\n 306: \n 307: \t\tif (group_id < group->id)\n 308: \t\t\tp = &(*p)->rb_left;\n 309: \t\telse if (group_id > group->id)\n 310: \t\t\tp = &(*p)->rb_right;\n 311: \t\telse\n 312: \t\t\tbreak;\n 313: \t}\n 314: \n 315: \tif (*p == NULL)\n 316: \t{\n 317: \t\tgroup = new EndpointGroup(group_id, this);\n 318: \t\trb_link_node(&group->rb, parent, p);\n 319: \t\trb_insert_color(&group->rb, &this->group_map);\n 320: \t}\n 321: \n 322: \tpthread_mutex_lock(&group->mutex);\n 323: \tparams->group = group;\n 324: \tthis->recover_one_server(addr);\n 325: \tif (params->server_type == 0)\n 326: \t{\n 327: \t\tgroup->mains.push_back(addr);\n 328: \t\tgroup->weight += params->weight;\n 329: \t}\n 330: \telse\n 331: \t\tgroup->backups.push_back(addr);\n 332: \tpthread_mutex_unlock(&group->mutex);\n 333: }\n 334: \nStacktrace #1:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 676: void UPSConsistentHashPolicy::add_server_locked(EndpointAddress *addr)\n 677: {\n 678: \tUPSGroupPolicy::add_server_locked(addr);\n 679: \tthis->hash_map_add_addr(addr);\n 680: }\n 681:\n崩溃的严重程度是什么？", "A": "中危", "B": "低危", "C": "高危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==755071==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdd1c4a310 at pc 0x55e418a16a1e bp 0x7ffdd1c4a230 sp 0x7ffdd1c4a220\nREAD of size 8 at 0x7ffdd1c4a310 thread T0\n    #0 0x55e418a16a1d in UPSWeightedRandomPolicy::recover_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:584\n    #1 0x55e418a02e69 in fuzzloop /dockerin/fuzz_drivers/tf1729655247791nkbs.cpp:19\n    #2 0x55e418bcd869 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x55e418a02978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7fc4167acd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7fc4167ace3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x55e418a02ac4 in _start (/dockerin/fuzz_drivers/tf1729655247791nkbs.out+0x377ac4)\n\nAddress 0x7ffdd1c4a310 is located in stack of thread T0 at offset 128 in frame\n    #0 0x55e418a02b98 in fuzzloop /dockerin/fuzz_drivers/tf1729655247791nkbs.cpp:15\n\n  This frame has 5 object(s):\n    [48, 49) '<unknown>'\n    [64, 120) 'params' (line 17) <== Memory access at offset 128 overflows this variable\n    [160, 192) '<unknown>'\n    [224, 376) 'addr' (line 18)\n    [448, 768) 'policy' (line 16)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:584 in UPSWeightedRandomPolicy::recover_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x10003a381410: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a381420: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a381430: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a381440: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a381450: 00 00 f1 f1 f1 f1 f1 f1 f8 f2 00 00 00 00 00 00\n=>0x10003a381460: 00 f2[f2]f2 f2 f2 f8 f8 f8 f8 f2 f2 f2 f2 00 00\n  0x10003a381470: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a381480: 00 f2 f2 f2 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00\n  0x10003a381490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a3814a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10003a3814b0: 00 00 f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:45:44\n// Signature: UPSWeightedRandomPolicy::recover_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy18recover_one_serverEPK15EndpointAddress\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFServiceGovernance.h\" // Added to fix undeclared symbol \"EndpointAddress\" error\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    UPSWeightedRandomPolicy policy(fuzzBool(0));\n    PolicyAddrParams params; // Create a PolicyAddrParams object\n    EndpointAddress addr(fuzzString(1), &params); // Provide the required arguments\n    policy.recover_one_server(&addr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 579: void UPSWeightedRandomPolicy::recover_one_server(const EndpointAddress *addr)\n 580: {\n 581: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 582: \n 583: \tthis->nalives++;\n 584: \tif (params->group->nalives++ == 0 && params->group->id > 0)\n 585: \t\tthis->available_weight += params->group->weight;\n 586: \n 587: \tif (params->group_id < 0 && params->server_type == 0)\n 588: \t\tthis->available_weight += params->weight;\n 589: }\n 590:\n崩溃的严重程度是什么？", "A": "不确定", "B": "高危", "C": "中危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==563637==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffd1e7c0650 at pc 0x561b87197e98 bp 0x7ffd1e7c0570 sp 0x7ffd1e7c0560\nREAD of size 8 at 0x7ffd1e7c0650 thread T0\n    #0 0x561b87197e97 in UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress const*) /sourcecode/src/nameservice/UpstreamPolicies.cc:596\n    #1 0x561b87182e69 in fuzzloop /dockerin/fuzz_drivers/tf1729655487316bfna.cpp:19\n    #2 0x561b8734d869 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #3 0x561b87182978 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #4 0x7f76362acd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #5 0x7f76362ace3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #6 0x561b87182ac4 in _start (/dockerin/fuzz_drivers/tf1729655487316bfna.out+0x377ac4)\n\nAddress 0x7ffd1e7c0650 is located in stack of thread T0 at offset 128 in frame\n    #0 0x561b87182b98 in fuzzloop /dockerin/fuzz_drivers/tf1729655487316bfna.cpp:15\n\n  This frame has 5 object(s):\n    [48, 49) '<unknown>'\n    [64, 120) 'params' (line 17) <== Memory access at offset 128 overflows this variable\n    [160, 192) '<unknown>'\n    [224, 376) 'addr' (line 18)\n    [448, 768) 'policy' (line 16)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /sourcecode/src/nameservice/UpstreamPolicies.cc:596 in UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress const*)\nShadow bytes around the buggy address:\n  0x100023cf0070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf0080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf0090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf00a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf00b0: 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 f1 f1\n=>0x100023cf00c0: f8 f2 00 00 00 00 00 00 00 f2[f2]f2 f2 f2 f8 f8\n  0x100023cf00d0: f8 f8 f2 f2 f2 f2 00 00 00 00 00 00 00 00 00 00\n  0x100023cf00e0: 00 00 00 00 00 00 00 00 00 f2 f2 f2 f2 f2 f2 f2\n  0x100023cf00f0: f2 f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf0100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x100023cf0110: 00 00 00 00 00 00 00 00 00 00 f3 f3 f3 f3 f3 f3\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:50:15\n// Signature: UPSWeightedRandomPolicy::fuse_one_server(EndpointAddress *addr)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN23UPSWeightedRandomPolicy15fuse_one_serverEPK15EndpointAddress\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/manager/UpstreamManager.h\"\n#include \"_include/workflow/WFServiceGovernance.h\" // Added to fix undeclared symbol errors\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    UPSWeightedRandomPolicy policy(fuzzBool(0));\n    PolicyAddrParams params; // Create a PolicyAddrParams object\n    EndpointAddress addr(fuzzString(1), &params); // Provide the required arguments\n    policy.fuse_one_server(&addr);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/nameservice/UpstreamPolicies.cc\n 591: void UPSWeightedRandomPolicy::fuse_one_server(const EndpointAddress *addr)\n 592: {\n 593: \tUPSAddrParams *params = static_cast<UPSAddrParams *>(addr->params);\n 594: \n 595: \tthis->nalives--;\n 596: \tif (--params->group->nalives == 0 && params->group->id > 0)\n 597: \t\tthis->available_weight -= params->group->weight;\n 598: \n 599: \tif (params->group_id < 0 && params->server_type == 0)\n 600: \t\tthis->available_weight -= params->weight;\n 601: }\n 602:\n崩溃的严重程度是什么？", "A": "中危", "B": "不确定", "C": "高危", "D": "低危", "answer": "D"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==196==ERROR: AddressSanitizer: stack-buffer-underflow on address 0x7ffe54090f80 at pc 0x7fe5ec799c23 bp 0x7ffe54090e80 sp 0x7ffe54090628\nWRITE of size 32752 at 0x7ffe54090f80 thread T0\n    #0 0x7fe5ec799c22 in __interceptor_memset ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:799\n    #1 0x55973ff0ac53 in block_free /sourcecode/lib/facil/fio.c:7840\n    #2 0x55973ff0b6a0 in block_slice_free /sourcecode/lib/facil/fio.c:7935\n    #3 0x55973ff0bf76 in fio_free /sourcecode/lib/facil/fio.c:8097\n    #4 0x55973ff70c52 in http_sse_try_free /sourcecode/lib/facil/http/http_internal.h:181\n    #5 0x55973ff84955 in http_sse_free /sourcecode/lib/facil/http/http.c:1413\n    #6 0x55973fe8698f in fuzzloop /sharedockerin/ta1730101611169jkcz/test_file.c:24\n    #7 0x559740005459 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #8 0x55973fe85ab8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #9 0x7fe5ebe3bd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #10 0x7fe5ebe3be3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #11 0x55973fe85c04 in _start (/sharedockerin/ta1730101611169jkcz/clouditera+0x1dbc04)\n\nAddress 0x7ffe54090f80 is located in stack of thread T0 at offset 0 in frame\n    #0 0x55973fe867d9 in fuzzloop /sharedockerin/ta1730101611169jkcz/test_file.c:14\n\n  This frame has 1 object(s):\n    [48, 88) 'sse' (line 15) <== Memory access at offset 0 partially underflows this variable\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-underflow ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:799 in __interceptor_memset\nShadow bytes around the buggy address:\n  0x10004a80a1a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a1b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a1c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a1d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a1e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x10004a80a1f0:[f1]f1 f1 f1 f1 f1 00 00 00 00 00 f3 f3 f3 f3 f3\n  0x10004a80a200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a220: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a230: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  0x10004a80a240: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-28 06:01:26\n// Signature: http_sse_dup(http_sse_s *sse)\n// Language: C\n// Engine: ClouditeraFuzzAgent\n// Target: http_sse_dup\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-I. -I./lib -I./lib/facil -I./lib/facil/tls -I./lib/facil/fiobj -I./lib/facil/cli -I./lib/facil/http -I./lib/facil/http/parsers -I./lib/facil/redis\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"lib/facil/http/http1.h\"\n\n// main fuzz loop\nint fuzzloop() {\n    http_sse_s sse;\n    sse.udata = fuzzData(0);\n    sse.on_open = NULL;\n    sse.on_ready = NULL;\n    sse.on_shutdown = NULL;\n    sse.on_close = NULL;\n\n    http_sse_s *dup_sse = http_sse_dup(&sse);\n    if (dup_sse) {\n        http_sse_free(dup_sse);\n    }\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/lib/facil/fio.c\n7836: static inline void block_free(block_s *blk) {\n7837:   if (fio_atomic_sub(&blk->ref, 1))\n7838:     return;\n7839: \n7840:   memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n7841:   fio_lock(&memory.lock);\n7842:   fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n7843: \n7844:   blk = blk->parent;\n7845: \n7846:   if (fio_atomic_sub(&blk->root_ref, 1)) {\n7847:     fio_unlock(&memory.lock);\n7848:     return;\n7849:   }\n7850:   // fio_unlock(&memory.lock);\n7851:   // return;\n7852: \n7853:   /* remove all of the root block's children (slices) from the memory pool */\n7854:   for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n7855:     block_node_s *pos =\n7856:         (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));\n7857:     fio_ls_embd_remove(&pos->node);\n7858:   }\n7859: \n7860:   fio_unlock(&memory.lock);\n7861:   sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n7862:   FIO_LOG_DEBUG(\"memory allocator returned %p to the system\", (void *)blk);\n7863:   FIO_MEMORY_ON_BLOCK_FREE();\n7864: }\n7865: \nStacktrace #1:\nFile: /sourcecode/lib/facil/fio.c\n7932: static inline void block_slice_free(void *mem) {\n7933:   /* locate block boundary */\n7934:   block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n7935:   block_free(blk);\n7936: }\n7937: \nStacktrace #2:\nFile: /sourcecode/lib/facil/fio.c\n8088: void fio_free(void *ptr) {\n8089:   if (!ptr || ptr == (void *)&on_malloc_zero)\n8090:     return;\n8091:   if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n8092:     /* big allocation - direct from the system */\n8093:     big_free(ptr);\n8094:     return;\n8095:   }\n8096:   /* allocated within block */\n8097:   block_slice_free(ptr);\n8098: }\n8099: \nStacktrace #3:\nFile: /sourcecode/lib/facil/http/http_internal.h\n 178: static inline void http_sse_try_free(http_sse_internal_s *sse) {\n 179:   if (fio_atomic_sub(&sse->ref, 1))\n 180:     return;\n 181:   fio_free(sse);\n 182: }\n 183: \nStacktrace #4:\nFile: /sourcecode/lib/facil/http/http.c\n1412: void http_sse_free(http_sse_s *sse) {\n1413:   http_sse_try_free(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse));\n1414: }\n1415:\n崩溃的严重程度是什么？", "A": "中危", "B": "高危", "C": "低危", "D": "不确定", "answer": "C"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: unknown-crash on address 0x602000022d91 at pc 0x56551533eb61 bp 0x7fff18d98920 sp 0x7fff18d98910\nREAD of size 8 at 0x602000022d91 thread T0\n    #0 0x56551533eb60 in uint8korr /sourcecode/src/protocol/mysql_byteorder.h:58\n    #1 0x56551533f3cb in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:61\n    #2 0x56551533f592 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x56551533e73c in fuzzloop /sharedockerin/ta1729664330266xzik/test_file.cpp:22\n    #4 0x565515347f59 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #5 0x56551533e3a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #6 0x7f99e539fd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #7 0x7f99e539fe3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #8 0x56551533e4f4 in _start (/sharedockerin/ta1729664330266xzik/clouditera+0xf4f4)\n\n0x602000022d98 is located 0 bytes to the right of 8-byte region [0x602000022d90,0x602000022d98)\nallocated by thread T0 here:\n    #0 0x7f99e5fc6887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x56551534816c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: unknown-crash /sourcecode/src/protocol/mysql_byteorder.h:58 in uint8korr\nShadow bytes around the buggy address:\n  0x0c047fffc560: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc570: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fd\n  0x0c047fffc580: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc590: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc5a0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\n=>0x0c047fffc5b0: fa fa[00]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc5c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc5d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc5e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc5f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc600: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:37:15\n// Signature: decode_string(unsigned char **str, unsigned long long *len, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_string\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    const unsigned char *data = reinterpret_cast<const unsigned char*>(fuzzData(0));\n    int len = fuzzGetLen(0);\n    const unsigned char *pos = data;\n    const unsigned char *end = data + len;\n    unsigned long long length;\n    const unsigned char *str;\n\n    decode_string(&str, &length, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  56: static inline uint64_t uint8korr(const unsigned char *A)\n  57: {\n  58: \tuint64_t ret;\n  59: \tmemcpy(&ret, A, sizeof(ret));\n  60: \treturn ret;\n  61: }\n  62: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "中危", "D": "不确定", "answer": "B"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==203==ERROR: AddressSanitizer: unknown-crash on address 0x602000004b11 at pc 0x556c194f6b3d bp 0x7ffec82fcbb0 sp 0x7ffec82fcba0\nREAD of size 8 at 0x602000004b11 thread T0\n    #0 0x556c194f6b3c in uint8korr /sourcecode/src/protocol/mysql_byteorder.h:58\n    #1 0x556c194f73a7 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:61\n    #2 0x556c194f672e in fuzzloop /sharedockerin/ta1729664329765ysdw/test_file.cpp:24\n    #3 0x556c194fff29 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #4 0x556c194f63a8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #5 0x7f240b07cd8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #6 0x7f240b07ce3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #7 0x556c194f64f4 in _start (/sharedockerin/ta1729664329765ysdw/clouditera+0xf4f4)\n\n0x602000004b18 is located 0 bytes to the right of 8-byte region [0x602000004b10,0x602000004b18)\nallocated by thread T0 here:\n    #0 0x7f240bca3887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x556c1950013c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: unknown-crash /sourcecode/src/protocol/mysql_byteorder.h:58 in uint8korr\nShadow bytes around the buggy address:\n  0x0c047fff8910: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8920: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8930: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fd\n  0x0c047fff8940: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c047fff8950: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n=>0x0c047fff8960: fa fa[00]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8970: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8980: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8990: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff89a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff89b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-22 10:40:09\n// Signature: decode_length_safe(unsigned long long *res, unsigned char **pos, unsigned char *end)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: decode_length_safe\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"mysql_byteorder.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    unsigned long long res;\n    const unsigned char *pos;\n    const unsigned char *end;\n\n    char *data = fuzzData(0);\n    int len = fuzzGetLen(0);\n    pos = reinterpret_cast<const unsigned char*>(data);\n    end = reinterpret_cast<const unsigned char*>(data + len);\n\n    decode_length_safe(&res, &pos, end);\n\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  56: static inline uint64_t uint8korr(const unsigned char *A)\n  57: {\n  58: \tuint64_t ret;\n  59: \tmemcpy(&ret, A, sizeof(ret));\n  60: \treturn ret;\n  61: }\n  62: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71:\n崩溃的严重程度是什么？", "A": "低危", "B": "高危", "C": "不确定", "D": "中危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==311==ERROR: AddressSanitizer: unknown-crash on address 0x60e000010c8e at pc 0x5615bfb94828 bp 0x7ffc818530e0 sp 0x7ffc818530d0\nREAD of size 8 at 0x60e000010c8e thread T0\n    #0 0x5615bfb94827 in uint8korr /sourcecode/src/protocol/mysql_byteorder.h:58\n    #1 0x5615bfb95092 in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:61\n    #2 0x5615bfb95259 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x5615bfb93054 in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:425\n    #4 0x5615bfb8e2ba in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x5615bfb8c77b in fuzzloop /sharedockerin/ta1729664327849pfow/test_file.cpp:21\n    #6 0x5615bfb9dc19 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #7 0x5615bfb8c448 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #8 0x7facca366d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #9 0x7facca366e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #10 0x5615bfb8c594 in _start (/sharedockerin/ta1729664327849pfow/clouditera+0x19594)\n\n0x60e000010c95 is located 0 bytes to the right of 149-byte region [0x60e000010c00,0x60e000010c95)\nallocated by thread T0 here:\n    #0 0x7faccaf8d887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x5615bfb9de2c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: unknown-crash /sourcecode/src/protocol/mysql_byteorder.h:58 in uint8korr\nShadow bytes around the buggy address:\n  0x0c1c7fffa140: fa fa fa fa fa fa fa fa fd fd fd fd fd fd fd fd\n  0x0c1c7fffa150: fd fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa\n  0x0c1c7fffa160: fa fa fa fa fd fd fd fd fd fd fd fd fd fd fd fd\n  0x0c1c7fffa170: fd fd fd fd fd fd fd fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n=>0x0c1c7fffa190: 00[00]05 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa1a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa1b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa1c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa1d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c1c7fffa1e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:06\n// Signature: mysql_parser_get_err_msg(char **err_msg_str, size_t *err_msg_len, mysql_parser_t *parser)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: mysql_parser_get_err_msg\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"src/protocol/MySQLResult.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    mysql_parser_t parser;\n    mysql_parser_init(&parser);\n\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n\n    int ret = mysql_parser_parse(buf, len, &parser);\n    if (ret == 0) {\n        const char* err_msg_str;\n        size_t err_msg_len;\n        mysql_parser_get_err_msg(&err_msg_str, &err_msg_len, &parser);\n    }\n\n    mysql_parser_deinit(&parser);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  56: static inline uint64_t uint8korr(const unsigned char *A)\n  57: {\n  58: \tuint64_t ret;\n  59: \tmemcpy(&ret, A, sizeof(ret));\n  60: \treturn ret;\n  61: }\n  62: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #4:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92:\n崩溃的严重程度是什么？", "A": "低危", "B": "中危", "C": "不确定", "D": "高危", "answer": "A"}
{"question": "进行模糊测试触发崩溃，崩溃日志如下：\n=================================================================\n==299==ERROR: AddressSanitizer: unknown-crash on address 0x602000024775 at pc 0x55cab905b263 bp 0x7ffe5cc8c030 sp 0x7ffe5cc8c020\nREAD of size 8 at 0x602000024775 thread T0\n    #0 0x55cab905b262 in uint8korr /sourcecode/src/protocol/mysql_byteorder.h:58\n    #1 0x55cab905bacd in decode_length_safe /sourcecode/src/protocol/mysql_byteorder.c:61\n    #2 0x55cab905bc94 in decode_string /sourcecode/src/protocol/mysql_byteorder.c:77\n    #3 0x55cab9059596 in parse_column_def_packet /sourcecode/src/protocol/mysql_parser.c:410\n    #4 0x55cab9054cf5 in mysql_parser_parse /sourcecode/src/protocol/mysql_parser.c:81\n    #5 0x55cab906b087 in protocol::MySQLResponse::decode_packet(unsigned char const*, unsigned long) /sourcecode/src/protocol/MySQLMessage.cc:623\n    #6 0x55cab8ffd6ae in fuzzloop /sharedockerin/ta1729664328007pfbx/test_file.cpp:19\n    #7 0x55cab90a1929 in fuzzFunction /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:54\n    #8 0x55cab8ffd2b8 in main /home/clouditera/workdir-engine_c/betafuzz/srap/wrapentry.c:78\n    #9 0x7f0f05d35d8f  (/lib/x86_64-linux-gnu/libc.so.6+0x29d8f)\n    #10 0x7f0f05d35e3f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x29e3f)\n    #11 0x55cab8ffd404 in _start (/sharedockerin/ta1729664328007pfbx/clouditera+0x109404)\n\n0x60200002477c is located 0 bytes to the right of 12-byte region [0x602000024770,0x60200002477c)\nallocated by thread T0 here:\n    #0 0x7f0f0695c887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145\n    #1 0x55cab90a1b3c in BetaWmalloc /home/clouditera/workdir-engine_c/betafuzz/srap/wrapsystem.c:88\n\nSUMMARY: AddressSanitizer: unknown-crash /sourcecode/src/protocol/mysql_byteorder.h:58 in uint8korr\nShadow bytes around the buggy address:\n  0x0c047fffc890: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc8a0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc8b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc8c0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fffc8d0: fa fa fd fa fa fa 02 fa fa fa fd fa fa fa fd fa\n=>0x0c047fffc8e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[00]04\n  0x0c047fffc8f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc900: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc910: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc920: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fffc930: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n模糊测试驱动如下：\n// Version: dev-v2.4.6-20241022-a3db99a\n// Date: 2024-10-23 03:46:02\n// Signature: protocol::MySQLResponse::decode_packet(unsigned char *buf, size_t buflen)\n// Language: C++\n// Engine: ClouditeraFuzzAgent\n// Target: _ZN8protocol13MySQLResponse13decode_packetEPKhm\n// CFLAGS is used to specify compile flags, add other flags and separating with space.\n// Note: If CFLAGS is not empty, DON'T remove it.\n// CFLAGS=-DNDEBUG -I. -I./_include/workflow -fno-access-control\n#include \"FuzzAgent.h\" // DON'T remove this line\n#include \"_include/workflow/MySQLMessage.h\"\n\n// main fuzz loop\nextern \"C\" int fuzzloop() {\n    // fuzz code here, you SHOULD NOT add any loop in the fuzz code\n    char* buf = fuzzData(0);\n    int len = fuzzGetLen(0);\n    protocol::MySQLResponse response;\n    response.decode_packet((const unsigned char*)buf, len);\n    return 0;\n}\n调用栈如下：\nStacktrace #0:\nFile: /sourcecode/src/protocol/mysql_byteorder.h\n  56: static inline uint64_t uint8korr(const unsigned char *A)\n  57: {\n  58: \tuint64_t ret;\n  59: \tmemcpy(&ret, A, sizeof(ret));\n  60: \treturn ret;\n  61: }\n  62: \nStacktrace #1:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  21: int decode_length_safe(unsigned long long *res, const unsigned char **pos,\n  22: \t\t\t\t\t   const unsigned char *end)\n  23: {\n  24: \tconst unsigned char *p = *pos;\n  25: \n  26: \tif (p >= end)\n  27: \t\treturn 0;\n  28: \n  29: \tswitch (*p)\n  30: \t{\n  31: \tdefault:\n  32: \t\t*res = *p;\n  33: \t\t*pos = p + 1;\n  34: \t\tbreak;\n  35: \n  36: \tcase 251:\n  37: \t\t*res = (~0ULL);\n  38: \t\t*pos = p + 1;\n  39: \t\tbreak;\n  40: \n  41: \tcase 252:\n  42: \t\tif (p + 2 > end)\n  43: \t\t\treturn 0;\n  44: \n  45: \t\t*res = uint2korr(p + 1);\n  46: \t\t*pos = p + 3;\n  47: \t\tbreak;\n  48: \n  49: \tcase 253:\n  50: \t\tif (p + 3 > end)\n  51: \t\t\treturn 0;\n  52: \n  53: \t\t*res = uint3korr(p + 1);\n  54: \t\t*pos = p + 4;\n  55: \t\tbreak;\n  56: \n  57: \tcase 254:\n  58: \t\tif (p + 8 > end)\n  59: \t\t\treturn 0;\n  60: \n  61: \t\t*res = uint8korr(p + 1);\n  62: \t\t*pos = p + 9;\n  63: \t\tbreak;\n  64: \n  65: \tcase 255:\n  66: \t\treturn -1;\n  67: \t}\n  68: \n  69: \treturn 1;\n  70: }\n  71: \nStacktrace #2:\nFile: /sourcecode/src/protocol/mysql_byteorder.c\n  72: int decode_string(const unsigned char **str, unsigned long long *len,\n  73: \t\t\t\t  const unsigned char **pos, const unsigned char *end)\n  74: {\n  75: \tunsigned long long length;\n  76: \n  77: \tif (decode_length_safe(&length, pos, end) <= 0)\n  78: \t\treturn 0;\n  79: \n  80: \tif (length == (~0ULL))\n  81: \t\tlength = 0;\n  82: \n  83: \tif (*pos + length > end)\n  84: \t\treturn 0;\n  85: \n  86: \t*len = length;\n  87: \t*str = *pos;\n  88: \t*pos = *pos + length;\n  89: \treturn 1;\n  90: }\n  91: \nStacktrace #3:\nFile: /sourcecode/src/protocol/mysql_parser.c\n 396: static int parse_column_def_packet(const void *buf, size_t len, mysql_parser_t *parser)\n 397: {\n 398: \tconst unsigned char *p = (const unsigned char *)buf + parser->offset;\n 399: \tconst unsigned char *buf_end = (const unsigned char *)buf + len;\n 400: \n 401: \tint flag = 0;\n 402: \tconst unsigned char *str;\n 403: \tunsigned long long str_len;\n 404: \tmysql_field_t *field = (mysql_field_t *)malloc(sizeof(mysql_field_t));\n 405: \n 406: \tif (!field)\n 407: \t\treturn -1;\n 408: \n 409: \tdo {\n 410: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 411: \t\t\tbreak;\n 412: \t\tfield->catalog_offset = str - (const unsigned char *)buf;\n 413: \t\tfield->catalog_length = str_len;\n 414: \n 415: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 416: \t\t\tbreak;\n 417: \t\tfield->db_offset = str - (const unsigned char *)buf;\n 418: \t\tfield->db_length = str_len;\n 419: \n 420: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 421: \t\t\tbreak;\n 422: \t\tfield->table_offset = str - (const unsigned char *)buf;\n 423: \t\tfield->table_length = str_len;\n 424: \n 425: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 426: \t\t\tbreak;\n 427: \t\tfield->org_table_offset = str - (const unsigned char *)buf;\n 428: \t\tfield->org_table_length = str_len;\n 429: \n 430: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 431: \t\t\tbreak;\n 432: \t\tfield->name_offset = str - (const unsigned char *)buf;\n 433: \t\tfield->name_length = str_len;\n 434: \n 435: \t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 436: \t\t\tbreak;\n 437: \t\tfield->org_name_offset = str - (const unsigned char *)buf;\n 438: \t\tfield->org_name_length = str_len;\n 439: \n 440: \t\t// the rest needs at least 13\n 441: \t\tif (p + 13 > buf_end)\n 442: \t\t\tbreak;\n 443: \n 444: \t\tp++; // length of the following fields (always 0x0c)\n 445: \t\tfield->charsetnr = uint2korr(p);\n 446: \t\tfield->length = uint4korr(p + 2);\n 447: \t\tfield->data_type = *(p + 6);\n 448: \t\tfield->flags = uint2korr(p + 7);\n 449: \t\tfield->decimals = (int)p[9];\n 450: \t\tp += 12;\n 451: \t\t// if is COM_FIELD_LIST, the rest is a string\n 452: \t\t// 0x03 for COM_QUERY\n 453: \t\tif (parser->cmd == MYSQL_COM_FIELD_LIST)\n 454: \t\t{\n 455: \t\t\tif (decode_string(&str, &str_len, &p, buf_end) == 0)\n 456: \t\t\t\tbreak;\n 457: \t\t\tfield->def_offset = str - (const unsigned char *)buf;\n 458: \t\t\tfield->def_length = str_len;\n 459: \t\t} else {\n 460: \t\t\tfield->def_offset = (size_t)-1;\n 461: \t\t\tfield->def_length = 0;\n 462: \t\t}\n 463: \t\tflag = 1;\n 464: \t} while (0);\n 465: \n 466: \tif (flag == 0)\n 467: \t{\n 468: \t\tfree(field);\n 469: \t\treturn -2;\n 470: \t}\n 471: \n 472: \t//parser->fields.emplace_back(std::move(field));\n 473: \tparser->current_result_set->fields[parser->current_field_count] = field;\n 474: \n 475: \tparser->offset = p - (const unsigned char *)buf;\n 476: \tif (++parser->current_field_count == parser->current_result_set->field_count)\n 477: \t\tparser->parse = parse_field_eof_packet;\n 478: \n 479: \treturn 0;\n 480: }\n 481: \nStacktrace #4:\nFile: /sourcecode/src/protocol/mysql_parser.c\n  75: int mysql_parser_parse(const void *buf, size_t len, mysql_parser_t *parser)\n  76: {\n  77: //\tconst char *end = (const char *)buf + len;\n  78: \tint ret;\n  79: \n  80: \tdo {\n  81: \t\tret = parser->parse(buf, len, parser);\n  82: \t\tif (ret < 0)\n  83: \t\t\treturn ret;\n  84: \n  85: \t\tif (ret > 0 && parser->offset != len)\n  86: \t\t\treturn -2;\n  87: \n  88: \t} while (parser->offset < len);\n  89: \n  90: \treturn ret;\n  91: }\n  92: \nStacktrace #5:\nFile: /sourcecode/src/protocol/MySQLMessage.cc\n 621: int MySQLResponse::decode_packet(const unsigned char *buf, size_t buflen)\n 622: {\n 623: \treturn mysql_parser_parse(buf, buflen, parser_);\n 624: }\n 625:\n崩溃的严重程度是什么？", "A": "高危", "B": "低危", "C": "不确定", "D": "中危", "answer": "B"}
